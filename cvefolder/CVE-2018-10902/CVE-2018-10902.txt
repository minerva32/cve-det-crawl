CVE Number : CVE-2018-10902
Commit Message : 
ALSA: rawmidi: Change resized buffers atomically
Commit Details : 
The SNDRV_RAWMIDI_IOCTL_PARAMS ioctl may resize the buffers and the
current code is racy.  For example, the sequencer client may write to
buffer while it being resized.

As a simple workaround, let's switch to the resized buffer inside the
stream runtime lock.

Reported-by: syzbot+52f83f0ea8df16932f7f@syzkaller.appspotmail.com
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

Before patch : 
 int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,
 			      struct snd_rawmidi_params * params)
 {
 	char *newbuf;
 	struct snd_rawmidi_runtime *runtime = substream >runtime;
 
 	if (substream >append && substream >use_count > 1)
 		return  EINVAL;
 	}
 	if (params >buffer_size != runtime >buffer_size) {
 		newbuf = krealloc(runtime >buffer, params >buffer_size,
 				  GFP_KERNEL);
 		if (!newbuf)
 			return  ENOMEM;
 		runtime >buffer = newbuf;
 		runtime >buffer_size = params >buffer_size;
 		runtime >avail = runtime >buffer_size;
 	}
 	runtime >avail_min = params >avail_min;
 	substream >active_sensing = !params >no_active_sensing;
 int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,
 			     struct snd_rawmidi_params * params)
 {
 	char *newbuf;
 	struct snd_rawmidi_runtime *runtime = substream >runtime;
 
 	snd_rawmidi_drain_input(substream);
 		return  EINVAL;
 	}
 	if (params >buffer_size != runtime >buffer_size) {
 		newbuf = krealloc(runtime >buffer, params >buffer_size,
 				  GFP_KERNEL);
 		if (!newbuf)
 			return  ENOMEM;
 		runtime >buffer = newbuf;
 		runtime >buffer_size = params >buffer_size;
 	}
 	runtime >avail_min = params >avail_min;
 	return 0;
After patch : 
 int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,
 			      struct snd_rawmidi_params * params)
 {
 	char *newbuf, *oldbuf;
 	struct snd_rawmidi_runtime *runtime = substream >runtime;
 
 	if (substream >append && substream >use_count > 1)
 		return  EINVAL;
 	}
 	if (params >buffer_size != runtime >buffer_size) {
 		newbuf = kmalloc(params >buffer_size, GFP_KERNEL);
 		if (!newbuf)
 			return  ENOMEM;
 		spin_lock_irq(&runtime >lock);
 		oldbuf = runtime >buffer;
 		runtime >buffer = newbuf;
 		runtime >buffer_size = params >buffer_size;
 		runtime >avail = runtime >buffer_size;
 		runtime >appl_ptr = runtime >hw_ptr = 0;
 		spin_unlock_irq(&runtime >lock);
 		kfree(oldbuf);
 	}
 	runtime >avail_min = params >avail_min;
 	substream >active_sensing = !params >no_active_sensing;
 int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,
 			     struct snd_rawmidi_params * params)
 {
 	char *newbuf, *oldbuf;
 	struct snd_rawmidi_runtime *runtime = substream >runtime;
 
 	snd_rawmidi_drain_input(substream);
 		return  EINVAL;
 	}
 	if (params >buffer_size != runtime >buffer_size) {
 		newbuf = kmalloc(params >buffer_size, GFP_KERNEL);
 		if (!newbuf)
 			return  ENOMEM;
 		spin_lock_irq(&runtime >lock);
 		oldbuf = runtime >buffer;
 		runtime >buffer = newbuf;
 		runtime >buffer_size = params >buffer_size;
 		runtime >appl_ptr = runtime >hw_ptr = 0;
 		spin_unlock_irq(&runtime >lock);
 		kfree(oldbuf);
 	}
 	runtime >avail_min = params >avail_min;
 	return 0;
