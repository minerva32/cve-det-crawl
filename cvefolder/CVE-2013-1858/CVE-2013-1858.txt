CVE Number : CVE-2013-1858
Commit Message : 
userns: Don't allow CLONE_NEWUSER | CLONE_FS
Commit Details : 
Don't allowing sharing the root directory with processes in a
different user namespace.  There doesn't seem to be any point, and to
allow it would require the overhead of putting a user namespace
reference in fs_struct (for permission checks) and incrementing that
reference count on practically every call to fork.

So just perform the inexpensive test of forbidding sharing fs_struct
acrosss processes in different user namespaces.  We already disallow
other forms of threading when unsharing a user namespace so this
should be no real burden in practice.

This updates setns, clone, and unshare to disallow multiple user
namespaces sharing an fs_struct.

Cc: stable@vger.kernel.org
Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
 		return ERR_PTR( EINVAL);
 
 	/*
 	 * Thread groups must share signals as well, and detached threads
 	 * can only be started up within the thread group.
 	 * If unsharing a user namespace must also unshare the thread.
 	 */
 	if (unshare_flags & CLONE_NEWUSER)
 		unshare_flags |= CLONE_THREAD;
 	/*
 	 * If unsharing a pid namespace must also unshare the thread.
 	 */
 #include <linux/uaccess.h>
 #include <linux/ctype.h>
 #include <linux/projid.h>
 
 static struct kmem_cache *user_ns_cachep __read_mostly;
 
 	if (atomic_read(&current >mm >mm_users) > 1)
 		return  EINVAL;
 
 	if (!ns_capable(user_ns, CAP_SYS_ADMIN))
 		return  EPERM;
 
After patch : 
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
 		return ERR_PTR( EINVAL);
 
 	if ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))
 		return ERR_PTR( EINVAL);
 
 	/*
 	 * Thread groups must share signals as well, and detached threads
 	 * can only be started up within the thread group.
 	 * If unsharing a user namespace must also unshare the thread.
 	 */
 	if (unshare_flags & CLONE_NEWUSER)
 		unshare_flags |= CLONE_THREAD | CLONE_FS;
 	/*
 	 * If unsharing a pid namespace must also unshare the thread.
 	 */
 #include <linux/uaccess.h>
 #include <linux/ctype.h>
 #include <linux/projid.h>
 #include <linux/fs_struct.h>
 
 static struct kmem_cache *user_ns_cachep __read_mostly;
 
 	if (atomic_read(&current >mm >mm_users) > 1)
 		return  EINVAL;
 
 	if (current >fs >users != 1)
 		return  EINVAL;
 
 	if (!ns_capable(user_ns, CAP_SYS_ADMIN))
 		return  EPERM;
 
