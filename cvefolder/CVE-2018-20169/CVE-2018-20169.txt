CVE Number : CVE-2018-20169
Commit Message : 
USB: check usb_get_extra_descriptor for proper size
Commit Details : 
When reading an extra descriptor, we need to properly check the minimum
and maximum size allowed, to prevent from invalid data being sent by a
device.

Reported-by: Hui Peng <benquike@gmail.com>
Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
Co-developed-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Hui Peng <benquike@gmail.com>
Signed-off-by: Mathias Payer <mathias.payer@nebelwelt.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Before patch : 
 		/* descriptor may appear anywhere in config */
 		err = __usb_get_extra_descriptor(udev >rawdescriptors[0],
 				le16_to_cpu(udev >config[0].desc.wTotalLength),
 				USB_DT_OTG, (void **) &desc);
 		if (err || !(desc >bmAttributes & USB_OTG_HNP))
 			return 0;
 
  */
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
 			       unsigned char type, void **ptr)
 {
 	struct usb_descriptor_header *header;
 
 	while (size >= sizeof(struct usb_descriptor_header)) {
 		header = (struct usb_descriptor_header *)buffer;
 
 		if (header >bLength < 2) {
 			printk(KERN_ERR
 				"%s: bogus descriptor, type %d length %d\n",
 				usbcore_name,
 			return  1;
 		}
 
 		if (header >bDescriptorType == type) {
 			*ptr = header;
 			return 0;
 		}
 	top = itr   itr_size;
 	result = __usb_get_extra_descriptor(usb_dev >rawdescriptors[index],
 			le16_to_cpu(usb_dev >actconfig >desc.wTotalLength),
 			USB_DT_SECURITY, (void **) &secd);
 	if (result ==  1) {
 		dev_warn(dev, "BUG? WUSB host has no security descriptors\n");
 		return 0;
 };
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
 	unsigned char type, void **ptr);
 #define usb_get_extra_descriptor(ifpoint, type, ptr) \
 				__usb_get_extra_descriptor((ifpoint) >extra, \
 				(ifpoint) >extralen, \
 				type, (void **)ptr)
 
 /*                                                                         */
 
After patch : 
 		/* descriptor may appear anywhere in config */
 		err = __usb_get_extra_descriptor(udev >rawdescriptors[0],
 				le16_to_cpu(udev >config[0].desc.wTotalLength),
 				USB_DT_OTG, (void **) &desc, sizeof(*desc));
 		if (err || !(desc >bmAttributes & USB_OTG_HNP))
 			return 0;
 
  */
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
 			       unsigned char type, void **ptr, size_t minsize)
 {
 	struct usb_descriptor_header *header;
 
 	while (size >= sizeof(struct usb_descriptor_header)) {
 		header = (struct usb_descriptor_header *)buffer;
 
 		if (header >bLength < 2 || header >bLength > size) {
 			printk(KERN_ERR
 				"%s: bogus descriptor, type %d length %d\n",
 				usbcore_name,
 			return  1;
 		}
 
 		if (header >bDescriptorType == type && header >bLength >= minsize) {
 			*ptr = header;
 			return 0;
 		}
 	top = itr   itr_size;
 	result = __usb_get_extra_descriptor(usb_dev >rawdescriptors[index],
 			le16_to_cpu(usb_dev >actconfig >desc.wTotalLength),
 			USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
 	if (result ==  1) {
 		dev_warn(dev, "BUG? WUSB host has no security descriptors\n");
 		return 0;
 };
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
 	unsigned char type, void **ptr, size_t min);
 #define usb_get_extra_descriptor(ifpoint, type, ptr) \
 				__usb_get_extra_descriptor((ifpoint) >extra, \
 				(ifpoint) >extralen, \
 				type, (void **)ptr, sizeof(**(ptr)))
 
 /*                                                                         */
 
