CVE Number : CVE-2019-25045
Commit Message : 
xfrm: clean up xfrm protocol checks
Commit Details : 
In commit 6a53b7593233 ("xfrm: check id proto in validate_tmpl()")
I introduced a check for xfrm protocol, but according to Herbert
IPSEC_PROTO_ANY should only be used as a wildcard for lookup, so
it should be removed from validate_tmpl().

And, IPSEC_PROTO_ANY is expected to only match 3 IPSec-specific
protocols, this is why xfrm_state_flush() could still miss
IPPROTO_ROUTING, which leads that those entries are left in
net->xfrm.state_all before exit net. Fix this by replacing
IPSEC_PROTO_ANY with zero.

This patch also extracts the check from validate_tmpl() to
xfrm_id_proto_valid() and uses it in parse_ipsecrequest().
With this, no other protocols should be added into xfrm.

Fixes: 6a53b7593233 ("xfrm: check id proto in validate_tmpl()")
Reported-by: syzbot+0bf0519d6e0de15914fe@syzkaller.appspotmail.com
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Cc: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

Before patch : 
 	return atomic_read(&x >tunnel_users);
 }
 
 static inline int xfrm_id_proto_match(u8 proto, u8 userproto)
 {
 	return (!userproto || proto == userproto ||
 	unsigned int i;
 
 	xfrm_flush_gc();
 	xfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);
 
 	for (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i  )
 		WARN_ON_ONCE(!hlist_empty(&xfrm6_tn >spi_byaddr[i]));
 
 	if (rq >sadb_x_ipsecrequest_mode == 0)
 		return  EINVAL;
 
 	t >id.proto = rq >sadb_x_ipsecrequest_proto; /* XXX check proto */
 	if ((mode = pfkey_mode_to_xfrm(rq >sadb_x_ipsecrequest_mode)) < 0)
 		return  EINVAL;
 	t >mode = mode;
 
 	flush_work(&net >xfrm.state_hash_work);
 	flush_work(&xfrm_state_gc_work);
 	xfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);
 
 	WARN_ON(!list_empty(&net >xfrm.state_all));
 
 			return  EINVAL;
 		}
 
 		switch (ut[i].id.proto) {
 		case IPPROTO_AH:
 		case IPPROTO_ESP:
 		case IPPROTO_COMP:
 #if IS_ENABLED(CONFIG_IPV6)
 		case IPPROTO_ROUTING:
 		case IPPROTO_DSTOPTS:
 #endif
 		case IPSEC_PROTO_ANY:
 			break;
 		default:
 			return  EINVAL;
 		}
 
 	}
 
 	return 0;
After patch : 
 	return atomic_read(&x >tunnel_users);
 }
 
 static inline bool xfrm_id_proto_valid(u8 proto)
 {
 	switch (proto) {
 	case IPPROTO_AH:
 	case IPPROTO_ESP:
 	case IPPROTO_COMP:
 #if IS_ENABLED(CONFIG_IPV6)
 	case IPPROTO_ROUTING:
 	case IPPROTO_DSTOPTS:
 #endif
 		return true;
 	default:
 		return false;
 	}
 }
 
 /* IPSEC_PROTO_ANY only matches 3 IPsec protocols, 0 could match all. */
 static inline int xfrm_id_proto_match(u8 proto, u8 userproto)
 {
 	return (!userproto || proto == userproto ||
 	unsigned int i;
 
 	xfrm_flush_gc();
 	xfrm_state_flush(net, 0, false, true);
 
 	for (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i  )
 		WARN_ON_ONCE(!hlist_empty(&xfrm6_tn >spi_byaddr[i]));
 
 	if (rq >sadb_x_ipsecrequest_mode == 0)
 		return  EINVAL;
 	if (!xfrm_id_proto_valid(rq >sadb_x_ipsecrequest_proto))
 		return  EINVAL;
 
 	t >id.proto = rq >sadb_x_ipsecrequest_proto;
 	if ((mode = pfkey_mode_to_xfrm(rq >sadb_x_ipsecrequest_mode)) < 0)
 		return  EINVAL;
 	t >mode = mode;
 
 	flush_work(&net >xfrm.state_hash_work);
 	flush_work(&xfrm_state_gc_work);
 	xfrm_state_flush(net, 0, false, true);
 
 	WARN_ON(!list_empty(&net >xfrm.state_all));
 
 			return  EINVAL;
 		}
 
 		if (!xfrm_id_proto_valid(ut[i].id.proto))
 			return  EINVAL;
 	}
 
 	return 0;
