CVE Number : CVE-2008-3275
Commit Message : 
patch vfs: fix lookup on deleted directory
Commit Details : 
Lookup can install a child dentry for a deleted directory.  This keeps
the directory dentry alive, and the inode pinned in the cache and on
disk, even after all external references have gone away.

This isn't a big problem normally, since memory pressure or umount
will clear out the directory dentry and its children, releasing the
inode.  But for UBIFS this causes problems because its orphan area can
overflow.

Fix this by returning ENOENT for all lookups on a S_DEAD directory
before creating a child dentry.

Thanks to Zoltan Sogor for noticing this while testing UBIFS, and
Artem for the excellent analysis of the problem and testing.

Reported-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Tested-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

Before patch : 
 	 */
 	result = d_lookup(parent, name);
 	if (!result) {
 		struct dentry * dentry = d_alloc(parent, name);
 		result = ERR_PTR( ENOMEM);
 		if (dentry) {
 			result = dir >i_op >lookup(dir, dentry, nd);
 			else
 				result = dentry;
 		}
 		mutex_unlock(&dir >i_mutex);
 		return result;
 	}
 
 	dentry = cached_lookup(base, name, nd);
 	if (!dentry) {
 		struct dentry *new = d_alloc(base, name);
 		dentry = ERR_PTR( ENOMEM);
 		if (!new)
 			goto out;
After patch : 
 	 */
 	result = d_lookup(parent, name);
 	if (!result) {
 		struct dentry *dentry;
 
 		/* Don't create child dentry for a dead directory. */
 		result = ERR_PTR( ENOENT);
 		if (IS_DEADDIR(dir))
 			goto out_unlock;
 
 		dentry = d_alloc(parent, name);
 		result = ERR_PTR( ENOMEM);
 		if (dentry) {
 			result = dir >i_op >lookup(dir, dentry, nd);
 			else
 				result = dentry;
 		}
 out_unlock:
 		mutex_unlock(&dir >i_mutex);
 		return result;
 	}
 
 	dentry = cached_lookup(base, name, nd);
 	if (!dentry) {
 		struct dentry *new;
 
 		/* Don't create child dentry for a dead directory. */
 		dentry = ERR_PTR( ENOENT);
 		if (IS_DEADDIR(inode))
 			goto out;
 
 		new = d_alloc(base, name);
 		dentry = ERR_PTR( ENOMEM);
 		if (!new)
 			goto out;
