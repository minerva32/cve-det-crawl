CVE Number : CVE-2017-1000252
Commit Message : 
KVM: VMX: Do not BUG() on out-of-bounds guest IRQ
Commit Details : 
The value of the guest_irq argument to vmx_update_pi_irte() is
ultimately coming from a KVM_IRQFD API call. Do not BUG() in
vmx_update_pi_irte() if the value is out-of bounds. (Especially,
since KVM as a whole seems to hang after that.)

Instead, print a message only once if we find that we don't have a
route for a certain IRQ (which can be out-of-bounds or within the
array).

This fixes CVE-2017-1000252.

Fixes: efc644048ecde54 ("KVM: x86: Update IRTE for posted-interrupts")
Signed-off-by: Jan H. Sch√∂nherr <jschoenh@amazon.de>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

Before patch : 
 	struct kvm_lapic_irq irq;
 	struct kvm_vcpu *vcpu;
 	struct vcpu_data vcpu_info;
 	int idx, ret =  EINVAL;
 
 	if (!kvm_arch_has_assigned_device(kvm) ||
 		!irq_remapping_cap(IRQ_POSTING_CAP) ||
 
 	idx = srcu_read_lock(&kvm >irq_srcu);
 	irq_rt = srcu_dereference(kvm >irq_routing, &kvm >irq_srcu);
 	BUG_ON(guest_irq >= irq_rt >nr_rt_entries);
 
 	hlist_for_each_entry(e, &irq_rt >map[guest_irq], link) {
 		if (e >type != KVM_IRQ_ROUTING_MSI)
After patch : 
 	struct kvm_lapic_irq irq;
 	struct kvm_vcpu *vcpu;
 	struct vcpu_data vcpu_info;
 	int idx, ret = 0;
 
 	if (!kvm_arch_has_assigned_device(kvm) ||
 		!irq_remapping_cap(IRQ_POSTING_CAP) ||
 
 	idx = srcu_read_lock(&kvm >irq_srcu);
 	irq_rt = srcu_dereference(kvm >irq_routing, &kvm >irq_srcu);
 	if (guest_irq >= irq_rt >nr_rt_entries ||
 	    hlist_empty(&irq_rt >map[guest_irq])) {
 		pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
 			     guest_irq, irq_rt >nr_rt_entries);
 		goto out;
 	}
 
 	hlist_for_each_entry(e, &irq_rt >map[guest_irq], link) {
 		if (e >type != KVM_IRQ_ROUTING_MSI)
