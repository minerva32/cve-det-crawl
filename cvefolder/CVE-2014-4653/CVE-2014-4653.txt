CVE Number : CVE-2014-4653
Commit Message : 
ALSA: control: Don't access controls outside of protected regions
Commit Details : 
A control that is visible on the card->controls list can be freed at any time.
This means we must not access any of its memory while not holding the
controls_rw_lock. Otherwise we risk a use after free access.

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Acked-by: Jaroslav Kysela <perex@perex.cz>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

Before patch : 
 {
 	struct snd_ctl_elem_id id;
 	unsigned int idx;
 	int err =  EINVAL;
 
 	if (! kcontrol)
 	card >controls_count  = kcontrol >count;
 	kcontrol >id.numid = card >last_numid   1;
 	card >last_numid  = kcontrol >count;
 	up_write(&card >controls_rwsem);
 	for (idx = 0; idx < kcontrol >count; idx  , id.index  , id.numid  )
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
 	return 0;
 
 		    bool add_on_replace)
 {
 	struct snd_ctl_elem_id id;
 	unsigned int idx;
 	struct snd_kcontrol *old;
 	int ret;
 	card >controls_count  = kcontrol >count;
 	kcontrol >id.numid = card >last_numid   1;
 	card >last_numid  = kcontrol >count;
 	up_write(&card >controls_rwsem);
 	for (idx = 0; idx < kcontrol >count; idx  , id.index  , id.numid  )
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
 	return 0;
 
 			result = kctl >put(kctl, control);
 		}
 		if (result > 0) {
 			up_read(&card >controls_rwsem);
 			snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
 				       &control >id);
 			return 0;
 		}
 	}
 		}
 		err = kctl >tlv.c(kctl, op_flag, tlv.length, _tlv >tlv);
 		if (err > 0) {
 			up_read(&card >controls_rwsem);
 			snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &kctl >id);
 			return 0;
 		}
 	} else {
After patch : 
 {
 	struct snd_ctl_elem_id id;
 	unsigned int idx;
 	unsigned int count;
 	int err =  EINVAL;
 
 	if (! kcontrol)
 	card >controls_count  = kcontrol >count;
 	kcontrol >id.numid = card >last_numid   1;
 	card >last_numid  = kcontrol >count;
 	count = kcontrol >count;
 	up_write(&card >controls_rwsem);
 	for (idx = 0; idx < count; idx  , id.index  , id.numid  )
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
 	return 0;
 
 		    bool add_on_replace)
 {
 	struct snd_ctl_elem_id id;
 	unsigned int count;
 	unsigned int idx;
 	struct snd_kcontrol *old;
 	int ret;
 	card >controls_count  = kcontrol >count;
 	kcontrol >id.numid = card >last_numid   1;
 	card >last_numid  = kcontrol >count;
 	count = kcontrol >count;
 	up_write(&card >controls_rwsem);
 	for (idx = 0; idx < count; idx  , id.index  , id.numid  )
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
 	return 0;
 
 			result = kctl >put(kctl, control);
 		}
 		if (result > 0) {
 			struct snd_ctl_elem_id id = control >id;
 			up_read(&card >controls_rwsem);
 			snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &id);
 			return 0;
 		}
 	}
 		}
 		err = kctl >tlv.c(kctl, op_flag, tlv.length, _tlv >tlv);
 		if (err > 0) {
 			struct snd_ctl_elem_id id = kctl >id;
 			up_read(&card >controls_rwsem);
 			snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &id);
 			return 0;
 		}
 	} else {
