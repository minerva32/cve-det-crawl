CVE Number : CVE-2009-3620
Commit Message : 
drm/r128: Add test for initialisation to all ioctls that require it
Commit Details : 
Almost all r128's private ioctls require that the CCE state has
already been initialised.  However, most do not test that this has
been done, and will proceed to dereference a null pointer.  This may
result in a security vulnerability, since some ioctls are
unprivileged.

This adds a macro for the common initialisation test and changes all
ioctl implementations that require prior initialisation to use that
macro.

Also, r128_do_init_cce() does not test that the CCE state has not
been initialised already.  Repeated initialisation may lead to a crash
or resource leak.  This adds that test.

Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: Dave Airlie <airlied@redhat.com>

Before patch : 
 
 	DRM_DEBUG("\n");
 
 	dev_priv = kzalloc(sizeof(drm_r128_private_t), GFP_KERNEL);
 	if (dev_priv == NULL)
 		return  ENOMEM;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	if (dev_priv >cce_running || dev_priv >cce_mode == R128_PM4_NONPM4) {
 		DRM_DEBUG("while CCE running\n");
 		return 0;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	/* Flush any pending CCE commands.  This ensures any outstanding
 	 * commands are exectuted by the engine before we turn it off.
 	 */
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	if (!dev_priv) {
 		DRM_DEBUG("called before init done\n");
 		return  EINVAL;
 	}
 
 	r128_do_cce_reset(dev_priv);
 
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	if (dev_priv >cce_running) {
 		r128_do_cce_flush(dev_priv);
 	}
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	return r128_do_engine_reset(dev);
 }
 
  * Misc helper macros
  */
 
 #define RING_SPACE_TEST_WITH_RETURN( dev_priv )				\
 do {									\
 	drm_r128_ring_buffer_t *ring = &dev_priv >ring; int i;		\
 static int r128_cce_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev >dev_private;
 	drm_r128_sarea_t *sarea_priv = dev_priv >sarea_priv;
 	drm_r128_clear_t *clear = data;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	if (sarea_priv >nbox > R128_NR_SAREA_CLIPRECTS)
 		sarea_priv >nbox = R128_NR_SAREA_CLIPRECTS;
 
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	if (!dev_priv >page_flipping)
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	if (sarea_priv >nbox > R128_NR_SAREA_CLIPRECTS)
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	if (!dev_priv) {
 		DRM_ERROR("called with no initialization\n");
 		return  EINVAL;
 	}
 
 	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
 		  DRM_CURRENTPID, vertex >idx, vertex >count, vertex >discard);
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	if (!dev_priv) {
 		DRM_ERROR("called with no initialization\n");
 		return  EINVAL;
 	}
 
 	DRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n", DRM_CURRENTPID,
 		  elts >idx, elts >start, elts >end, elts >discard);
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DRM_DEBUG("pid=%d index=%d\n", DRM_CURRENTPID, blit >idx);
 
 	if (blit >idx < 0 || blit >idx >= dma >buf_count) {
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	ret =  EINVAL;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	if (DRM_COPY_FROM_USER(&mask, stipple >mask, 32 * sizeof(u32)))
 		return  EFAULT;
 
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	if (!dev_priv) {
 		DRM_ERROR("called with no initialization\n");
 		return  EINVAL;
 	}
 
 	DRM_DEBUG("idx=%d s=%d e=%d d=%d\n",
 		  indirect >idx, indirect >start, indirect >end,
 	drm_r128_getparam_t *param = data;
 	int value;
 
 	if (!dev_priv) {
 		DRM_ERROR("called with no initialization\n");
 		return  EINVAL;
 	}
 
 	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
 
After patch : 
 
 	DRM_DEBUG("\n");
 
 	if (dev >dev_private) {
 		DRM_DEBUG("called when already initialized\n");
 		return  EINVAL;
 	}
 
 	dev_priv = kzalloc(sizeof(drm_r128_private_t), GFP_KERNEL);
 	if (dev_priv == NULL)
 		return  ENOMEM;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	if (dev_priv >cce_running || dev_priv >cce_mode == R128_PM4_NONPM4) {
 		DRM_DEBUG("while CCE running\n");
 		return 0;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	/* Flush any pending CCE commands.  This ensures any outstanding
 	 * commands are exectuted by the engine before we turn it off.
 	 */
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	r128_do_cce_reset(dev_priv);
 
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	if (dev_priv >cce_running) {
 		r128_do_cce_flush(dev_priv);
 	}
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev >dev_private);
 
 	return r128_do_engine_reset(dev);
 }
 
  * Misc helper macros
  */
 
 #define DEV_INIT_TEST_WITH_RETURN(_dev_priv)				\
 do {									\
 	if (!_dev_priv) {						\
 		DRM_ERROR("called with no initialization\n");		\
 		return  EINVAL;						\
 	}								\
 } while (0)
 
 #define RING_SPACE_TEST_WITH_RETURN( dev_priv )				\
 do {									\
 	drm_r128_ring_buffer_t *ring = &dev_priv >ring; int i;		\
 static int r128_cce_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev >dev_private;
 	drm_r128_sarea_t *sarea_priv;
 	drm_r128_clear_t *clear = data;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	sarea_priv = dev_priv >sarea_priv;
 
 	if (sarea_priv >nbox > R128_NR_SAREA_CLIPRECTS)
 		sarea_priv >nbox = R128_NR_SAREA_CLIPRECTS;
 
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	if (!dev_priv >page_flipping)
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	if (sarea_priv >nbox > R128_NR_SAREA_CLIPRECTS)
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
 		  DRM_CURRENTPID, vertex >idx, vertex >count, vertex >discard);
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n", DRM_CURRENTPID,
 		  elts >idx, elts >start, elts >end, elts >discard);
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("pid=%d index=%d\n", DRM_CURRENTPID, blit >idx);
 
 	if (blit >idx < 0 || blit >idx >= dma >buf_count) {
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	ret =  EINVAL;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	if (DRM_COPY_FROM_USER(&mask, stipple >mask, 32 * sizeof(u32)))
 		return  EFAULT;
 
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("idx=%d s=%d e=%d d=%d\n",
 		  indirect >idx, indirect >start, indirect >end,
 	drm_r128_getparam_t *param = data;
 	int value;
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
 
