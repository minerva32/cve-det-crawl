CVE Number : CVE-2017-8071
Commit Message : 
HID: cp2112: fix sleep-while-atomic
Commit Details : 
A recent commit fixing DMA-buffers on stack added a shared transfer
buffer protected by a spinlock. This is broken as the USB HID request
callbacks can sleep. Fix this up by replacing the spinlock with a mutex.

Fixes: 1ffb3c40ffb5 ("HID: cp2112: make transfer buffers DMA capable")
Cc: stable <stable@vger.kernel.org>	# 4.9
Signed-off-by: Johan Hovold <johan@kernel.org>
Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>

Before patch : 
 	atomic_t xfer_avail;
 	struct gpio_chip gc;
 	u8 *in_out_buffer;
 	spinlock_t lock;
 
 	struct gpio_desc *desc[8];
 	bool gpio_poll;
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev >hdev;
 	u8 *buf = dev >in_out_buffer;
 	unsigned long flags;
 	int ret;
 
 	spin_lock_irqsave(&dev >lock, flags);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
 				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
 	ret = 0;
 
 exit:
 	spin_unlock_irqrestore(&dev >lock, flags);
 	return ret <= 0 ? ret :  EIO;
 }
 
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev >hdev;
 	u8 *buf = dev >in_out_buffer;
 	unsigned long flags;
 	int ret;
 
 	spin_lock_irqsave(&dev >lock, flags);
 
 	buf[0] = CP2112_GPIO_SET;
 	buf[1] = value ? 0xff : 0;
 	if (ret < 0)
 		hid_err(hdev, "error setting GPIO values: %d\n", ret);
 
 	spin_unlock_irqrestore(&dev >lock, flags);
 }
 
 static int cp2112_gpio_get_all(struct gpio_chip *chip)
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev >hdev;
 	u8 *buf = dev >in_out_buffer;
 	unsigned long flags;
 	int ret;
 
 	spin_lock_irqsave(&dev >lock, flags);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
 				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
 	ret = buf[1];
 
 exit:
 	spin_unlock_irqrestore(&dev >lock, flags);
 
 	return ret;
 }
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev >hdev;
 	u8 *buf = dev >in_out_buffer;
 	unsigned long flags;
 	int ret;
 
 	spin_lock_irqsave(&dev >lock, flags);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
 				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
 		goto fail;
 	}
 
 	spin_unlock_irqrestore(&dev >lock, flags);
 
 	/*
 	 * Set gpio value when output direction is already set,
 	return 0;
 
 fail:
 	spin_unlock_irqrestore(&dev >lock, flags);
 	return ret < 0 ? ret :  EIO;
 }
 
 	if (!dev >in_out_buffer)
 		return  ENOMEM;
 
 	spin_lock_init(&dev >lock);
 
 	ret = hid_parse(hdev);
 	if (ret) {
After patch : 
 	atomic_t xfer_avail;
 	struct gpio_chip gc;
 	u8 *in_out_buffer;
 	struct mutex lock;
 
 	struct gpio_desc *desc[8];
 	bool gpio_poll;
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev >hdev;
 	u8 *buf = dev >in_out_buffer;
 	int ret;
 
 	mutex_lock(&dev >lock);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
 				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
 	ret = 0;
 
 exit:
 	mutex_unlock(&dev >lock);
 	return ret <= 0 ? ret :  EIO;
 }
 
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev >hdev;
 	u8 *buf = dev >in_out_buffer;
 	int ret;
 
 	mutex_lock(&dev >lock);
 
 	buf[0] = CP2112_GPIO_SET;
 	buf[1] = value ? 0xff : 0;
 	if (ret < 0)
 		hid_err(hdev, "error setting GPIO values: %d\n", ret);
 
 	mutex_unlock(&dev >lock);
 }
 
 static int cp2112_gpio_get_all(struct gpio_chip *chip)
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev >hdev;
 	u8 *buf = dev >in_out_buffer;
 	int ret;
 
 	mutex_lock(&dev >lock);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
 				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
 	ret = buf[1];
 
 exit:
 	mutex_unlock(&dev >lock);
 
 	return ret;
 }
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev >hdev;
 	u8 *buf = dev >in_out_buffer;
 	int ret;
 
 	mutex_lock(&dev >lock);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
 				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
 		goto fail;
 	}
 
 	mutex_unlock(&dev >lock);
 
 	/*
 	 * Set gpio value when output direction is already set,
 	return 0;
 
 fail:
 	mutex_unlock(&dev >lock);
 	return ret < 0 ? ret :  EIO;
 }
 
 	if (!dev >in_out_buffer)
 		return  ENOMEM;
 
 	mutex_init(&dev >lock);
 
 	ret = hid_parse(hdev);
 	if (ret) {
