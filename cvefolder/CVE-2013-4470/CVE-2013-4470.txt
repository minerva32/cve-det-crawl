CVE Number : CVE-2013-4470
Commit Message : 
ip6_output: do skb ufo init for peeked non ufo skb as well
Commit Details : 
Now, if user application does:
sendto len<mtu flag MSG_MORE
sendto len>mtu flag 0
The skb is not treated as fragmented one because it is not initialized
that way. So move the initialization to fix this.

introduced by:
commit e89e9cf539a28df7d0eb1d0a545368e9920b34ac "IPv4/IPv6: UFO Scatter-gather approach"

Signed-off-by: Jiri Pirko <jiri@resnulli.us>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 {
 	struct sk_buff *skb;
 	int err;
 
 	/* There is support for UDP large send offload by network
 	 * udp datagram
 	 */
 	if ((skb = skb_peek_tail(&sk >sk_write_queue)) == NULL) {
 		struct frag_hdr fhdr;
 
 		skb = sock_alloc_send_skb(sk,
 			hh_len   fragheaderlen   transhdrlen   20,
 			(flags & MSG_DONTWAIT), &err);
 		skb >transport_header = skb >network_header   fragheaderlen;
 
 		skb >protocol = htons(ETH_P_IPV6);
 		skb >ip_summed = CHECKSUM_PARTIAL;
 		skb >csum = 0;
 
 		/* Specify the length of each IPv6 datagram fragment.
 		 * It has to be a multiple of 8.
 		 */
 		skb_shinfo(skb) >gso_size = (mtu   fragheaderlen  
 					     sizeof(struct frag_hdr)) & ~7;
 		skb_shinfo(skb) >gso_type = SKB_GSO_UDP;
 		ipv6_select_ident(&fhdr, rt);
 		skb_shinfo(skb) >ip6_frag_id = fhdr.identification;
 		__skb_queue_tail(&sk >sk_write_queue, skb);
 	}
 
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length   transhdrlen));
 }
After patch : 
 
 {
 	struct sk_buff *skb;
 	struct frag_hdr fhdr;
 	int err;
 
 	/* There is support for UDP large send offload by network
 	 * udp datagram
 	 */
 	if ((skb = skb_peek_tail(&sk >sk_write_queue)) == NULL) {
 		skb = sock_alloc_send_skb(sk,
 			hh_len   fragheaderlen   transhdrlen   20,
 			(flags & MSG_DONTWAIT), &err);
 		skb >transport_header = skb >network_header   fragheaderlen;
 
 		skb >protocol = htons(ETH_P_IPV6);
 		skb >csum = 0;
 
 		__skb_queue_tail(&sk >sk_write_queue, skb);
 	} else if (skb_is_gso(skb)) {
 		goto append;
 	}
 
 	skb >ip_summed = CHECKSUM_PARTIAL;
 	/* Specify the length of each IPv6 datagram fragment.
 	 * It has to be a multiple of 8.
 	 */
 	skb_shinfo(skb) >gso_size = (mtu   fragheaderlen  
 				     sizeof(struct frag_hdr)) & ~7;
 	skb_shinfo(skb) >gso_type = SKB_GSO_UDP;
 	ipv6_select_ident(&fhdr, rt);
 	skb_shinfo(skb) >ip6_frag_id = fhdr.identification;
 
 append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length   transhdrlen));
 }
