CVE Number : CVE-2012-3520
Commit Message : 
af_netlink: force credentials passing CVE-2012-3520
Commit Details : 
Pablo Neira Ayuso discovered that avahi and
potentially NetworkManager accept spoofed Netlink messages because of a
kernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data
to the receiver if the sender did not provide such data, instead of not
including any such data at all or including the correct data from the
peer (as it is the case with AF_UNIX).

This bug was introduced in commit 16e572626961
(af_unix: dont send SCM_CREDENTIALS by default)

This patch forces passing credentials for netlink, as
before the regression.

Another fix would be to not add SCM_CREDENTIALS in
netlink messages if not provided by the sender, but it
might break some programs.

With help from Florian Weimer & Petr Matousek

This issue is designated as CVE-2012-3520

Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Cc: Florian Weimer <fweimer@redhat.com>
Cc: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 }
 
 static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
 			       struct scm_cookie *scm)
 {
 	memset(scm, 0, sizeof(*scm));
 	unix_get_peersec_dgram(sock, scm);
 	if (msg >msg_controllen <= 0)
 		return 0;
 	if (NULL == siocb >scm)
 		siocb >scm = &scm;
 
 	err = scm_send(sock, msg, siocb >scm);
 	if (err < 0)
 		return err;
 
 	if (NULL == siocb >scm)
 		siocb >scm = &tmp_scm;
 	wait_for_unix_gc();
 	err = scm_send(sock, msg, siocb >scm);
 	if (err < 0)
 		return err;
 
 	if (NULL == siocb >scm)
 		siocb >scm = &tmp_scm;
 	wait_for_unix_gc();
 	err = scm_send(sock, msg, siocb >scm);
 	if (err < 0)
 		return err;
 
After patch : 
 }
 
 static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
 			       struct scm_cookie *scm, bool forcecreds)
 {
 	memset(scm, 0, sizeof(*scm));
 	if (forcecreds)
 		scm_set_cred(scm, task_tgid(current), current_cred());
 	unix_get_peersec_dgram(sock, scm);
 	if (msg >msg_controllen <= 0)
 		return 0;
 	if (NULL == siocb >scm)
 		siocb >scm = &scm;
 
 	err = scm_send(sock, msg, siocb >scm, true);
 	if (err < 0)
 		return err;
 
 	if (NULL == siocb >scm)
 		siocb >scm = &tmp_scm;
 	wait_for_unix_gc();
 	err = scm_send(sock, msg, siocb >scm, false);
 	if (err < 0)
 		return err;
 
 	if (NULL == siocb >scm)
 		siocb >scm = &tmp_scm;
 	wait_for_unix_gc();
 	err = scm_send(sock, msg, siocb >scm, false);
 	if (err < 0)
 		return err;
 
