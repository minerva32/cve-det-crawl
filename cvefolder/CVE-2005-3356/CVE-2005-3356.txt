CVE Number : CVE-2005-3356
Commit Message : 
PATCH Fix double decrement of mqueue_mnt->mnt_count in sys_mq_open
Commit Details : 
Fixed the refcounting on failure exits in sys_mq_open() and
cleaned the logics up.  Rules are actually pretty simple - dentry_open()
expects vfsmount and dentry to be pinned down and it either transfers
them into created struct file or drops them.  Old code had been very
confused in that area - if dentry_open() had failed either in do_open()
or do_create(), we ended up dentry and mqueue_mnt dropped twice, once
by dentry_open() cleanup and then by sys_mq_open().

Fix consists of making the rules for do_create() and do_open()
same as for dentry_open() and updating the sys_mq_open() accordingly;
that actually leads to more straightforward code and less work on
normal path.

Signed-off-by: Al Viro <aviro@redhat.com>
Signed-off-by: Linus Torvalds <torvalds@osdl.org>

Before patch : 
 static struct file *do_create(struct dentry *dir, struct dentry *dentry,
 			int oflag, mode_t mode, struct mq_attr __user *u_attr)
 {
 	struct file *filp;
 	struct mq_attr attr;
 	int ret;
 
 	if (u_attr != NULL) {
 		if (copy_from_user(&attr, u_attr, sizeof(attr)))
 			return ERR_PTR( EFAULT);
 		if (!mq_attr_ok(&attr))
 			return ERR_PTR( EINVAL);
 		/* store for use during create */
 		dentry >d_fsdata = &attr;
 	}
 	ret = vfs_create(dir >d_inode, dentry, mode, NULL);
 	dentry >d_fsdata = NULL;
 	if (ret)
 		return ERR_PTR(ret);
 
 	filp = dentry_open(dentry, mqueue_mnt, oflag);
 	if (!IS_ERR(filp))
 		dget(dentry);
 
 	return filp;
 }
 
 /* Opens existing queue */
 {
 static int oflag2acc[O_ACCMODE] = { MAY_READ, MAY_WRITE,
 					MAY_READ | MAY_WRITE };
 	struct file *filp;
 
 	if ((oflag & O_ACCMODE) == (O_RDWR | O_WRONLY))
 		return ERR_PTR( EINVAL);
 
 	if (permission(dentry >d_inode, oflag2acc[oflag & O_ACCMODE], NULL))
 		return ERR_PTR( EACCES);
 
 	filp = dentry_open(dentry, mqueue_mnt, oflag);
 
 	if (!IS_ERR(filp))
 		dget(dentry);
 
 	return filp;
 }
 
 asmlinkage long sys_mq_open(const char __user *u_name, int oflag, mode_t mode,
 
 	if (oflag & O_CREAT) {
 		if (dentry >d_inode) {	/* entry already exists */
 			filp = (oflag & O_EXCL) ? ERR_PTR( EEXIST) :
 					do_open(dentry, oflag);
 		} else {
 			filp = do_create(mqueue_mnt >mnt_root, dentry,
 						oflag, mode, u_attr);
 		}
 	} else
 		filp = (dentry >d_inode) ? do_open(dentry, oflag) :
 					ERR_PTR( ENOENT);
 
 	dput(dentry);
 
 	if (IS_ERR(filp)) {
 		error = PTR_ERR(filp);
 	fd_install(fd, filp);
 	goto out_upsem;
 
 out_putfd:
 	mntput(mqueue_mnt);
 	put_unused_fd(fd);
 out_err:
 	fd = error;
After patch : 
 static struct file *do_create(struct dentry *dir, struct dentry *dentry,
 			int oflag, mode_t mode, struct mq_attr __user *u_attr)
 {
 	struct mq_attr attr;
 	int ret;
 
 	if (u_attr) {
 		ret =  EFAULT;
 		if (copy_from_user(&attr, u_attr, sizeof(attr)))
 			goto out;
 		ret =  EINVAL;
 		if (!mq_attr_ok(&attr))
 			goto out;
 		/* store for use during create */
 		dentry >d_fsdata = &attr;
 	}
 	ret = vfs_create(dir >d_inode, dentry, mode, NULL);
 	dentry >d_fsdata = NULL;
 	if (ret)
 		goto out;
 
 	return dentry_open(dentry, mqueue_mnt, oflag);
 
 out:
 	dput(dentry);
 	mntput(mqueue_mnt);
 	return ERR_PTR(ret);
 }
 
 /* Opens existing queue */
 {
 static int oflag2acc[O_ACCMODE] = { MAY_READ, MAY_WRITE,
 					MAY_READ | MAY_WRITE };
 
 	if ((oflag & O_ACCMODE) == (O_RDWR | O_WRONLY)) {
 		dput(dentry);
 		mntput(mqueue_mnt);
 		return ERR_PTR( EINVAL);
 	}
 
 	if (permission(dentry >d_inode, oflag2acc[oflag & O_ACCMODE], NULL)) {
 		dput(dentry);
 		mntput(mqueue_mnt);
 		return ERR_PTR( EACCES);
 	}
 
 	return dentry_open(dentry, mqueue_mnt, oflag);
 }
 
 asmlinkage long sys_mq_open(const char __user *u_name, int oflag, mode_t mode,
 
 	if (oflag & O_CREAT) {
 		if (dentry >d_inode) {	/* entry already exists */
 			error =  EEXIST;
 			if (oflag & O_EXCL)
 				goto out;
 			filp = do_open(dentry, oflag);
 		} else {
 			filp = do_create(mqueue_mnt >mnt_root, dentry,
 						oflag, mode, u_attr);
 		}
 	} else {
 		error =  ENOENT;
 		if (!dentry >d_inode)
 			goto out;
 		filp = do_open(dentry, oflag);
 	}
 
 	if (IS_ERR(filp)) {
 		error = PTR_ERR(filp);
 	fd_install(fd, filp);
 	goto out_upsem;
 
 out:
 	dput(dentry);
 	mntput(mqueue_mnt);
 out_putfd:
 	put_unused_fd(fd);
 out_err:
 	fd = error;
