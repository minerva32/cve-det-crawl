CVE Number : CVE-2013-2547
Commit Message : 
crypto: user - fix info leaks in report API
Commit Details : 
Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

Before patch : 
 {
 	struct crypto_report_blkcipher rblkcipher;
 
 	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, "%s", "ablkcipher");
 	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, "%s",
 		 alg >cra_ablkcipher.geniv ?: "<default>");
 
 	rblkcipher.blocksize = alg >cra_blocksize;
 	rblkcipher.min_keysize = alg >cra_ablkcipher.min_keysize;
 {
 	struct crypto_report_blkcipher rblkcipher;
 
 	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, "%s", "givcipher");
 	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, "%s",
 		 alg >cra_ablkcipher.geniv ?: "<built in>");
 
 	rblkcipher.blocksize = alg >cra_blocksize;
 	rblkcipher.min_keysize = alg >cra_ablkcipher.min_keysize;
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg >cra_aead;
 
 	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, "%s", "aead");
 	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, "%s",
 		 aead >geniv ?: "<built in>");
 
 	raead.blocksize = alg >cra_blocksize;
 	raead.maxauthsize = aead >maxauthsize;
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg >cra_aead;
 
 	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, "%s", "nivaead");
 	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, "%s", aead >geniv);
 
 	raead.blocksize = alg >cra_blocksize;
 	raead.maxauthsize = aead >maxauthsize;
 {
 	struct crypto_report_hash rhash;
 
 	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, "%s", "ahash");
 
 	rhash.blocksize = alg >cra_blocksize;
 	rhash.digestsize = __crypto_hash_alg_common(alg) >digestsize;
 {
 	struct crypto_report_blkcipher rblkcipher;
 
 	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, "%s", "blkcipher");
 	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, "%s",
 		 alg >cra_blkcipher.geniv ?: "<default>");
 
 	rblkcipher.blocksize = alg >cra_blocksize;
 	rblkcipher.min_keysize = alg >cra_blkcipher.min_keysize;
 {
 	struct crypto_report_cipher rcipher;
 
 	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, "%s", "cipher");
 
 	rcipher.blocksize = alg >cra_blocksize;
 	rcipher.min_keysize = alg >cra_cipher.cia_min_keysize;
 {
 	struct crypto_report_comp rcomp;
 
 	snprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, "%s", "compression");
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
 static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
 	memcpy(&ualg >cru_name, &alg >cra_name, sizeof(ualg >cru_name));
 	memcpy(&ualg >cru_driver_name, &alg >cra_driver_name,
 	       sizeof(ualg >cru_driver_name));
 	memcpy(&ualg >cru_module_name, module_name(alg >cra_module),
 	       CRYPTO_MAX_ALG_NAME);
 
 	ualg >cru_flags = alg >cra_flags;
 	ualg >cru_refcnt = atomic_read(&alg >cra_refcnt);
 
 	if (alg >cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
 		snprintf(rl.type, CRYPTO_MAX_ALG_NAME, "%s", "larval");
 
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;
 {
 	struct crypto_report_comp rpcomp;
 
 	snprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, "%s", "pcomp");
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rpcomp))
 		goto nla_put_failure;
 {
 	struct crypto_report_rng rrng;
 
 	snprintf(rrng.type, CRYPTO_MAX_ALG_NAME, "%s", "rng");
 
 	rrng.seedsize = alg >cra_rng.seedsize;
 
 	struct crypto_report_hash rhash;
 	struct shash_alg *salg = __crypto_shash_alg(alg);
 
 	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, "%s", "shash");
 	rhash.blocksize = alg >cra_blocksize;
 	rhash.digestsize = salg >digestsize;
 
After patch : 
 {
 	struct crypto_report_blkcipher rblkcipher;
 
 	strncpy(rblkcipher.type, "ablkcipher", sizeof(rblkcipher.type));
 	strncpy(rblkcipher.geniv, alg >cra_ablkcipher.geniv ?: "<default>",
 		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg >cra_blocksize;
 	rblkcipher.min_keysize = alg >cra_ablkcipher.min_keysize;
 {
 	struct crypto_report_blkcipher rblkcipher;
 
 	strncpy(rblkcipher.type, "givcipher", sizeof(rblkcipher.type));
 	strncpy(rblkcipher.geniv, alg >cra_ablkcipher.geniv ?: "<built in>",
 		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg >cra_blocksize;
 	rblkcipher.min_keysize = alg >cra_ablkcipher.min_keysize;
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg >cra_aead;
 
 	strncpy(raead.type, "aead", sizeof(raead.type));
 	strncpy(raead.geniv, aead >geniv ?: "<built in>", sizeof(raead.geniv));
 
 	raead.blocksize = alg >cra_blocksize;
 	raead.maxauthsize = aead >maxauthsize;
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg >cra_aead;
 
 	strncpy(raead.type, "nivaead", sizeof(raead.type));
 	strncpy(raead.geniv, aead >geniv, sizeof(raead.geniv));
 
 	raead.blocksize = alg >cra_blocksize;
 	raead.maxauthsize = aead >maxauthsize;
 {
 	struct crypto_report_hash rhash;
 
 	strncpy(rhash.type, "ahash", sizeof(rhash.type));
 
 	rhash.blocksize = alg >cra_blocksize;
 	rhash.digestsize = __crypto_hash_alg_common(alg) >digestsize;
 {
 	struct crypto_report_blkcipher rblkcipher;
 
 	strncpy(rblkcipher.type, "blkcipher", sizeof(rblkcipher.type));
 	strncpy(rblkcipher.geniv, alg >cra_blkcipher.geniv ?: "<default>",
 		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg >cra_blocksize;
 	rblkcipher.min_keysize = alg >cra_blkcipher.min_keysize;
 {
 	struct crypto_report_cipher rcipher;
 
 	strncpy(rcipher.type, "cipher", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg >cra_blocksize;
 	rcipher.min_keysize = alg >cra_cipher.cia_min_keysize;
 {
 	struct crypto_report_comp rcomp;
 
 	strncpy(rcomp.type, "compression", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
 static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
 	strncpy(ualg >cru_name, alg >cra_name, sizeof(ualg >cru_name));
 	strncpy(ualg >cru_driver_name, alg >cra_driver_name,
 		sizeof(ualg >cru_driver_name));
 	strncpy(ualg >cru_module_name, module_name(alg >cra_module),
 		sizeof(ualg >cru_module_name));
 
 	ualg >cru_type = 0;
 	ualg >cru_mask = 0;
 	ualg >cru_flags = alg >cra_flags;
 	ualg >cru_refcnt = atomic_read(&alg >cra_refcnt);
 
 	if (alg >cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
 		strncpy(rl.type, "larval", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;
 {
 	struct crypto_report_comp rpcomp;
 
 	strncpy(rpcomp.type, "pcomp", sizeof(rpcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rpcomp))
 		goto nla_put_failure;
 {
 	struct crypto_report_rng rrng;
 
 	strncpy(rrng.type, "rng", sizeof(rrng.type));
 
 	rrng.seedsize = alg >cra_rng.seedsize;
 
 	struct crypto_report_hash rhash;
 	struct shash_alg *salg = __crypto_shash_alg(alg);
 
 	strncpy(rhash.type, "shash", sizeof(rhash.type));
 
 	rhash.blocksize = alg >cra_blocksize;
 	rhash.digestsize = salg >digestsize;
 
