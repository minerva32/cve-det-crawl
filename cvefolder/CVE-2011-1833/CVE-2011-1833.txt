CVE Number : CVE-2011-1833
Commit Message : 
Ecryptfs: Add mount option to check uid of device being mounted = expect uid
Commit Details : 
Close a TOCTOU race for mounts done via ecryptfs-mount-private.  The mount
source (device) can be raced when the ownership test is done in userspace.
Provide Ecryptfs a means to force the uid check at mount time.

Signed-off-by: John Johansen <john.johansen@canonical.com>
Cc: <stable@kernel.org>
Signed-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>

Before patch : 
        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,
        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,
        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,
        ecryptfs_opt_err };
 
 static const match_table_t tokens = {
 	{ecryptfs_opt_fn_cipher_key_bytes, "ecryptfs_fn_key_bytes=%u"},
 	{ecryptfs_opt_unlink_sigs, "ecryptfs_unlink_sigs"},
 	{ecryptfs_opt_mount_auth_tok_only, "ecryptfs_mount_auth_tok_only"},
 	{ecryptfs_opt_err, NULL}
 };
 
  * ecryptfs_parse_options
  * @sb: The ecryptfs super block
  * @options: The options passed to the kernel
  *
  * Parse mount options:
  * debug=N 	     ecryptfs_verbosity level for debug output
  *
  * Returns zero on success; non zero on error
  */
 static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 {
 	char *p;
 	int rc = 0;
 	char *cipher_key_bytes_src;
 	char *fn_cipher_key_bytes_src;
 
 	if (!options) {
 		rc =  EINVAL;
 		goto out;
 			mount_crypt_stat >flags |=
 				ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;
 			break;
 		case ecryptfs_opt_err:
 		default:
 			printk(KERN_WARNING
 	const char *err = "Getting sb failed";
 	struct inode *inode;
 	struct path path;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
 		goto out;
 	}
 
 	rc = ecryptfs_parse_options(sbi, raw_data);
 	if (rc) {
 		err = "Error parsing options";
 		goto out;
 			"known incompatibilities\n");
 		goto out_free;
 	}
 	ecryptfs_set_superblock_lower(s, path.dentry >d_sb);
 	s >s_maxbytes = path.dentry >d_sb >s_maxbytes;
 	s >s_blocksize = path.dentry >d_sb >s_blocksize;
After patch : 
        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,
        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,
        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,
        ecryptfs_opt_check_dev_ruid,
        ecryptfs_opt_err };
 
 static const match_table_t tokens = {
 	{ecryptfs_opt_fn_cipher_key_bytes, "ecryptfs_fn_key_bytes=%u"},
 	{ecryptfs_opt_unlink_sigs, "ecryptfs_unlink_sigs"},
 	{ecryptfs_opt_mount_auth_tok_only, "ecryptfs_mount_auth_tok_only"},
 	{ecryptfs_opt_check_dev_ruid, "ecryptfs_check_dev_ruid"},
 	{ecryptfs_opt_err, NULL}
 };
 
  * ecryptfs_parse_options
  * @sb: The ecryptfs super block
  * @options: The options passed to the kernel
  * @check_ruid: set to 1 if device uid should be checked against the ruid
  *
  * Parse mount options:
  * debug=N 	     ecryptfs_verbosity level for debug output
  *
  * Returns zero on success; non zero on error
  */
 static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
 				  uid_t *check_ruid)
 {
 	char *p;
 	int rc = 0;
 	char *cipher_key_bytes_src;
 	char *fn_cipher_key_bytes_src;
 
 	*check_ruid = 0;
 
 	if (!options) {
 		rc =  EINVAL;
 		goto out;
 			mount_crypt_stat >flags |=
 				ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;
 			break;
 		case ecryptfs_opt_check_dev_ruid:
 			*check_ruid = 1;
 			break;
 		case ecryptfs_opt_err:
 		default:
 			printk(KERN_WARNING
 	const char *err = "Getting sb failed";
 	struct inode *inode;
 	struct path path;
 	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
 		goto out;
 	}
 
 	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = "Error parsing options";
 		goto out;
 			"known incompatibilities\n");
 		goto out_free;
 	}
 
 	if (check_ruid && path.dentry >d_inode >i_uid != current_uid()) {
 		rc =  EPERM;
 		printk(KERN_ERR "Mount of device (uid: %d) not owned by "
 		       "requested user (uid: %d)\n",
 		       path.dentry >d_inode >i_uid, current_uid());
 		goto out_free;
 	}
 
 	ecryptfs_set_superblock_lower(s, path.dentry >d_sb);
 	s >s_maxbytes = path.dentry >d_sb >s_maxbytes;
 	s >s_blocksize = path.dentry >d_sb >s_blocksize;
