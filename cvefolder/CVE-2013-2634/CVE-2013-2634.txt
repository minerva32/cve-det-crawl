CVE Number : CVE-2013-2634
Commit Message : 
dcbnl: fix various netlink info leaks
Commit Details : 
The dcb netlink interface leaks stack memory in various places:
* perm_addr buffer is only filled at max with 12 of the 32 bytes but
  copied completely,
* no in-kernel driver fills all fields of an IEEE 802.1Qaz subcommand,
  so we're leaking up to 58 bytes for ieee_ets structs, up to 136 bytes
  for ieee_pfc structs, etc.,
* the same is true for CEE -- no in-kernel driver fills the whole
  struct,

Prevent all of the above stack info leaks by properly initializing the
buffers/structures involved.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 	if (!netdev >dcbnl_ops >getpermhwaddr)
 		return  EOPNOTSUPP;
 
 	netdev >dcbnl_ops >getpermhwaddr(netdev, perm_addr);
 
 	return nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);
 
 	if (ops >ieee_getets) {
 		struct ieee_ets ets;
 		err = ops >ieee_getets(netdev, &ets);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets))
 
 	if (ops >ieee_getmaxrate) {
 		struct ieee_maxrate maxrate;
 		err = ops >ieee_getmaxrate(netdev, &maxrate);
 		if (!err) {
 			err = nla_put(skb, DCB_ATTR_IEEE_MAXRATE,
 
 	if (ops >ieee_getpfc) {
 		struct ieee_pfc pfc;
 		err = ops >ieee_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc))
 	/* get peer info if available */
 	if (ops >ieee_peer_getets) {
 		struct ieee_ets ets;
 		err = ops >ieee_peer_getets(netdev, &ets);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets))
 
 	if (ops >ieee_peer_getpfc) {
 		struct ieee_pfc pfc;
 		err = ops >ieee_peer_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc))
 	/* peer info if available */
 	if (ops >cee_peer_getpg) {
 		struct cee_pg pg;
 		err = ops >cee_peer_getpg(netdev, &pg);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg))
 
 	if (ops >cee_peer_getpfc) {
 		struct cee_pfc pfc;
 		err = ops >cee_peer_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc))
After patch : 
 	if (!netdev >dcbnl_ops >getpermhwaddr)
 		return  EOPNOTSUPP;
 
 	memset(perm_addr, 0, sizeof(perm_addr));
 	netdev >dcbnl_ops >getpermhwaddr(netdev, perm_addr);
 
 	return nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);
 
 	if (ops >ieee_getets) {
 		struct ieee_ets ets;
 		memset(&ets, 0, sizeof(ets));
 		err = ops >ieee_getets(netdev, &ets);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets))
 
 	if (ops >ieee_getmaxrate) {
 		struct ieee_maxrate maxrate;
 		memset(&maxrate, 0, sizeof(maxrate));
 		err = ops >ieee_getmaxrate(netdev, &maxrate);
 		if (!err) {
 			err = nla_put(skb, DCB_ATTR_IEEE_MAXRATE,
 
 	if (ops >ieee_getpfc) {
 		struct ieee_pfc pfc;
 		memset(&pfc, 0, sizeof(pfc));
 		err = ops >ieee_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc))
 	/* get peer info if available */
 	if (ops >ieee_peer_getets) {
 		struct ieee_ets ets;
 		memset(&ets, 0, sizeof(ets));
 		err = ops >ieee_peer_getets(netdev, &ets);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets))
 
 	if (ops >ieee_peer_getpfc) {
 		struct ieee_pfc pfc;
 		memset(&pfc, 0, sizeof(pfc));
 		err = ops >ieee_peer_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc))
 	/* peer info if available */
 	if (ops >cee_peer_getpg) {
 		struct cee_pg pg;
 		memset(&pg, 0, sizeof(pg));
 		err = ops >cee_peer_getpg(netdev, &pg);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg))
 
 	if (ops >cee_peer_getpfc) {
 		struct cee_pfc pfc;
 		memset(&pfc, 0, sizeof(pfc));
 		err = ops >cee_peer_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc))
