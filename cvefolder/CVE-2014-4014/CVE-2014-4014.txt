CVE Number : CVE-2014-4014
Commit Message : 
fs,userns: Change inode_capable to capable_wrt_inode_uidgid
Commit Details : 
The kernel has no concept of capabilities with respect to inodes; inodes
exist independently of namespaces.  For example, inode_capable(inode,
CAP_LINUX_IMMUTABLE) would be nonsense.

This patch changes inode_capable to check for uid and gid mappings and
renames it to capable_wrt_inode_uidgid, which should make it more
obvious what it does.

Fixes CVE-2014-4014.

Cc: Theodore Ts'o <tytso@mit.edu>
Cc: Serge Hallyn <serge.hallyn@ubuntu.com>
Cc: "Eric W. Biederman" <ebiederm@xmission.com>
Cc: Dave Chinner <david@fromorbit.com>
Cc: stable@vger.kernel.org
Signed-off-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 	if ((ia_valid & ATTR_UID) &&
 	    (!uid_eq(current_fsuid(), inode >i_uid) ||
 	     !uid_eq(attr >ia_uid, inode >i_uid)) &&
 	    !inode_capable(inode, CAP_CHOWN))
 		return  EPERM;
 
 	/* Make sure caller can chgrp. */
 	if ((ia_valid & ATTR_GID) &&
 	    (!uid_eq(current_fsuid(), inode >i_uid) ||
 	    (!in_group_p(attr >ia_gid) && !gid_eq(attr >ia_gid, inode >i_gid))) &&
 	    !inode_capable(inode, CAP_CHOWN))
 		return  EPERM;
 
 	/* Make sure a caller can chmod. */
 		/* Also check the setgid bit! */
 		if (!in_group_p((ia_valid & ATTR_GID) ? attr >ia_gid :
 				inode >i_gid) &&
 		    !inode_capable(inode, CAP_FSETID))
 			attr >ia_mode &= ~S_ISGID;
 	}
 
 		umode_t mode = attr >ia_mode;
 
 		if (!in_group_p(inode >i_gid) &&
 		    !inode_capable(inode, CAP_FSETID))
 			mode &= ~S_ISGID;
 		inode >i_mode = mode;
 	}
  * inode_owner_or_capable   check current task permissions to inode
  * @inode: inode being checked
  *
  * Return true if current either has CAP_FOWNER to the inode, or
  * owns the file.
  */
 bool inode_owner_or_capable(const struct inode *inode)
 {
 	if (uid_eq(current_fsuid(), inode >i_uid))
 		return true;
 	if (inode_capable(inode, CAP_FOWNER))
 		return true;
 	return false;
 }
 
 	if (S_ISDIR(inode >i_mode)) {
 		/* DACs are overridable for directories */
 		if (inode_capable(inode, CAP_DAC_OVERRIDE))
 			return 0;
 		if (!(mask & MAY_WRITE))
 			if (inode_capable(inode, CAP_DAC_READ_SEARCH))
 				return 0;
 		return  EACCES;
 	}
 	 * at least one exec bit set.
 	 */
 	if (!(mask & MAY_EXEC) || (inode >i_mode & S_IXUGO))
 		if (inode_capable(inode, CAP_DAC_OVERRIDE))
 			return 0;
 
 	/*
 	 */
 	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
 	if (mask == MAY_READ)
 		if (inode_capable(inode, CAP_DAC_READ_SEARCH))
 			return 0;
 
 	return  EACCES;
 		return 0;
 	if (uid_eq(dir >i_uid, fsuid))
 		return 0;
 	return !inode_capable(inode, CAP_FOWNER);
 }
 
 /*
 		 * cleared upon successful return from chown()
 		 */
 		if ((ip >i_d.di_mode & (S_ISUID|S_ISGID)) &&
 		    !inode_capable(VFS_I(ip), CAP_FSETID))
 			ip >i_d.di_mode &= ~(S_ISUID|S_ISGID);
 
 		/*
 				      struct user_namespace *ns, int cap);
 extern bool capable(int cap);
 extern bool ns_capable(struct user_namespace *ns, int cap);
 extern bool inode_capable(const struct inode *inode, int cap);
 extern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);
 
 /* audit system wants to get cap info from files as well */
 EXPORT_SYMBOL(capable);
 
 /**
  * inode_capable   Check superior capability over inode
  * @inode: The inode in question
  * @cap: The capability in question
  *
  * Return true if the current task has the given superior capability
  * targeted at it's own user namespace and that the given inode is owned
  * by the current user namespace or a child namespace.
  *
  * Currently we check to see if an inode is owned by the current
  * user namespace by seeing if the inode's owner maps into the
  * current user namespace.
  *
  */
 bool inode_capable(const struct inode *inode, int cap)
 {
 	struct user_namespace *ns = current_user_ns();
 
 	return ns_capable(ns, cap) && kuid_has_mapping(ns, inode >i_uid);
 }
 EXPORT_SYMBOL(inode_capable);
After patch : 
 	if ((ia_valid & ATTR_UID) &&
 	    (!uid_eq(current_fsuid(), inode >i_uid) ||
 	     !uid_eq(attr >ia_uid, inode >i_uid)) &&
 	    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))
 		return  EPERM;
 
 	/* Make sure caller can chgrp. */
 	if ((ia_valid & ATTR_GID) &&
 	    (!uid_eq(current_fsuid(), inode >i_uid) ||
 	    (!in_group_p(attr >ia_gid) && !gid_eq(attr >ia_gid, inode >i_gid))) &&
 	    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))
 		return  EPERM;
 
 	/* Make sure a caller can chmod. */
 		/* Also check the setgid bit! */
 		if (!in_group_p((ia_valid & ATTR_GID) ? attr >ia_gid :
 				inode >i_gid) &&
 		    !capable_wrt_inode_uidgid(inode, CAP_FSETID))
 			attr >ia_mode &= ~S_ISGID;
 	}
 
 		umode_t mode = attr >ia_mode;
 
 		if (!in_group_p(inode >i_gid) &&
 		    !capable_wrt_inode_uidgid(inode, CAP_FSETID))
 			mode &= ~S_ISGID;
 		inode >i_mode = mode;
 	}
  * inode_owner_or_capable   check current task permissions to inode
  * @inode: inode being checked
  *
  * Return true if current either has CAP_FOWNER in a namespace with the
  * inode owner uid mapped, or owns the file.
  */
 bool inode_owner_or_capable(const struct inode *inode)
 {
 	struct user_namespace *ns;
 
 	if (uid_eq(current_fsuid(), inode >i_uid))
 		return true;
 
 	ns = current_user_ns();
 	if (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode >i_uid))
 		return true;
 	return false;
 }
 
 	if (S_ISDIR(inode >i_mode)) {
 		/* DACs are overridable for directories */
 		if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))
 			return 0;
 		if (!(mask & MAY_WRITE))
 			if (capable_wrt_inode_uidgid(inode,
 						     CAP_DAC_READ_SEARCH))
 				return 0;
 		return  EACCES;
 	}
 	 * at least one exec bit set.
 	 */
 	if (!(mask & MAY_EXEC) || (inode >i_mode & S_IXUGO))
 		if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))
 			return 0;
 
 	/*
 	 */
 	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
 	if (mask == MAY_READ)
 		if (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))
 			return 0;
 
 	return  EACCES;
 		return 0;
 	if (uid_eq(dir >i_uid, fsuid))
 		return 0;
 	return !capable_wrt_inode_uidgid(inode, CAP_FOWNER);
 }
 
 /*
 		 * cleared upon successful return from chown()
 		 */
 		if ((ip >i_d.di_mode & (S_ISUID|S_ISGID)) &&
 		    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))
 			ip >i_d.di_mode &= ~(S_ISUID|S_ISGID);
 
 		/*
 				      struct user_namespace *ns, int cap);
 extern bool capable(int cap);
 extern bool ns_capable(struct user_namespace *ns, int cap);
 extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);
 extern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);
 
 /* audit system wants to get cap info from files as well */
 EXPORT_SYMBOL(capable);
 
 /**
  * capable_wrt_inode_uidgid   Check nsown_capable and uid and gid mapped
  * @inode: The inode in question
  * @cap: The capability in question
  *
  * Return true if the current task has the given capability targeted at
  * its own user namespace and that the given inode's uid and gid are
  * mapped into the current user namespace.
  */
 bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)
 {
 	struct user_namespace *ns = current_user_ns();
 
 	return ns_capable(ns, cap) && kuid_has_mapping(ns, inode >i_uid) &&
 		kgid_has_mapping(ns, inode >i_gid);
 }
 EXPORT_SYMBOL(capable_wrt_inode_uidgid);
