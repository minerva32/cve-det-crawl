CVE Number : CVE-2013-4205
Commit Message : 
userns: unshare_userns(&cred) should not populate cred on failure
Commit Details : 
unshare_userns(new_cred) does *new_cred = prepare_creds() before
create_user_ns() which can fail. However, the caller expects that
it doesn't need to take care of new_cred if unshare_userns() fails.

We could change the single caller, sys_unshare(), but I think it
would be more clean to avoid the side effects on failure, so with
this patch unshare_userns() does put_cred() itself and initializes
*new_cred only if create_user_ns() succeeeds.

Cc: stable@vger.kernel.org
Signed-off-by: Oleg Nesterov <oleg@redhat.com>
Reviewed-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)
 {
 	struct cred *cred;
 
 	if (!(unshare_flags & CLONE_NEWUSER))
 		return 0;
 
 	cred = prepare_creds();
 	if (!cred)
 		return  ENOMEM;
 
 	*new_cred = cred;
 	return create_user_ns(cred);
 }
 
 void free_user_ns(struct user_namespace *ns)
After patch : 
 int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)
 {
 	struct cred *cred;
 	int err =  ENOMEM;
 
 	if (!(unshare_flags & CLONE_NEWUSER))
 		return 0;
 
 	cred = prepare_creds();
 	if (cred) {
 		err = create_user_ns(cred);
 		if (err)
 			put_cred(cred);
 		else
 			*new_cred = cred;
 	}
 
 	return err;
 }
 
 void free_user_ns(struct user_namespace *ns)
