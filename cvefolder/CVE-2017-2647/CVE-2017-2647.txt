CVE Number : CVE-2017-2647
Commit Message : 
KEYS: Remove key_type::match in favour of overriding default by match_preparse
Commit Details : 
A previous patch added a ->match_preparse() method to the key type.  This is
allowed to override the function called by the iteration algorithm.
Therefore, we can just set a default that simply checks for an exact match of
the key description with the original criterion data and allow match_preparse
to override it as needed.

The key_type::match op is then redundant and can be removed, as can the
user_match() function.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>

Before patch : 
  *	"id:<id>"	  request a key matching the ID
  *	"<subtype>:<id>"   request a key of a subtype
  */
 static int asymmetric_key_match(const struct key *key,
 				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data >raw_data;
 static int asymmetric_key_match_preparse(struct key_match_data *match_data)
 {
 	match_data >lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
 	return 0;
 }
 
 	.free_preparse	= asymmetric_key_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match_preparse	= asymmetric_key_match_preparse,
 	.match		= asymmetric_key_match,
 	.match_free	= asymmetric_key_match_free,
 	.destroy	= asymmetric_key_destroy,
 	.describe	= asymmetric_key_describe,
 	.preparse		= pkcs7_preparse,
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.match			= user_match,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,
 struct key_type cifs_spnego_key_type = {
 	.name		= "cifs.spnego",
 	.instantiate	= cifs_spnego_key_instantiate,
 	.match		= user_match,
 	.destroy	= cifs_spnego_key_destroy,
 	.describe	= user_describe,
 };
 	.instantiate = cifs_idmap_key_instantiate,
 	.destroy     = cifs_idmap_key_destroy,
 	.describe    = user_describe,
 	.match       = user_match,
 };
 
 static char *
 	.preparse	= user_preparse,
 	.free_preparse	= user_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match		= user_match,
 	.revoke		= user_revoke,
 	.destroy	= user_destroy,
 	.describe	= user_describe,
 	.preparse	= user_preparse,
 	.free_preparse	= user_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match		= user_match,
 	.revoke		= user_revoke,
 	.destroy	= user_destroy,
 	.describe	= user_describe,
 extern struct key_type key_type_logon;
 
 struct key_preparsed_payload;
 struct key_match_data;
 
 extern int user_preparse(struct key_preparsed_payload *prep);
 extern void user_free_preparse(struct key_preparsed_payload *prep);
 extern int user_update(struct key *key, struct key_preparsed_payload *prep);
 extern int user_match(const struct key *key,
 		      const struct key_match_data *match_data);
 extern void user_revoke(struct key *key);
 extern void user_destroy(struct key *key);
 extern void user_describe(const struct key *user, struct seq_file *m);
 	 */
 	int (*match_preparse)(struct key_match_data *match_data);
 
 	/* match a key against a description */
 	int (*match)(const struct key *key,
 		     const struct key_match_data *match_data);
 
 	/* Free preparsed match data (optional).  This should be supplied it
 	 *  >match_preparse() is supplied. */
 	void (*match_free)(struct key_match_data *match_data);
 	.preparse	= ceph_key_preparse,
 	.free_preparse	= ceph_key_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match		= user_match,
 	.destroy	= ceph_key_destroy,
 };
 
  * The domain name may be a simple name or an absolute domain name (which
  * should end with a period).  The domain name is case independent.
  */
 static int
 dns_resolver_match(const struct key *key,
 		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key >description, *dsp = match_data >raw_data;
 }
 
 /*
  * Describe a DNS key
  */
 static void dns_resolver_describe(const struct key *key, struct seq_file *m)
 	.preparse	= dns_resolver_preparse,
 	.free_preparse	= dns_resolver_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match		= dns_resolver_match,
 	.revoke		= user_revoke,
 	.destroy	= user_destroy,
 	.describe	= dns_resolver_describe,
 	.preparse	= rxrpc_preparse,
 	.free_preparse	= rxrpc_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match		= user_match,
 	.destroy	= rxrpc_destroy,
 	.describe	= rxrpc_describe,
 	.read		= rxrpc_read,
 	.preparse	= rxrpc_preparse_s,
 	.free_preparse	= rxrpc_free_preparse_s,
 	.instantiate	= generic_key_instantiate,
 	.match		= user_match,
 	.destroy	= rxrpc_destroy_s,
 	.describe	= rxrpc_describe,
 };
 	.preparse		= big_key_preparse,
 	.free_preparse		= big_key_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.match			= user_match,
 	.revoke			= big_key_revoke,
 	.destroy		= big_key_destroy,
 	.describe		= big_key_describe,
 	.name = "encrypted",
 	.instantiate = encrypted_instantiate,
 	.update = encrypted_update,
 	.match = user_match,
 	.destroy = encrypted_destroy,
 	.describe = user_describe,
 	.read = encrypted_read,
 	struct timespec		now;
 };
 
 extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 				    struct keyring_search_context *ctx);
 
 	}
 
 	key_ref = ERR_PTR( EINVAL);
 	if (!index_key.type >match || !index_key.type >instantiate ||
 	    (!index_key.description && !index_key.type >preparse))
 		goto error_put_type;
 
 	.preparse	= keyring_preparse,
 	.free_preparse	= keyring_free_preparse,
 	.instantiate	= keyring_instantiate,
 	.match		= user_match,
 	.revoke		= keyring_revoke,
 	.destroy	= keyring_destroy,
 	.describe	= keyring_describe,
 EXPORT_SYMBOL(keyring_alloc);
 
 /*
  * Iteration function to consider each key found.
  */
 static int keyring_search_iterator(const void *object, void *iterator_data)
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
 		.match_data.cmp		= type >match,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
 	key_ref_t key;
 	int ret;
 
 	if (!ctx.match_data.cmp)
 		return ERR_PTR( ENOKEY);
 
 	if (type >match_preparse) {
 		ret = type >match_preparse(&ctx.match_data);
 		if (ret < 0)
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
 		.match_data.cmp		= type >match,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
 		.index_key.type		= &key_type_request_key_auth,
 		.index_key.description	= description,
 		.cred			= current_cred(),
 		.match_data.cmp		= user_match,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
 	.name = "trusted",
 	.instantiate = trusted_instantiate,
 	.update = trusted_update,
 	.match = user_match,
 	.destroy = trusted_destroy,
 	.describe = user_describe,
 	.read = trusted_read,
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.update			= user_update,
 	.match			= user_match,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.update			= user_update,
 	.match			= user_match,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,
 EXPORT_SYMBOL_GPL(user_update);
 
 /*
  * match users on their name
  */
 int user_match(const struct key *key, const struct key_match_data *match_data)
 {
 	return strcmp(key >description, match_data >raw_data) == 0;
 }
 
 EXPORT_SYMBOL_GPL(user_match);
 
 /*
  * dispose of the links from a revoked keyring
  *   called with the key sem write locked
  */
After patch : 
  *	"id:<id>"	  request a key matching the ID
  *	"<subtype>:<id>"   request a key of a subtype
  */
 static int asymmetric_key_cmp(const struct key *key,
 			      const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data >raw_data;
 static int asymmetric_key_match_preparse(struct key_match_data *match_data)
 {
 	match_data >lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
 	match_data >cmp = asymmetric_key_cmp;
 	return 0;
 }
 
 	.free_preparse	= asymmetric_key_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match_preparse	= asymmetric_key_match_preparse,
 	.match_free	= asymmetric_key_match_free,
 	.destroy	= asymmetric_key_destroy,
 	.describe	= asymmetric_key_describe,
 	.preparse		= pkcs7_preparse,
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,
 struct key_type cifs_spnego_key_type = {
 	.name		= "cifs.spnego",
 	.instantiate	= cifs_spnego_key_instantiate,
 	.destroy	= cifs_spnego_key_destroy,
 	.describe	= user_describe,
 };
 	.instantiate = cifs_idmap_key_instantiate,
 	.destroy     = cifs_idmap_key_destroy,
 	.describe    = user_describe,
 };
 
 static char *
 	.preparse	= user_preparse,
 	.free_preparse	= user_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.revoke		= user_revoke,
 	.destroy	= user_destroy,
 	.describe	= user_describe,
 	.preparse	= user_preparse,
 	.free_preparse	= user_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.revoke		= user_revoke,
 	.destroy	= user_destroy,
 	.describe	= user_describe,
 extern struct key_type key_type_logon;
 
 struct key_preparsed_payload;
 
 extern int user_preparse(struct key_preparsed_payload *prep);
 extern void user_free_preparse(struct key_preparsed_payload *prep);
 extern int user_update(struct key *key, struct key_preparsed_payload *prep);
 extern void user_revoke(struct key *key);
 extern void user_destroy(struct key *key);
 extern void user_describe(const struct key *user, struct seq_file *m);
 	 */
 	int (*match_preparse)(struct key_match_data *match_data);
 
 	/* Free preparsed match data (optional).  This should be supplied it
 	 *  >match_preparse() is supplied. */
 	void (*match_free)(struct key_match_data *match_data);
 	.preparse	= ceph_key_preparse,
 	.free_preparse	= ceph_key_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.destroy	= ceph_key_destroy,
 };
 
  * The domain name may be a simple name or an absolute domain name (which
  * should end with a period).  The domain name is case independent.
  */
 static int dns_resolver_cmp(const struct key *key,
 			    const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key >description, *dsp = match_data >raw_data;
 }
 
 /*
  * Preparse the match criterion.
  */
 static int dns_resolver_match_preparse(struct key_match_data *match_data)
 {
 	match_data >lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
 	match_data >cmp = dns_resolver_cmp;
 	return 0;
 }
 
 /*
  * Describe a DNS key
  */
 static void dns_resolver_describe(const struct key *key, struct seq_file *m)
 	.preparse	= dns_resolver_preparse,
 	.free_preparse	= dns_resolver_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match_preparse	= dns_resolver_match_preparse,
 	.revoke		= user_revoke,
 	.destroy	= user_destroy,
 	.describe	= dns_resolver_describe,
 	.preparse	= rxrpc_preparse,
 	.free_preparse	= rxrpc_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.destroy	= rxrpc_destroy,
 	.describe	= rxrpc_describe,
 	.read		= rxrpc_read,
 	.preparse	= rxrpc_preparse_s,
 	.free_preparse	= rxrpc_free_preparse_s,
 	.instantiate	= generic_key_instantiate,
 	.destroy	= rxrpc_destroy_s,
 	.describe	= rxrpc_describe,
 };
 	.preparse		= big_key_preparse,
 	.free_preparse		= big_key_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.revoke			= big_key_revoke,
 	.destroy		= big_key_destroy,
 	.describe		= big_key_describe,
 	.name = "encrypted",
 	.instantiate = encrypted_instantiate,
 	.update = encrypted_update,
 	.destroy = encrypted_destroy,
 	.describe = user_describe,
 	.read = encrypted_read,
 	struct timespec		now;
 };
 
 extern int key_default_cmp(const struct key *key,
 			   const struct key_match_data *match_data);
 extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 				    struct keyring_search_context *ctx);
 
 	}
 
 	key_ref = ERR_PTR( EINVAL);
 	if (!index_key.type >instantiate ||
 	    (!index_key.description && !index_key.type >preparse))
 		goto error_put_type;
 
 	.preparse	= keyring_preparse,
 	.free_preparse	= keyring_free_preparse,
 	.instantiate	= keyring_instantiate,
 	.revoke		= keyring_revoke,
 	.destroy	= keyring_destroy,
 	.describe	= keyring_describe,
 EXPORT_SYMBOL(keyring_alloc);
 
 /*
  * By default, we keys found by getting an exact match on their descriptions.
  */
 int key_default_cmp(const struct key *key,
 		    const struct key_match_data *match_data)
 {
 	return strcmp(key >description, match_data >raw_data) == 0;
 }
 
 /*
  * Iteration function to consider each key found.
  */
 static int keyring_search_iterator(const void *object, void *iterator_data)
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
 		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
 	key_ref_t key;
 	int ret;
 
 	if (type >match_preparse) {
 		ret = type >match_preparse(&ctx.match_data);
 		if (ret < 0)
 		.index_key.type		= type,
 		.index_key.description	= description,
 		.cred			= current_cred(),
 		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
 		.index_key.type		= &key_type_request_key_auth,
 		.index_key.description	= description,
 		.cred			= current_cred(),
 		.match_data.cmp		= key_default_cmp,
 		.match_data.raw_data	= description,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 	};
 	.name = "trusted",
 	.instantiate = trusted_instantiate,
 	.update = trusted_update,
 	.destroy = trusted_destroy,
 	.describe = user_describe,
 	.read = trusted_read,
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.update			= user_update,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,
 	.free_preparse		= user_free_preparse,
 	.instantiate		= generic_key_instantiate,
 	.update			= user_update,
 	.revoke			= user_revoke,
 	.destroy		= user_destroy,
 	.describe		= user_describe,
 EXPORT_SYMBOL_GPL(user_update);
 
 /*
  * dispose of the links from a revoked keyring
  *   called with the key sem write locked
  */
