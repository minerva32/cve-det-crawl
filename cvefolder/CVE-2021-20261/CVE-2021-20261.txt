CVE Number : CVE-2021-20261
Commit Message : 
floppy: fix lock_fdc() signal handling
Commit Details : 
floppy_revalidate() doesn't perform any error handling on lock_fdc()
result. lock_fdc() might actually be interrupted by a signal (it waits for
fdc becoming non-busy interruptibly). In such case, floppy_revalidate()
proceeds as if it had claimed the lock, but it fact it doesn't.

In case of multiple threads trying to open("/dev/fdX"), this leads to
serious corruptions all over the place, because all of a sudden there is
no critical section protection (that'd otherwise be guaranteed by locked
fd) whatsoever.

While at this, fix the fact that the 'interruptible' parameter to
lock_fdc() doesn't make any sense whatsoever, because we always wait
interruptibly anyway.

Most of the lock_fdc() callsites do properly handle error (and propagate
EINTR), but floppy_revalidate() and floppy_check_events() don't. Fix this.

Spotted by 'syzkaller' tool.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Tested-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>

Before patch : 
 }
 
 /* locks the driver */
 static int lock_fdc(int drive, bool interruptible)
 {
 	if (WARN(atomic_read(&usage_count) == 0,
 		 "Trying to lock fdc while usage count=0\n"))
 {
 	int ret;
 
 	if (lock_fdc(drive, true))
 		return  EINTR;
 
 	set_floppy(drive);
 {
 	int ret;
 
 	if (lock_fdc(drive, interruptible))
 		return  EINTR;
 
 	if (arg == FD_RESET_ALWAYS)
 		if (!capable(CAP_SYS_ADMIN))
 			return  EPERM;
 		mutex_lock(&open_lock);
 		if (lock_fdc(drive, true)) {
 			mutex_unlock(&open_lock);
 			return  EINTR;
 		}
 	} else {
 		int oldStretch;
 
 		if (lock_fdc(drive, true))
 			return  EINTR;
 		if (cmd != FDDEFPRM) {
 			/* notice a disk change immediately, else
 	if (type)
 		*g = &floppy_type[type];
 	else {
 		if (lock_fdc(drive, false))
 			return  EINTR;
 		if (poll_drive(false, 0) ==  EINTR)
 			return  EINTR;
 		if (UDRS >fd_ref != 1)
 			/* somebody else has this drive open */
 			return  EBUSY;
 		if (lock_fdc(drive, true))
 			return  EINTR;
 
 		/* do the actual eject. Fails on
 		process_fd_request();
 		return ret;
 	case FDCLRPRM:
 		if (lock_fdc(drive, true))
 			return  EINTR;
 		current_type[drive] = NULL;
 		floppy_sizes[drive] = MAX_DISK_SIZE << 1;
 		UDP >flags &= ~FTD_MSG;
 		return 0;
 	case FDFMTBEG:
 		if (lock_fdc(drive, true))
 			return  EINTR;
 		if (poll_drive(true, FD_RAW_NEED_DISK) ==  EINTR)
 			return  EINTR;
 		return do_format(drive, &inparam.f);
 	case FDFMTEND:
 	case FDFLUSH:
 		if (lock_fdc(drive, true))
 			return  EINTR;
 		return invalidate_drive(bdev);
 	case FDSETEMSGTRESH:
 		outparam = UDP;
 		break;
 	case FDPOLLDRVSTAT:
 		if (lock_fdc(drive, true))
 			return  EINTR;
 		if (poll_drive(true, FD_RAW_NEED_DISK) ==  EINTR)
 			return  EINTR;
 	case FDRAWCMD:
 		if (type)
 			return  EINVAL;
 		if (lock_fdc(drive, true))
 			return  EINTR;
 		set_floppy(drive);
 		i = raw_cmd_ioctl(cmd, (void __user *)param);
 		process_fd_request();
 		return i;
 	case FDTWADDLE:
 		if (lock_fdc(drive, true))
 			return  EINTR;
 		twaddle();
 		process_fd_request();
 		return DISK_EVENT_MEDIA_CHANGE;
 
 	if (time_after(jiffies, UDRS >last_checked   UDP >checkfreq)) {
 		lock_fdc(drive, false);
 		poll_drive(false, 0);
 		process_fd_request();
 	}
 			 "VFS: revalidate called on non open device.\n"))
 			return  EFAULT;
 
 		lock_fdc(drive, false);
 		cf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS >flags) ||
 		      test_bit(FD_VERIFY_BIT, &UDRS >flags));
 		if (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {
After patch : 
 }
 
 /* locks the driver */
 static int lock_fdc(int drive)
 {
 	if (WARN(atomic_read(&usage_count) == 0,
 		 "Trying to lock fdc while usage count=0\n"))
 {
 	int ret;
 
 	if (lock_fdc(drive))
 		return  EINTR;
 
 	set_floppy(drive);
 {
 	int ret;
 
 	if (lock_fdc(drive))
 		return  EINTR;
 
 	if (arg == FD_RESET_ALWAYS)
 		if (!capable(CAP_SYS_ADMIN))
 			return  EPERM;
 		mutex_lock(&open_lock);
 		if (lock_fdc(drive)) {
 			mutex_unlock(&open_lock);
 			return  EINTR;
 		}
 	} else {
 		int oldStretch;
 
 		if (lock_fdc(drive))
 			return  EINTR;
 		if (cmd != FDDEFPRM) {
 			/* notice a disk change immediately, else
 	if (type)
 		*g = &floppy_type[type];
 	else {
 		if (lock_fdc(drive))
 			return  EINTR;
 		if (poll_drive(false, 0) ==  EINTR)
 			return  EINTR;
 		if (UDRS >fd_ref != 1)
 			/* somebody else has this drive open */
 			return  EBUSY;
 		if (lock_fdc(drive))
 			return  EINTR;
 
 		/* do the actual eject. Fails on
 		process_fd_request();
 		return ret;
 	case FDCLRPRM:
 		if (lock_fdc(drive))
 			return  EINTR;
 		current_type[drive] = NULL;
 		floppy_sizes[drive] = MAX_DISK_SIZE << 1;
 		UDP >flags &= ~FTD_MSG;
 		return 0;
 	case FDFMTBEG:
 		if (lock_fdc(drive))
 			return  EINTR;
 		if (poll_drive(true, FD_RAW_NEED_DISK) ==  EINTR)
 			return  EINTR;
 		return do_format(drive, &inparam.f);
 	case FDFMTEND:
 	case FDFLUSH:
 		if (lock_fdc(drive))
 			return  EINTR;
 		return invalidate_drive(bdev);
 	case FDSETEMSGTRESH:
 		outparam = UDP;
 		break;
 	case FDPOLLDRVSTAT:
 		if (lock_fdc(drive))
 			return  EINTR;
 		if (poll_drive(true, FD_RAW_NEED_DISK) ==  EINTR)
 			return  EINTR;
 	case FDRAWCMD:
 		if (type)
 			return  EINVAL;
 		if (lock_fdc(drive))
 			return  EINTR;
 		set_floppy(drive);
 		i = raw_cmd_ioctl(cmd, (void __user *)param);
 		process_fd_request();
 		return i;
 	case FDTWADDLE:
 		if (lock_fdc(drive))
 			return  EINTR;
 		twaddle();
 		process_fd_request();
 		return DISK_EVENT_MEDIA_CHANGE;
 
 	if (time_after(jiffies, UDRS >last_checked   UDP >checkfreq)) {
 		if (lock_fdc(drive))
 			return  EINTR;
 		poll_drive(false, 0);
 		process_fd_request();
 	}
 			 "VFS: revalidate called on non open device.\n"))
 			return  EFAULT;
 
 		res = lock_fdc(drive);
 		if (res)
 			return res;
 		cf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS >flags) ||
 		      test_bit(FD_VERIFY_BIT, &UDRS >flags));
 		if (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {
