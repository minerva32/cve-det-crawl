CVE Number : CVE-2010-4256
Commit Message : 
Export 'get_pipe_info()' to other users
Commit Details : 
And in particular, use it in 'pipe_fcntl()'.

The other pipe functions do not need to use the 'careful' version, since
they are only ever called for things that are already known to be pipes.

The normal read/write/ioctl functions are called through the file
operations structures, so if a file isn't a pipe, they'd never get
called.  But pipe_fcntl() is special, and called directly from the
generic fcntl code, and needs to use the same careful function that the
splice code is using.

Cc: Jens Axboe <jaxboe@fusionio.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Dave Jones <davej@redhat.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 	struct pipe_inode_info *pipe;
 	long ret;
 
 	pipe = file >f_path.dentry >d_inode >i_pipe;
 	if (!pipe)
 		return  EBADF;
 
 static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,
 			       struct pipe_inode_info *opipe,
 			       size_t len, unsigned int flags);
 /*
  * After the inode slimming patch, i_pipe/i_bdev/i_cdev share the same
  * location, so checking  >i_pipe is not enough to verify that this is a
  * pipe.
  */
 static inline struct pipe_inode_info *get_pipe_info(struct file *file)
 {
 	struct inode *i = file >f_path.dentry >d_inode;
 
 	return S_ISFIFO(i >i_mode) ? i >i_pipe : NULL;
 }
 
 /*
  * Determine where to splice to/from.
 /* for F_SETPIPE_SZ and F_GETPIPE_SZ */
 long pipe_fcntl(struct file *, unsigned int, unsigned long arg);
 
 #endif
After patch : 
 	struct pipe_inode_info *pipe;
 	long ret;
 
 	pipe = get_pipe_info(file);
 	if (!pipe)
 		return  EBADF;
 
 static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,
 			       struct pipe_inode_info *opipe,
 			       size_t len, unsigned int flags);
 
 /*
  * Determine where to splice to/from.
 /* for F_SETPIPE_SZ and F_GETPIPE_SZ */
 long pipe_fcntl(struct file *, unsigned int, unsigned long arg);
 
 /*
  * After the inode slimming patch, i_pipe/i_bdev/i_cdev share the same
  * location, so checking  >i_pipe is not enough to verify that this is a
  * pipe.
  */
 static inline struct pipe_inode_info *get_pipe_info(struct file *file)
 {
 	struct inode *i = file >f_path.dentry >d_inode;
 
 	return S_ISFIFO(i >i_mode) ? i >i_pipe : NULL;
 }
 
 #endif
