CVE Number : CVE-2016-7097
Commit Message : 
posix_acl: Clear SGID bit when setting file permissions
Commit Details : 
When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

References: CVE-2016-7097
Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

Before patch : 
 	switch (handler >flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
 			umode_t mode = inode >i_mode;
 			retval = posix_acl_equiv_mode(acl, &mode);
 			if (retval < 0)
 				goto err_out;
 			else {
 				struct iattr iattr;
 				if (retval == 0) {
 					/*
 					 * ACL can be represented
 					 * by the mode bits. So don't
 					 * update ACL.
 					 */
 					acl = NULL;
 					value = NULL;
 					size = 0;
 				}
 				/* Updte the mode bits */
 				iattr.ia_mode = ((mode & S_IALLUGO) |
 						 (inode >i_mode & ~S_IALLUGO));
 				iattr.ia_valid = ATTR_MODE;
 				/* FIXME should we update ctime ?
 				 * What is the following setxattr update the
 				 * mode ?
 				 */
 				v9fs_vfs_setattr_dotl(dentry, &iattr);
 			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			ret = posix_acl_equiv_mode(acl, &inode >i_mode);
 			if (ret < 0)
 				return ret;
 			if (ret == 0)
 				acl = NULL;
 		}
 		ret = 0;
 		break;
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			ret = posix_acl_equiv_mode(acl, &new_mode);
 			if (ret < 0)
 				goto out;
 			if (ret == 0)
 				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
 				error = posix_acl_equiv_mode(acl, &inode >i_mode);
 				if (error < 0)
 					return error;
 				else {
 					inode >i_ctime = CURRENT_TIME_SEC;
 					mark_inode_dirty(inode);
 					if (error == 0)
 						acl = NULL;
 				}
 			}
 			break;
 
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
 			error = posix_acl_equiv_mode(acl, &inode >i_mode);
 			if (error < 0)
 				return error;
 			else {
 				inode >i_ctime = ext4_current_time(inode);
 				ext4_mark_inode_dirty(handle, inode);
 				if (error == 0)
 					acl = NULL;
 			}
 		}
 		break;
 
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
 			error = posix_acl_equiv_mode(acl, &inode >i_mode);
 			if (error < 0)
 				return error;
 			set_acl_inode(inode, inode >i_mode);
 			if (error == 0)
 				acl = NULL;
 		}
 		break;
 
 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode >i_mode;
 
 		error = posix_acl_equiv_mode(acl, &mode);
 		if (error < 0)
 			return error;
 
 		if (error == 0)
 			acl = NULL;
 
 		if (mode != inode >i_mode) {
 			inode >i_mode = mode;
 			mark_inode_dirty(inode);
 		}
 	}
 
 	if (acl) {
 	case ACL_TYPE_ACCESS:
 		xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			err = posix_acl_equiv_mode(acl, &inode >i_mode);
 			if (err < 0)
 				return err;
 		}
 		err = 0;
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
 			umode_t mode = inode >i_mode;
 			rc = posix_acl_equiv_mode(acl, &mode);
 			if (rc < 0)
 				return rc;
 			if (inode >i_mode != mode) {
 				struct iattr attr;
 				if (rc < 0)
 					return rc;
 			}
 			if (rc == 0)
 				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			rc = posix_acl_equiv_mode(acl, &inode >i_mode);
 			if (rc < 0)
 				return rc;
 			inode >i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
 			if (rc == 0)
 				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
 			umode_t mode = inode >i_mode;
 			ret = posix_acl_equiv_mode(acl, &mode);
 			if (ret < 0)
 				return ret;
 
 			if (ret == 0)
 				acl = NULL;
 
 			ret = ocfs2_acl_set_mode(inode, di_bh,
 						 handle, mode);
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			umode_t mode = inode >i_mode;
 			/*
 			 * can we represent this with the traditional file
 			 * mode permission bits?
 			 */
 			error = posix_acl_equiv_mode(acl, &mode);
 			if (error < 0) {
 				gossip_err("%s: posix_acl_equiv_mode err: %d\n",
 					   __func__,
 					   error);
 				return error;
 				SetModeFlag(orangefs_inode);
 			inode >i_mode = mode;
 			mark_inode_dirty_sync(inode);
 			if (error == 0)
 				acl = NULL;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 }
 EXPORT_SYMBOL_GPL(posix_acl_create);
 
 /*
  * Fix up the uids and gids in posix acl extended attributes in place.
  */
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			error = posix_acl_equiv_mode(acl, &inode >i_mode);
 			if (error < 0)
 				return error;
 			else {
 				if (error == 0)
 					acl = NULL;
 			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode >i_mode;
 		error = posix_acl_equiv_mode(acl, &mode);
 
 		if (error <= 0) {
 			acl = NULL;
 
 			if (error < 0)
 				return error;
 		}
 
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;
 extern int posix_acl_chmod(struct inode *, umode_t);
 extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,
 		struct posix_acl **);
 
 extern int simple_set_acl(struct inode *, struct posix_acl *, int);
 extern int simple_acl_create(struct inode *, struct inode *);
After patch : 
 	switch (handler >flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
 			struct iattr iattr;
 
 			retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);
 			if (retval)
 				goto err_out;
 			if (!acl) {
 				/*
 				 * ACL can be represented
 				 * by the mode bits. So don't
 				 * update ACL.
 				 */
 				value = NULL;
 				size = 0;
 			}
 			iattr.ia_valid = ATTR_MODE;
 			/* FIXME should we update ctime ?
 			 * What is the following setxattr update the
 			 * mode ?
 			 */
 			v9fs_vfs_setattr_dotl(dentry, &iattr);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			ret = posix_acl_update_mode(inode, &inode >i_mode, &acl);
 			if (ret)
 				return ret;
 		}
 		ret = 0;
 		break;
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			ret = posix_acl_update_mode(inode, &new_mode, &acl);
 			if (ret)
 				goto out;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
 				error = posix_acl_update_mode(inode, &inode >i_mode, &acl);
 				if (error)
 					return error;
 				inode >i_ctime = CURRENT_TIME_SEC;
 				mark_inode_dirty(inode);
 			}
 			break;
 
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
 			error = posix_acl_update_mode(inode, &inode >i_mode, &acl);
 			if (error)
 				return error;
 			inode >i_ctime = ext4_current_time(inode);
 			ext4_mark_inode_dirty(handle, inode);
 		}
 		break;
 
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
 			error = posix_acl_update_mode(inode, &inode >i_mode, &acl);
 			if (error)
 				return error;
 			set_acl_inode(inode, inode >i_mode);
 		}
 		break;
 
 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode >i_mode;
 
 		error = posix_acl_update_mode(inode, &inode >i_mode, &acl);
 		if (error)
 			return error;
 		if (mode != inode >i_mode)
 			mark_inode_dirty(inode);
 	}
 
 	if (acl) {
 	case ACL_TYPE_ACCESS:
 		xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			err = posix_acl_update_mode(inode, &inode >i_mode, &acl);
 			if (err)
 				return err;
 		}
 		err = 0;
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
 			umode_t mode;
 
 			rc = posix_acl_update_mode(inode, &mode, &acl);
 			if (rc)
 				return rc;
 			if (inode >i_mode != mode) {
 				struct iattr attr;
 				if (rc < 0)
 					return rc;
 			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			rc = posix_acl_update_mode(inode, &inode >i_mode, &acl);
 			if (rc)
 				return rc;
 			inode >i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
 			umode_t mode;
 
 			ret = posix_acl_update_mode(inode, &mode, &acl);
 			if (ret)
 				return ret;
 
 			ret = ocfs2_acl_set_mode(inode, di_bh,
 						 handle, mode);
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			umode_t mode;
 
 			error = posix_acl_update_mode(inode, &mode, &acl);
 			if (error) {
 				gossip_err("%s: posix_acl_update_mode err: %d\n",
 					   __func__,
 					   error);
 				return error;
 				SetModeFlag(orangefs_inode);
 			inode >i_mode = mode;
 			mark_inode_dirty_sync(inode);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 }
 EXPORT_SYMBOL_GPL(posix_acl_create);
 
 /**
  * posix_acl_update_mode     update mode in set_acl
  *
  * Update the file mode when setting an ACL: compute the new file permission
  * bits based on the ACL.  In addition, if the ACL is equivalent to the new
  * file mode, set *acl to NULL to indicate that no ACL should be set.
  *
  * As with chmod, clear the setgit bit if the caller is not in the owning group
  * or capable of CAP_FSETID (see inode_change_ok).
  *
  * Called from set_acl inode operations.
  */
 int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,
 			  struct posix_acl **acl)
 {
 	umode_t mode = inode >i_mode;
 	int error;
 
 	error = posix_acl_equiv_mode(*acl, &mode);
 	if (error < 0)
 		return error;
 	if (error == 0)
 		*acl = NULL;
 	if (!in_group_p(inode >i_gid) &&
 	    !capable_wrt_inode_uidgid(inode, CAP_FSETID))
 		mode &= ~S_ISGID;
 	*mode_p = mode;
 	return 0;
 }
 EXPORT_SYMBOL(posix_acl_update_mode);
 
 /*
  * Fix up the uids and gids in posix acl extended attributes in place.
  */
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			error = posix_acl_update_mode(inode, &inode >i_mode, &acl);
 			if (error)
 				return error;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode;
 
 		error = posix_acl_update_mode(inode, &mode, &acl);
 		if (error)
 			return error;
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;
 extern int posix_acl_chmod(struct inode *, umode_t);
 extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,
 		struct posix_acl **);
 extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);
 
 extern int simple_set_acl(struct inode *, struct posix_acl *, int);
 extern int simple_acl_create(struct inode *, struct inode *);
