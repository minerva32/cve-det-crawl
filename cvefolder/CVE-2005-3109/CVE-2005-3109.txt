CVE Number : CVE-2005-3109
Commit Message : 
PATCH hfs, hfsplus: don't leak s_fs_info and fix an oops
Commit Details : 
This patch fixes the leak of sb->s_fs_info in both the HFS and HFS+
modules.  In addition to this, it fixes an oops happening when trying to
mount a non-hfsplus filesystem using hfsplus.  This patch is from Roman
Zippel, based off patches sent by myself.

Signed-off-by: Colin Leroy <colin@colino.net>
Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Signed-off-by: Linus Torvalds <torvalds@osdl.org>

Before patch : 
  * Release the resources associated with the in core MDB.  */
 void hfs_mdb_put(struct super_block *sb)
 {
 	/* free the B trees */
 	hfs_btree_close(HFS_SB(sb) >ext_tree);
 	hfs_btree_close(HFS_SB(sb) >cat_tree);
 	/* free the buffers holding the primary and alternate MDBs */
 	brelse(HFS_SB(sb) >mdb_bh);
 	brelse(HFS_SB(sb) >alt_mdb_bh);
 }
 	res =  EINVAL;
 	if (!parse_options((char *)data, sbi)) {
 		hfs_warn("hfs_fs: unable to parse mount options.\n");
 		goto bail3;
 	}
 
 	sb >s_op = &hfs_super_operations;
 			hfs_warn("VFS: Can't find a HFS filesystem on dev %s.\n",
 				hfs_mdb_name(sb));
 		res =  EINVAL;
 		goto bail2;
 	}
 
 	/* try to get the root inode */
 	iput(root_inode);
 bail_no_root:
 	hfs_warn("hfs_fs: get root inode failed.\n");
 	hfs_mdb_put(sb);
 bail2:
 bail3:
 	kfree(sbi);
 	return res;
 }
 
 static void hfsplus_put_super(struct super_block *sb)
 {
 	dprint(DBG_SUPER, "hfsplus_put_super\n");
 	if (!(sb >s_flags & MS_RDONLY)) {
 		struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
 
 		vhdr >modify_date = hfsp_now2mt();
 	brelse(HFSPLUS_SB(sb).s_vhbh);
 	if (HFSPLUS_SB(sb).nls)
 		unload_nls(HFSPLUS_SB(sb).nls);
 }
 
 static int hfsplus_statfs(struct super_block *sb, struct kstatfs *buf)
After patch : 
  * Release the resources associated with the in core MDB.  */
 void hfs_mdb_put(struct super_block *sb)
 {
 	if (!HFS_SB(sb))
 		return;
 	/* free the B trees */
 	hfs_btree_close(HFS_SB(sb) >ext_tree);
 	hfs_btree_close(HFS_SB(sb) >cat_tree);
 	/* free the buffers holding the primary and alternate MDBs */
 	brelse(HFS_SB(sb) >mdb_bh);
 	brelse(HFS_SB(sb) >alt_mdb_bh);
 
 	kfree(HFS_SB(sb));
 	sb >s_fs_info = NULL;
 }
 	res =  EINVAL;
 	if (!parse_options((char *)data, sbi)) {
 		hfs_warn("hfs_fs: unable to parse mount options.\n");
 		goto bail;
 	}
 
 	sb >s_op = &hfs_super_operations;
 			hfs_warn("VFS: Can't find a HFS filesystem on dev %s.\n",
 				hfs_mdb_name(sb));
 		res =  EINVAL;
 		goto bail;
 	}
 
 	/* try to get the root inode */
 	iput(root_inode);
 bail_no_root:
 	hfs_warn("hfs_fs: get root inode failed.\n");
 bail:
 	hfs_mdb_put(sb);
 	return res;
 }
 
 static void hfsplus_put_super(struct super_block *sb)
 {
 	dprint(DBG_SUPER, "hfsplus_put_super\n");
 	if (!sb >s_fs_info)
 		return;
 	if (!(sb >s_flags & MS_RDONLY) && HFSPLUS_SB(sb).s_vhdr) {
 		struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
 
 		vhdr >modify_date = hfsp_now2mt();
 	brelse(HFSPLUS_SB(sb).s_vhbh);
 	if (HFSPLUS_SB(sb).nls)
 		unload_nls(HFSPLUS_SB(sb).nls);
 	kfree(sb >s_fs_info);
 	sb >s_fs_info = NULL;
 }
 
 static int hfsplus_statfs(struct super_block *sb, struct kstatfs *buf)
