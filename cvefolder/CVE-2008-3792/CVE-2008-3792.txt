CVE Number : CVE-2008-3792
Commit Message : 
sctp: fix potential panics in the SCTP-AUTH API.
Commit Details : 
All of the SCTP-AUTH socket options could cause a panic
if the extension is disabled and the API is envoked.

Additionally, there were some additional assumptions that
certain pointers would always be valid which may not
always be the case.

This patch hardens the API and address all of the crash
scenarios.

Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 		/* Initialize the CHUNKS parameter */
 		auth_chunks >param_hdr.type = SCTP_PARAM_CHUNKS;
 
 		/* If the Add IP functionality is enabled, we must
 		 * authenticate, ASCONF and ASCONF ACK chunks
 		if (sctp_addip_enable) {
 			auth_chunks >chunks[0] = SCTP_CID_ASCONF;
 			auth_chunks >chunks[1] = SCTP_CID_ASCONF_ACK;
 			auth_chunks >param_hdr.length =
 					htons(sizeof(sctp_paramhdr_t)   2);
 		}
 	}
 
 {
 	struct sctp_authchunk val;
 
 	if (optlen != sizeof(struct sctp_authchunk))
 		return  EINVAL;
 	if (copy_from_user(&val, optval, optlen))
 	struct sctp_hmacalgo *hmacs;
 	int err;
 
 	if (optlen < sizeof(struct sctp_hmacalgo))
 		return  EINVAL;
 
 	struct sctp_association *asoc;
 	int ret;
 
 	if (optlen <= sizeof(struct sctp_authkey))
 		return  EINVAL;
 
 	struct sctp_authkeyid val;
 	struct sctp_association *asoc;
 
 	if (optlen != sizeof(struct sctp_authkeyid))
 		return  EINVAL;
 	if (copy_from_user(&val, optval, optlen))
 	struct sctp_authkeyid val;
 	struct sctp_association *asoc;
 
 	if (optlen != sizeof(struct sctp_authkeyid))
 		return  EINVAL;
 	if (copy_from_user(&val, optval, optlen))
 static int sctp_getsockopt_hmac_ident(struct sock *sk, int len,
 				    char __user *optval, int __user *optlen)
 {
 	struct sctp_hmac_algo_param *hmacs;
 	__u16 param_len;
 
 	hmacs = sctp_sk(sk) >ep >auth_hmacs_list;
 	param_len = ntohs(hmacs >param_hdr.length);
 
 	if (len < param_len)
 		return  EINVAL;
 	if (put_user(len, optlen))
 		return  EFAULT;
 	if (copy_to_user(optval, hmacs >hmac_ids, len))
 		return  EFAULT;
 
 	return 0;
 }
 
 	struct sctp_authkeyid val;
 	struct sctp_association *asoc;
 
 	if (len < sizeof(struct sctp_authkeyid))
 		return  EINVAL;
 	if (copy_from_user(&val, optval, sizeof(struct sctp_authkeyid)))
 	else
 		val.scact_keynumber = sctp_sk(sk) >ep >active_key_id;
 
 	return 0;
 }
 
 	struct sctp_authchunks val;
 	struct sctp_association *asoc;
 	struct sctp_chunks_param *ch;
 	u32    num_chunks;
 	char __user *to;
 
 	if (len <= sizeof(struct sctp_authchunks))
 		return  EINVAL;
 
 	if (copy_from_user(&val, p, sizeof(struct sctp_authchunks)))
 		return  EFAULT;
 
 	to = p >gauth_chunks;
 		return  EINVAL;
 
 	ch = asoc >peer.peer_chunks;
 
 	/* See if the user provided enough room for all the data */
 	num_chunks = ntohs(ch >param_hdr.length)   sizeof(sctp_paramhdr_t);
 	if (len < num_chunks)
 		return  EINVAL;
 
 	len = num_chunks;
 	if (put_user(len, optlen))
 		return  EFAULT;
 	if (put_user(num_chunks, &p >gauth_number_of_chunks))
 		return  EFAULT;
 	if (copy_to_user(to, ch >chunks, len))
 		return  EFAULT;
 
 	return 0;
 }
 
 	struct sctp_authchunks val;
 	struct sctp_association *asoc;
 	struct sctp_chunks_param *ch;
 	u32    num_chunks;
 	char __user *to;
 
 	if (len <= sizeof(struct sctp_authchunks))
 		return  EINVAL;
 
 	if (copy_from_user(&val, p, sizeof(struct sctp_authchunks)))
 		return  EFAULT;
 
 	to = p >gauth_chunks;
 	else
 		ch = sctp_sk(sk) >ep >auth_chunk_list;
 
 	num_chunks = ntohs(ch >param_hdr.length)   sizeof(sctp_paramhdr_t);
 	if (len < num_chunks)
 		return  EINVAL;
 
 	len = num_chunks;
 	if (put_user(len, optlen))
 		return  EFAULT;
 	if (put_user(num_chunks, &p >gauth_number_of_chunks))
 		return  EFAULT;
 	if (copy_to_user(to, ch >chunks, len))
 		return  EFAULT;
 
 	return 0;
 }
After patch : 
 
 		/* Initialize the CHUNKS parameter */
 		auth_chunks >param_hdr.type = SCTP_PARAM_CHUNKS;
 		auth_chunks >param_hdr.length = htons(sizeof(sctp_paramhdr_t));
 
 		/* If the Add IP functionality is enabled, we must
 		 * authenticate, ASCONF and ASCONF ACK chunks
 		if (sctp_addip_enable) {
 			auth_chunks >chunks[0] = SCTP_CID_ASCONF;
 			auth_chunks >chunks[1] = SCTP_CID_ASCONF_ACK;
 			auth_chunks >param_hdr.length  = htons(2);
 		}
 	}
 
 {
 	struct sctp_authchunk val;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	if (optlen != sizeof(struct sctp_authchunk))
 		return  EINVAL;
 	if (copy_from_user(&val, optval, optlen))
 	struct sctp_hmacalgo *hmacs;
 	int err;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	if (optlen < sizeof(struct sctp_hmacalgo))
 		return  EINVAL;
 
 	struct sctp_association *asoc;
 	int ret;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	if (optlen <= sizeof(struct sctp_authkey))
 		return  EINVAL;
 
 	struct sctp_authkeyid val;
 	struct sctp_association *asoc;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	if (optlen != sizeof(struct sctp_authkeyid))
 		return  EINVAL;
 	if (copy_from_user(&val, optval, optlen))
 	struct sctp_authkeyid val;
 	struct sctp_association *asoc;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	if (optlen != sizeof(struct sctp_authkeyid))
 		return  EINVAL;
 	if (copy_from_user(&val, optval, optlen))
 static int sctp_getsockopt_hmac_ident(struct sock *sk, int len,
 				    char __user *optval, int __user *optlen)
 {
 	struct sctp_hmacalgo  __user *p = (void __user *)optval;
 	struct sctp_hmac_algo_param *hmacs;
 	__u16 data_len = 0;
 	u32 num_idents;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	hmacs = sctp_sk(sk) >ep >auth_hmacs_list;
 	data_len = ntohs(hmacs >param_hdr.length)   sizeof(sctp_paramhdr_t);
 
 	if (len < sizeof(struct sctp_hmacalgo)   data_len)
 		return  EINVAL;
 
 	len = sizeof(struct sctp_hmacalgo)   data_len;
 	num_idents = data_len / sizeof(u16);
 
 	if (put_user(len, optlen))
 		return  EFAULT;
 	if (put_user(num_idents, &p >shmac_num_idents))
 		return  EFAULT;
 	if (copy_to_user(p >shmac_idents, hmacs >hmac_ids, data_len))
 		return  EFAULT;
 	return 0;
 }
 
 	struct sctp_authkeyid val;
 	struct sctp_association *asoc;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	if (len < sizeof(struct sctp_authkeyid))
 		return  EINVAL;
 	if (copy_from_user(&val, optval, sizeof(struct sctp_authkeyid)))
 	else
 		val.scact_keynumber = sctp_sk(sk) >ep >active_key_id;
 
 	len = sizeof(struct sctp_authkeyid);
 	if (put_user(len, optlen))
 		return  EFAULT;
 	if (copy_to_user(optval, &val, len))
 		return  EFAULT;
 
 	return 0;
 }
 
 	struct sctp_authchunks val;
 	struct sctp_association *asoc;
 	struct sctp_chunks_param *ch;
 	u32    num_chunks = 0;
 	char __user *to;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	if (len < sizeof(struct sctp_authchunks))
 		return  EINVAL;
 
 	if (copy_from_user(&val, optval, sizeof(struct sctp_authchunks)))
 		return  EFAULT;
 
 	to = p >gauth_chunks;
 		return  EINVAL;
 
 	ch = asoc >peer.peer_chunks;
 	if (!ch)
 		goto num;
 
 	/* See if the user provided enough room for all the data */
 	num_chunks = ntohs(ch >param_hdr.length)   sizeof(sctp_paramhdr_t);
 	if (len < num_chunks)
 		return  EINVAL;
 
 	if (copy_to_user(to, ch >chunks, num_chunks))
 		return  EFAULT;
 num:
 	len = sizeof(struct sctp_authchunks)   num_chunks;
 	if (put_user(len, optlen)) return  EFAULT;
 	if (put_user(num_chunks, &p >gauth_number_of_chunks))
 		return  EFAULT;
 	return 0;
 }
 
 	struct sctp_authchunks val;
 	struct sctp_association *asoc;
 	struct sctp_chunks_param *ch;
 	u32    num_chunks = 0;
 	char __user *to;
 
 	if (!sctp_auth_enable)
 		return  EACCES;
 
 	if (len < sizeof(struct sctp_authchunks))
 		return  EINVAL;
 
 	if (copy_from_user(&val, optval, sizeof(struct sctp_authchunks)))
 		return  EFAULT;
 
 	to = p >gauth_chunks;
 	else
 		ch = sctp_sk(sk) >ep >auth_chunk_list;
 
 	if (!ch)
 		goto num;
 
 	num_chunks = ntohs(ch >param_hdr.length)   sizeof(sctp_paramhdr_t);
 	if (len < sizeof(struct sctp_authchunks)   num_chunks)
 		return  EINVAL;
 
 	if (copy_to_user(to, ch >chunks, num_chunks))
 		return  EFAULT;
 num:
 	len = sizeof(struct sctp_authchunks)   num_chunks;
 	if (put_user(len, optlen))
 		return  EFAULT;
 	if (put_user(num_chunks, &p >gauth_number_of_chunks))
 		return  EFAULT;
 
 	return 0;
 }
