CVE Number : CVE-2008-7316
Commit Message : 
fix writev regression: pan hanging unkillable and un-straceable
Commit Details : 
Frederik Himpe reported an unkillable and un-straceable pan process.

Zero length iovecs can go into an infinite loop in writev, because the
iovec iterator does not always advance over them.

The sequence required to trigger this is not trivial. I think it
requires that a zero-length iovec be followed by a non-zero-length iovec
which causes a pagefault in the atomic usercopy. This causes the writev
code to drop back into single-segment copy mode, which then tries to
copy the 0 bytes of the zero-length iovec; a zero length copy looks like
a failure though, so it loops.

Put a test into iov_iter_advance to catch zero-length iovecs. We could
just put the test in the fallback path, but I feel it is more robust to
skip over zero-length iovecs throughout the code (iovec iterator may be
used in filesystems too, so it should be robust).

Signed-off-by: Nick Piggin <npiggin@suse.de>
Signed-off-by: Ingo Molnar <mingo@elte.hu>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 		const struct iovec *iov = i >iov;
 		size_t base = i >iov_offset;
 
 		while (bytes) {
 			int copy = min(bytes, iov >iov_len   base);
 
 			bytes  = copy;
 
 		cond_resched();
 
 		if (unlikely(copied == 0)) {
 			/*
 			 * If we were unable to copy any data at all, we must
 						iov_iter_single_seg_count(i));
 			goto again;
 		}
 		iov_iter_advance(i, copied);
 		pos  = copied;
 		written  = copied;
 
After patch : 
 		const struct iovec *iov = i >iov;
 		size_t base = i >iov_offset;
 
 		/*
 		 * The !iov >iov_len check ensures we skip over unlikely
 		 * zero length segments.
 		 */
 		while (bytes || !iov >iov_len) {
 			int copy = min(bytes, iov >iov_len   base);
 
 			bytes  = copy;
 
 		cond_resched();
 
 		iov_iter_advance(i, copied);
 		if (unlikely(copied == 0)) {
 			/*
 			 * If we were unable to copy any data at all, we must
 						iov_iter_single_seg_count(i));
 			goto again;
 		}
 		pos  = copied;
 		written  = copied;
 
