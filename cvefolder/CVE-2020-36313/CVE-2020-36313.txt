CVE Number : CVE-2020-36313
Commit Message : 
KVM: Fix out of range accesses to memslots
Commit Details : 
Reset the LRU slot if it becomes invalid when deleting a memslot to fix
an out-of-bounds/use-after-free access when searching through memslots.

Explicitly check for there being no used slots in search_memslots(), and
in the caller of s390's approximation variant.

Fixes: 36947254e5f9 ("KVM: Dynamically size memslot array based on number of used slots")
Reported-by: Qian Cai <cai@lca.pw>
Cc: Peter Xu <peterx@redhat.com>
Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200320205546.2396-2-sean.j.christopherson@intel.com>
Acked-by: Christian Borntraeger <borntraeger@de.ibm.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

Before patch : 
 	struct kvm_memslots *slots = kvm_memslots(kvm);
 	struct kvm_memory_slot *ms;
 
 	cur_gfn = kvm_s390_next_dirty_cmma(slots, args >start_gfn);
 	ms = gfn_to_memslot(kvm, cur_gfn);
 	args >count = 0;
 	int slot = atomic_read(&slots >lru_slot);
 	struct kvm_memory_slot *memslots = slots >memslots;
 
 	if (gfn >= memslots[slot].base_gfn &&
 	    gfn < memslots[slot].base_gfn   memslots[slot].npages)
 		return &memslots[slot];
 
 	slots >used_slots  ;
 
 	for (i = slots >id_to_index[memslot >id]; i < slots >used_slots; i  ) {
 		mslots[i] = mslots[i   1];
 		slots >id_to_index[mslots[i].id] = i;
After patch : 
 	struct kvm_memslots *slots = kvm_memslots(kvm);
 	struct kvm_memory_slot *ms;
 
 	if (unlikely(!slots >used_slots))
 		return 0;
 
 	cur_gfn = kvm_s390_next_dirty_cmma(slots, args >start_gfn);
 	ms = gfn_to_memslot(kvm, cur_gfn);
 	args >count = 0;
 	int slot = atomic_read(&slots >lru_slot);
 	struct kvm_memory_slot *memslots = slots >memslots;
 
 	if (unlikely(!slots >used_slots))
 		return NULL;
 
 	if (gfn >= memslots[slot].base_gfn &&
 	    gfn < memslots[slot].base_gfn   memslots[slot].npages)
 		return &memslots[slot];
 
 	slots >used_slots  ;
 
 	if (atomic_read(&slots >lru_slot) >= slots >used_slots)
 		atomic_set(&slots >lru_slot, 0);
 
 	for (i = slots >id_to_index[memslot >id]; i < slots >used_slots; i  ) {
 		mslots[i] = mslots[i   1];
 		slots >id_to_index[mslots[i].id] = i;
