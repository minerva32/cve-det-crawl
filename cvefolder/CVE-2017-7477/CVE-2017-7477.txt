CVE Number : CVE-2017-7477
Commit Message : 
macsec: dynamically allocate space for sglist
Commit Details : 
We call skb_cow_data, which is good anyway to ensure we can actually
modify the skb as such (another error from prior). Now that we have the
number of fragments required, we can safely allocate exactly that amount
of memory.

Fixes: c09440f7dcb3 ("macsec: introduce IEEE 802.1AE driver")
Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
Acked-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 static struct aead_request *macsec_alloc_req(struct crypto_aead *tfm,
 					     unsigned char **iv,
 					     struct scatterlist **sg)
 {
 	size_t size, iv_offset, sg_offset;
 	struct aead_request *req;
 
 	size = ALIGN(size, __alignof__(struct scatterlist));
 	sg_offset = size;
 	size  = sizeof(struct scatterlist) * (MAX_SKB_FRAGS   1);
 
 	tmp = kmalloc(size, GFP_ATOMIC);
 	if (!tmp)
 {
 	int ret;
 	struct scatterlist *sg;
 	unsigned char *iv;
 	struct ethhdr *eth;
 	struct macsec_eth_header *hh;
 		return ERR_PTR( EINVAL);
 	}
 
 	req = macsec_alloc_req(tx_sa >key.tfm, &iv, &sg);
 	if (!req) {
 		macsec_txsa_put(tx_sa);
 		kfree_skb(skb);
 
 	macsec_fill_iv(iv, secy >sci, pn);
 
 	sg_init_table(sg, MAX_SKB_FRAGS   1);
 	skb_to_sgvec(skb, sg, 0, skb >len);
 
 	if (tx_sc >encrypt) {
 {
 	int ret;
 	struct scatterlist *sg;
 	unsigned char *iv;
 	struct aead_request *req;
 	struct macsec_eth_header *hdr;
 	if (!skb)
 		return ERR_PTR( ENOMEM);
 
 	req = macsec_alloc_req(rx_sa >key.tfm, &iv, &sg);
 	if (!req) {
 		kfree_skb(skb);
 		return ERR_PTR( ENOMEM);
 	hdr = (struct macsec_eth_header *)skb >data;
 	macsec_fill_iv(iv, sci, ntohl(hdr >packet_number));
 
 	sg_init_table(sg, MAX_SKB_FRAGS   1);
 	skb_to_sgvec(skb, sg, 0, skb >len);
 
 	if (hdr >tci_an & MACSEC_TCI_E) {
 }
 
 #define MACSEC_FEATURES \
 	(NETIF_F_SG | NETIF_F_HIGHDMA)
 static struct lock_class_key macsec_netdev_addr_lock_key;
 
 static int macsec_dev_init(struct net_device *dev)
After patch : 
 
 static struct aead_request *macsec_alloc_req(struct crypto_aead *tfm,
 					     unsigned char **iv,
 					     struct scatterlist **sg,
 					     int num_frags)
 {
 	size_t size, iv_offset, sg_offset;
 	struct aead_request *req;
 
 	size = ALIGN(size, __alignof__(struct scatterlist));
 	sg_offset = size;
 	size  = sizeof(struct scatterlist) * num_frags;
 
 	tmp = kmalloc(size, GFP_ATOMIC);
 	if (!tmp)
 {
 	int ret;
 	struct scatterlist *sg;
 	struct sk_buff *trailer;
 	unsigned char *iv;
 	struct ethhdr *eth;
 	struct macsec_eth_header *hh;
 		return ERR_PTR( EINVAL);
 	}
 
 	ret = skb_cow_data(skb, 0, &trailer);
 	if (unlikely(ret < 0)) {
 		macsec_txsa_put(tx_sa);
 		kfree_skb(skb);
 		return ERR_PTR(ret);
 	}
 
 	req = macsec_alloc_req(tx_sa >key.tfm, &iv, &sg, ret);
 	if (!req) {
 		macsec_txsa_put(tx_sa);
 		kfree_skb(skb);
 
 	macsec_fill_iv(iv, secy >sci, pn);
 
 	sg_init_table(sg, ret);
 	skb_to_sgvec(skb, sg, 0, skb >len);
 
 	if (tx_sc >encrypt) {
 {
 	int ret;
 	struct scatterlist *sg;
 	struct sk_buff *trailer;
 	unsigned char *iv;
 	struct aead_request *req;
 	struct macsec_eth_header *hdr;
 	if (!skb)
 		return ERR_PTR( ENOMEM);
 
 	ret = skb_cow_data(skb, 0, &trailer);
 	if (unlikely(ret < 0)) {
 		kfree_skb(skb);
 		return ERR_PTR(ret);
 	}
 	req = macsec_alloc_req(rx_sa >key.tfm, &iv, &sg, ret);
 	if (!req) {
 		kfree_skb(skb);
 		return ERR_PTR( ENOMEM);
 	hdr = (struct macsec_eth_header *)skb >data;
 	macsec_fill_iv(iv, sci, ntohl(hdr >packet_number));
 
 	sg_init_table(sg, ret);
 	skb_to_sgvec(skb, sg, 0, skb >len);
 
 	if (hdr >tci_an & MACSEC_TCI_E) {
 }
 
 #define MACSEC_FEATURES \
 	(NETIF_F_SG | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST)
 static struct lock_class_key macsec_netdev_addr_lock_key;
 
 static int macsec_dev_init(struct net_device *dev)
