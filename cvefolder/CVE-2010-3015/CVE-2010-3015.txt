CVE Number : CVE-2010-3015
Commit Message : 
ext4: consolidate in_range() definitions
Commit Details : 
There are duplicate macro definitions of in_range() in mballoc.h and
balloc.c.  This consolidates these two definitions into ext4.h, and
changes extents.c to use in_range() as well.

Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
Cc: Andreas Dilger <adilger@sun.com>

Before patch : 
  * when a file system is mounted (see ext4_fill_super).
  */
 
 
 #define in_range(b, first, len)	((b) >= (first) && (b) <= (first)   (len)   1)
 
 /**
  * ext4_get_group_desc()    load group descriptor from disk
  * @sb:			super block
 	set_bit(BH_BITMAP_UPTODATE, &(bh) >b_state);
 }
 
 #endif	/* __KERNEL__ */
 
 #endif	/* _EXT4_H */
 
 	BUG_ON(cex >ec_type != EXT4_EXT_CACHE_GAP &&
 			cex >ec_type != EXT4_EXT_CACHE_EXTENT);
 	if (block >= cex >ec_block && block < cex >ec_block   cex >ec_len) {
 		ex >ee_block = cpu_to_le32(cex >ec_block);
 		ext4_ext_store_pblock(ex, cex >ec_start);
 		ex >ee_len = cpu_to_le16(cex >ec_len);
 		 */
 		ee_len = ext4_ext_get_actual_len(ex);
 		/* if found extent covers block, simply return it */
 		if (iblock >= ee_block && iblock < ee_block   ee_len) {
 			newblock = iblock   ee_block   ee_start;
 			/* number of remaining blocks in the extent */
 			allocated = ee_len   (iblock   ee_block);
 #define EXT4_MB_BITMAP(e4b)	((e4b) >bd_bitmap)
 #define EXT4_MB_BUDDY(e4b)	((e4b) >bd_buddy)
 
 #define in_range(b, first, len)	((b) >= (first) && (b) <= (first)   (len)   1)
 
 static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,
 					struct ext4_free_extent *fex)
 {
After patch : 
  * when a file system is mounted (see ext4_fill_super).
  */
 
 /**
  * ext4_get_group_desc()    load group descriptor from disk
  * @sb:			super block
 	set_bit(BH_BITMAP_UPTODATE, &(bh) >b_state);
 }
 
 #define in_range(b, first, len)	((b) >= (first) && (b) <= (first)   (len)   1)
 
 #endif	/* __KERNEL__ */
 
 #endif	/* _EXT4_H */
 
 	BUG_ON(cex >ec_type != EXT4_EXT_CACHE_GAP &&
 			cex >ec_type != EXT4_EXT_CACHE_EXTENT);
 	if (in_range(block, cex >ec_block, cex >ec_len)) {
 		ex >ee_block = cpu_to_le32(cex >ec_block);
 		ext4_ext_store_pblock(ex, cex >ec_start);
 		ex >ee_len = cpu_to_le16(cex >ec_len);
 		 */
 		ee_len = ext4_ext_get_actual_len(ex);
 		/* if found extent covers block, simply return it */
 		if (in_range(iblock, ee_block, ee_len)) {
 			newblock = iblock   ee_block   ee_start;
 			/* number of remaining blocks in the extent */
 			allocated = ee_len   (iblock   ee_block);
 #define EXT4_MB_BITMAP(e4b)	((e4b) >bd_bitmap)
 #define EXT4_MB_BUDDY(e4b)	((e4b) >bd_buddy)
 
 static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,
 					struct ext4_free_extent *fex)
 {
