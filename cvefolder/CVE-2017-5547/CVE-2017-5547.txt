CVE Number : CVE-2017-5547
Commit Message : 
HID: corsair: fix DMA buffers on stack
Commit Details : 
Not all platforms support DMA to the stack, and specifically since v4.9
this is no longer supported on x86 with VMAP_STACK either.

Note that the macro-mode buffer was larger than necessary.

Fixes: 6f78193ee9ea ("HID: corsair: Add Corsair Vengeance K90 driver")
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Johan Hovold <johan@kernel.org>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>

Before patch : 
 	struct usb_interface *usbif = to_usb_interface(dev >parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int brightness;
 	char data[8];
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
 	if (ret < 0) {
 		dev_warn(dev, "Failed to get K90 initial state (error %d).\n",
 			 ret);
 		return  EIO;
 	}
 	brightness = data[4];
 	if (brightness < 0 || brightness > 3) {
 		dev_warn(dev,
 			 "Read invalid backlight brightness: %02hhx.\n",
 			 data[4]);
 		return  EIO;
 	}
 	return brightness;
 }
 
 static enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)
 	struct usb_interface *usbif = to_usb_interface(dev >parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	const char *macro_mode;
 	char data[8];
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_GET_MODE,
 	if (ret < 0) {
 		dev_warn(dev, "Failed to get K90 initial mode (error %d).\n",
 			 ret);
 		return  EIO;
 	}
 
 	switch (data[0]) {
 	default:
 		dev_warn(dev, "K90 in unknown mode: %02hhx.\n",
 			 data[0]);
 		return  EIO;
 	}
 
 	return snprintf(buf, PAGE_SIZE, "%s\n", macro_mode);
 }
 
 static ssize_t k90_store_macro_mode(struct device *dev,
 	struct usb_interface *usbif = to_usb_interface(dev >parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int current_profile;
 	char data[8];
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
 	if (ret < 0) {
 		dev_warn(dev, "Failed to get K90 initial state (error %d).\n",
 			 ret);
 		return  EIO;
 	}
 	current_profile = data[7];
 	if (current_profile < 1 || current_profile > 3) {
 		dev_warn(dev, "Read invalid current profile: %02hhx.\n",
 			 data[7]);
 		return  EIO;
 	}
 
 	return snprintf(buf, PAGE_SIZE, "%d\n", current_profile);
 }
 
 static ssize_t k90_store_current_profile(struct device *dev,
After patch : 
 	struct usb_interface *usbif = to_usb_interface(dev >parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int brightness;
 	char *data;
 
 	data = kmalloc(8, GFP_KERNEL);
 	if (!data)
 		return  ENOMEM;
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
 	if (ret < 0) {
 		dev_warn(dev, "Failed to get K90 initial state (error %d).\n",
 			 ret);
 		ret =  EIO;
 		goto out;
 	}
 	brightness = data[4];
 	if (brightness < 0 || brightness > 3) {
 		dev_warn(dev,
 			 "Read invalid backlight brightness: %02hhx.\n",
 			 data[4]);
 		ret =  EIO;
 		goto out;
 	}
 	ret = brightness;
 out:
 	kfree(data);
 
 	return ret;
 }
 
 static enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)
 	struct usb_interface *usbif = to_usb_interface(dev >parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	const char *macro_mode;
 	char *data;
 
 	data = kmalloc(2, GFP_KERNEL);
 	if (!data)
 		return  ENOMEM;
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_GET_MODE,
 	if (ret < 0) {
 		dev_warn(dev, "Failed to get K90 initial mode (error %d).\n",
 			 ret);
 		ret =  EIO;
 		goto out;
 	}
 
 	switch (data[0]) {
 	default:
 		dev_warn(dev, "K90 in unknown mode: %02hhx.\n",
 			 data[0]);
 		ret =  EIO;
 		goto out;
 	}
 
 	ret = snprintf(buf, PAGE_SIZE, "%s\n", macro_mode);
 out:
 	kfree(data);
 
 	return ret;
 }
 
 static ssize_t k90_store_macro_mode(struct device *dev,
 	struct usb_interface *usbif = to_usb_interface(dev >parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int current_profile;
 	char *data;
 
 	data = kmalloc(8, GFP_KERNEL);
 	if (!data)
 		return  ENOMEM;
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
 	if (ret < 0) {
 		dev_warn(dev, "Failed to get K90 initial state (error %d).\n",
 			 ret);
 		ret =  EIO;
 		goto out;
 	}
 	current_profile = data[7];
 	if (current_profile < 1 || current_profile > 3) {
 		dev_warn(dev, "Read invalid current profile: %02hhx.\n",
 			 data[7]);
 		ret =  EIO;
 		goto out;
 	}
 
 	ret = snprintf(buf, PAGE_SIZE, "%d\n", current_profile);
 out:
 	kfree(data);
 
 	return ret;
 }
 
 static ssize_t k90_store_current_profile(struct device *dev,
