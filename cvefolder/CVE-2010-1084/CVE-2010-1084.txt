CVE Number : CVE-2010-1084
Commit Message : 
Bluetooth: Fix potential bad memory access with sysfs files
Commit Details : 
When creating a high number of Bluetooth sockets (L2CAP, SCO
and RFCOMM) it is possible to scribble repeatedly on arbitrary
pages of memory. Ensure that the content of these sysfs files is
always less than one page. Even if this means truncating. The
files in question are scheduled to be moved over to debugfs in
the future anyway.

Based on initial patches from Neil Brown and Linus Torvalds

Reported-by: Neil Brown <neilb@suse.de>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

Before patch : 
 	struct sock *sk;
 	struct hlist_node *node;
 	char *str = buf;
 
 	read_lock_bh(&l2cap_sk_list.lock);
 
 	sk_for_each(sk, node, &l2cap_sk_list.head) {
 		struct l2cap_pinfo *pi = l2cap_pi(sk);
 
 		str  = sprintf(str, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d\n",
 				batostr(&bt_sk(sk) >src), batostr(&bt_sk(sk) >dst),
 				sk >sk_state, __le16_to_cpu(pi >psm), pi >scid,
 				pi >dcid, pi >imtu, pi >omtu, pi >sec_level);
 	}
 
 	read_unlock_bh(&l2cap_sk_list.lock);
 	struct rfcomm_session *s;
 	struct list_head *pp, *p;
 	char *str = buf;
 
 	rfcomm_lock();
 
 		list_for_each(pp, &s >dlcs) {
 			struct sock *sk = s >sock >sk;
 			struct rfcomm_dlc *d = list_entry(pp, struct rfcomm_dlc, list);
 
 			str  = sprintf(str, "%s %s %ld %d %d %d %d\n",
 					batostr(&bt_sk(sk) >src), batostr(&bt_sk(sk) >dst),
 					d >state, d >dlci, d >mtu, d >rx_credits, d >tx_credits);
 		}
 	}
 
 	rfcomm_unlock();
 	struct sock *sk;
 	struct hlist_node *node;
 	char *str = buf;
 
 	read_lock_bh(&rfcomm_sk_list.lock);
 
 	sk_for_each(sk, node, &rfcomm_sk_list.head) {
 		str  = sprintf(str, "%s %s %d %d\n",
 				batostr(&bt_sk(sk) >src), batostr(&bt_sk(sk) >dst),
 				sk >sk_state, rfcomm_pi(sk) >channel);
 	}
 
 	read_unlock_bh(&rfcomm_sk_list.lock);
 	struct sock *sk;
 	struct hlist_node *node;
 	char *str = buf;
 
 	read_lock_bh(&sco_sk_list.lock);
 
 	sk_for_each(sk, node, &sco_sk_list.head) {
 		str  = sprintf(str, "%s %s %d\n",
 				batostr(&bt_sk(sk) >src), batostr(&bt_sk(sk) >dst),
 				sk >sk_state);
 	}
 
 	read_unlock_bh(&sco_sk_list.lock);
After patch : 
 	struct sock *sk;
 	struct hlist_node *node;
 	char *str = buf;
 	int size = PAGE_SIZE;
 
 	read_lock_bh(&l2cap_sk_list.lock);
 
 	sk_for_each(sk, node, &l2cap_sk_list.head) {
 		struct l2cap_pinfo *pi = l2cap_pi(sk);
 		int len;
 
 		len = snprintf(str, size, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d\n",
 				batostr(&bt_sk(sk) >src), batostr(&bt_sk(sk) >dst),
 				sk >sk_state, __le16_to_cpu(pi >psm), pi >scid,
 				pi >dcid, pi >imtu, pi >omtu, pi >sec_level);
 
 		size  = len;
 		if (size <= 0)
 			break;
 
 		str  = len;
 	}
 
 	read_unlock_bh(&l2cap_sk_list.lock);
 	struct rfcomm_session *s;
 	struct list_head *pp, *p;
 	char *str = buf;
 	int size = PAGE_SIZE;
 
 	rfcomm_lock();
 
 		list_for_each(pp, &s >dlcs) {
 			struct sock *sk = s >sock >sk;
 			struct rfcomm_dlc *d = list_entry(pp, struct rfcomm_dlc, list);
 			int len;
 
 			len = snprintf(str, size, "%s %s %ld %d %d %d %d\n",
 					batostr(&bt_sk(sk) >src), batostr(&bt_sk(sk) >dst),
 					d >state, d >dlci, d >mtu, d >rx_credits, d >tx_credits);
 
 			size  = len;
 			if (size <= 0)
 				break;
 
 			str  = len;
 		}
 
 		if (size <= 0)
 			break;
 	}
 
 	rfcomm_unlock();
 	struct sock *sk;
 	struct hlist_node *node;
 	char *str = buf;
 	int size = PAGE_SIZE;
 
 	read_lock_bh(&rfcomm_sk_list.lock);
 
 	sk_for_each(sk, node, &rfcomm_sk_list.head) {
 		int len;
 
 		len = snprintf(str, size, "%s %s %d %d\n",
 				batostr(&bt_sk(sk) >src), batostr(&bt_sk(sk) >dst),
 				sk >sk_state, rfcomm_pi(sk) >channel);
 
 		size  = len;
 		if (size <= 0)
 			break;
 
 		str  = len;
 	}
 
 	read_unlock_bh(&rfcomm_sk_list.lock);
 	struct sock *sk;
 	struct hlist_node *node;
 	char *str = buf;
 	int size = PAGE_SIZE;
 
 	read_lock_bh(&sco_sk_list.lock);
 
 	sk_for_each(sk, node, &sco_sk_list.head) {
 		int len;
 
 		len = snprintf(str, size, "%s %s %d\n",
 				batostr(&bt_sk(sk) >src), batostr(&bt_sk(sk) >dst),
 				sk >sk_state);
 
 		size  = len;
 		if (size <= 0)
 			break;
 
 		str  = len;
 	}
 
 	read_unlock_bh(&sco_sk_list.lock);
