CVE Number : CVE-2017-8797
Commit Message : 
nfsd: encoders mustn't use unitialized values in error cases
Commit Details : 
In error cases, lgp->lg_layout_type may be out of bounds; so we
shouldn't be using it until after the check of nfserr.

This was seen to crash nfsd threads when the server receives a LAYOUTGET
request with a large layout type.

GETDEVICEINFO has the same problem.

Reported-by: Ari Kauppi <Ari.Kauppi@synopsys.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>

Before patch : 
 		struct nfsd4_getdeviceinfo *gdev)
 {
 	struct xdr_stream *xdr = &resp >xdr;
 	const struct nfsd4_layout_ops *ops =
 		nfsd4_layout_ops[gdev >gd_layout_type];
 	u32 starting_len = xdr >buf >len, needed_len;
 	__be32 *p;
 
 
 	/* If maxcount is 0 then just update notifications */
 	if (gdev >gd_maxcount != 0) {
 		nfserr = ops >encode_getdeviceinfo(xdr, gdev);
 		if (nfserr) {
 			/*
 		struct nfsd4_layoutget *lgp)
 {
 	struct xdr_stream *xdr = &resp >xdr;
 	const struct nfsd4_layout_ops *ops =
 		nfsd4_layout_ops[lgp >lg_layout_type];
 	__be32 *p;
 
 	dprintk("%s: err %d\n", __func__, nfserr);
 	*p   = cpu_to_be32(lgp >lg_seg.iomode);
 	*p   = cpu_to_be32(lgp >lg_layout_type);
 
 	nfserr = ops >encode_layoutget(xdr, lgp);
 out:
 	kfree(lgp >lg_content);
After patch : 
 		struct nfsd4_getdeviceinfo *gdev)
 {
 	struct xdr_stream *xdr = &resp >xdr;
 	const struct nfsd4_layout_ops *ops;
 	u32 starting_len = xdr >buf >len, needed_len;
 	__be32 *p;
 
 
 	/* If maxcount is 0 then just update notifications */
 	if (gdev >gd_maxcount != 0) {
 		ops = nfsd4_layout_ops[gdev >gd_layout_type];
 		nfserr = ops >encode_getdeviceinfo(xdr, gdev);
 		if (nfserr) {
 			/*
 		struct nfsd4_layoutget *lgp)
 {
 	struct xdr_stream *xdr = &resp >xdr;
 	const struct nfsd4_layout_ops *ops;
 	__be32 *p;
 
 	dprintk("%s: err %d\n", __func__, nfserr);
 	*p   = cpu_to_be32(lgp >lg_seg.iomode);
 	*p   = cpu_to_be32(lgp >lg_layout_type);
 
 	ops = nfsd4_layout_ops[lgp >lg_layout_type];
 	nfserr = ops >encode_layoutget(xdr, lgp);
 out:
 	kfree(lgp >lg_content);
