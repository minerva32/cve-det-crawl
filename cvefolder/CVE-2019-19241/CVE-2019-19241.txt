CVE Number : CVE-2019-19241
Commit Message : 
io_uring: async workers should inherit the user creds
Commit Details : 
If we don't inherit the original task creds, then we can confuse users
like fuse that pass creds in the request header. See link below on
identical aio issue.

Link: https://lore.kernel.org/linux-fsdevel/26f0d78e-99ca-2f1b-78b9-433088053a61@scylladb.com/T/#u
Signed-off-by: Jens Axboe <axboe@kernel.dk>

Before patch : 
 
 	struct rcu_head rcu;
 	struct mm_struct *mm;
 	struct files_struct *restore_files;
 };
 
 
 	struct task_struct *manager;
 	struct user_struct *user;
 	struct mm_struct *mm;
 	refcount_t refs;
 	struct completion done;
 {
 	bool dropped_lock = false;
 
 	if (current >files != worker >restore_files) {
 		__acquire(&wqe >lock);
 		spin_unlock_irq(&wqe >lock);
 			set_fs(USER_DS);
 			worker >mm = wq >mm;
 		}
 		if (test_bit(IO_WQ_BIT_CANCEL, &wq >state))
 			work >flags |= IO_WQ_WORK_CANCEL;
 		if (worker >mm)
 
 	/* caller must already hold a reference to this */
 	wq >user = data >user;
 
 	i = 0;
 	for_each_online_node(node) {
 struct io_wq_data {
 	struct mm_struct *mm;
 	struct user_struct *user;
 
 	get_work_fn *get_work;
 	put_work_fn *put_work;
 
 	struct user_struct	*user;
 
 	/* 0 is for ctx quiesce/reinit/free, 1 is for sqo_thread started */
 	struct completion	*completions;
 
 {
 	struct io_ring_ctx *ctx = data;
 	struct mm_struct *cur_mm = NULL;
 	mm_segment_t old_fs;
 	DEFINE_WAIT(wait);
 	unsigned inflight;
 
 	old_fs = get_fs();
 	set_fs(USER_DS);
 
 	ret = timeout = inflight = 0;
 	while (!kthread_should_park()) {
 		unuse_mm(cur_mm);
 		mmput(cur_mm);
 	}
 
 	kthread_parkme();
 
 
 	data.mm = ctx >sqo_mm;
 	data.user = ctx >user;
 	data.get_work = io_get_work;
 	data.put_work = io_put_work;
 
 		io_unaccount_mem(ctx >user,
 				ring_pages(ctx >sq_entries, ctx >cq_entries));
 	free_uid(ctx >user);
 	kfree(ctx >completions);
 	kmem_cache_free(req_cachep, ctx >fallback_req);
 	kfree(ctx);
 	ctx >compat = in_compat_syscall();
 	ctx >account_mem = account_mem;
 	ctx >user = user;
 
 	ret = io_allocate_scq_urings(ctx, p);
 	if (ret)
After patch : 
 
 	struct rcu_head rcu;
 	struct mm_struct *mm;
 	const struct cred *creds;
 	struct files_struct *restore_files;
 };
 
 
 	struct task_struct *manager;
 	struct user_struct *user;
 	struct cred *creds;
 	struct mm_struct *mm;
 	refcount_t refs;
 	struct completion done;
 {
 	bool dropped_lock = false;
 
 	if (worker >creds) {
 		revert_creds(worker >creds);
 		worker >creds = NULL;
 	}
 
 	if (current >files != worker >restore_files) {
 		__acquire(&wqe >lock);
 		spin_unlock_irq(&wqe >lock);
 			set_fs(USER_DS);
 			worker >mm = wq >mm;
 		}
 		if (!worker >creds)
 			worker >creds = override_creds(wq >creds);
 		if (test_bit(IO_WQ_BIT_CANCEL, &wq >state))
 			work >flags |= IO_WQ_WORK_CANCEL;
 		if (worker >mm)
 
 	/* caller must already hold a reference to this */
 	wq >user = data >user;
 	wq >creds = data >creds;
 
 	i = 0;
 	for_each_online_node(node) {
 struct io_wq_data {
 	struct mm_struct *mm;
 	struct user_struct *user;
 	struct cred *creds;
 
 	get_work_fn *get_work;
 	put_work_fn *put_work;
 
 	struct user_struct	*user;
 
 	struct cred		*creds;
 
 	/* 0 is for ctx quiesce/reinit/free, 1 is for sqo_thread started */
 	struct completion	*completions;
 
 {
 	struct io_ring_ctx *ctx = data;
 	struct mm_struct *cur_mm = NULL;
 	const struct cred *old_cred;
 	mm_segment_t old_fs;
 	DEFINE_WAIT(wait);
 	unsigned inflight;
 
 	old_fs = get_fs();
 	set_fs(USER_DS);
 	old_cred = override_creds(ctx >creds);
 
 	ret = timeout = inflight = 0;
 	while (!kthread_should_park()) {
 		unuse_mm(cur_mm);
 		mmput(cur_mm);
 	}
 	revert_creds(old_cred);
 
 	kthread_parkme();
 
 
 	data.mm = ctx >sqo_mm;
 	data.user = ctx >user;
 	data.creds = ctx >creds;
 	data.get_work = io_get_work;
 	data.put_work = io_put_work;
 
 		io_unaccount_mem(ctx >user,
 				ring_pages(ctx >sq_entries, ctx >cq_entries));
 	free_uid(ctx >user);
 	put_cred(ctx >creds);
 	kfree(ctx >completions);
 	kmem_cache_free(req_cachep, ctx >fallback_req);
 	kfree(ctx);
 	ctx >compat = in_compat_syscall();
 	ctx >account_mem = account_mem;
 	ctx >user = user;
 	ctx >creds = prepare_creds();
 
 	ret = io_allocate_scq_urings(ctx, p);
 	if (ret)
