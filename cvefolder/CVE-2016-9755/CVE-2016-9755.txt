CVE Number : CVE-2016-9755
Commit Message : 
netfilter: ipv6: nf_defrag: drop mangled skb on ream error
Commit Details : 
Dmitry Vyukov reported GPF in network stack that Andrey traced down to
negative nh offset in nf_ct_frag6_queue().

Problem is that all network headers before fragment header are pulled.
Normal ipv6 reassembly will drop the skb when errors occur further down
the line.

netfilter doesn't do this, and instead passed the original fragment
along.  That was also fine back when netfilter ipv6 defrag worked with
cloned fragments, as the original, pristine fragment was passed on.

So we either have to undo the pull op, or discard such fragments.
Since they're malformed after all (e.g. overlapping fragment) it seems
preferrable to just drop them.

Same for temporary errors -- it doesn't make sense to accept (and
perhaps forward!) only some fragments of same datagram.

Fixes: 029f7f3b8701cc7ac ("netfilter: ipv6: nf_defrag: avoid/free clone operations")
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Debugged-by: Andrey Konovalov <andreyknvl@google.com>
Diagnosed-by: Eric Dumazet <Eric Dumazet <edumazet@google.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Acked-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

Before patch : 
 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb) >payload_len == 0) {
 		pr_debug("payload len = 0\n");
 		return  EINVAL;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
 		return  EINVAL;
 
 	if (!pskb_may_pull(skb, fhoff   sizeof(*fhdr)))
 		return  ENOMEM;
 	if (err ==  EINPROGRESS)
 		return NF_STOLEN;
 
 	return NF_ACCEPT;
 }
 
 static struct nf_hook_ops ipv6_defrag_ops[] = {
After patch : 
 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb) >payload_len == 0) {
 		pr_debug("payload len = 0\n");
 		return 0;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
 		return 0;
 
 	if (!pskb_may_pull(skb, fhoff   sizeof(*fhdr)))
 		return  ENOMEM;
 	if (err ==  EINPROGRESS)
 		return NF_STOLEN;
 
 	return err == 0 ? NF_ACCEPT : NF_DROP;
 }
 
 static struct nf_hook_ops ipv6_defrag_ops[] = {
