CVE Number : CVE-2017-12146
Commit Message : 
driver core: platform: fix race condition with driver_override
Commit Details : 
The driver_override implementation is susceptible to race condition when
different threads are reading vs storing a different driver override.
Add locking to avoid race condition.

Fixes: 3d713e0e382e ("driver core: platform: add device binding path 'driver_override'")
Cc: stable@vger.kernel.org
Signed-off-by: Adrian Salido <salidoa@google.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Before patch : 
 				     const char *buf, size_t count)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	char *driver_override, *old = pdev >driver_override, *cp;
 
 	if (count > PATH_MAX)
 		return  EINVAL;
 	if (cp)
 		*cp = '\0';
 
 	if (strlen(driver_override)) {
 		pdev >driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev >driver_override = NULL;
 	}
 
 	kfree(old);
 
 				    struct device_attribute *attr, char *buf)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 
 	return sprintf(buf, "%s\n", pdev >driver_override);
 }
 static DEVICE_ATTR_RW(driver_override);
 
After patch : 
 				     const char *buf, size_t count)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	char *driver_override, *old, *cp;
 
 	if (count > PATH_MAX)
 		return  EINVAL;
 	if (cp)
 		*cp = '\0';
 
 	device_lock(dev);
 	old = pdev >driver_override;
 	if (strlen(driver_override)) {
 		pdev >driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev >driver_override = NULL;
 	}
 	device_unlock(dev);
 
 	kfree(old);
 
 				    struct device_attribute *attr, char *buf)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	ssize_t len;
 
 	device_lock(dev);
 	len = sprintf(buf, "%s\n", pdev >driver_override);
 	device_unlock(dev);
 	return len;
 }
 static DEVICE_ATTR_RW(driver_override);
 
