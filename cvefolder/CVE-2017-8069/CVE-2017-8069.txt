CVE Number : CVE-2017-8069
Commit Message : 
rtl8150: Use heap buffers for all register access
Commit Details : 
Allocating USB buffers on the stack is not portable, and no longer
works on x86_64 (with VMAP_STACK enabled as per default).

Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 */
 static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
 	return usb_control_msg(dev >udev, usb_rcvctrlpipe(dev >udev, 0),
 			       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
 			       indx, 0, data, size, 500);
 }
 
 static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
 	return usb_control_msg(dev >udev, usb_sndctrlpipe(dev >udev, 0),
 			       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
 			       indx, 0, data, size, 500);
 }
 
 static void async_set_reg_cb(struct urb *urb)
After patch : 
 */
 static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
 	void *buf;
 	int ret;
 
 	buf = kmalloc(size, GFP_NOIO);
 	if (!buf)
 		return  ENOMEM;
 
 	ret = usb_control_msg(dev >udev, usb_rcvctrlpipe(dev >udev, 0),
 			      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
 			      indx, 0, buf, size, 500);
 	if (ret > 0 && ret <= size)
 		memcpy(data, buf, ret);
 	kfree(buf);
 	return ret;
 }
 
 static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)
 {
 	void *buf;
 	int ret;
 
 	buf = kmemdup(data, size, GFP_NOIO);
 	if (!buf)
 		return  ENOMEM;
 
 	ret = usb_control_msg(dev >udev, usb_sndctrlpipe(dev >udev, 0),
 			      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
 			      indx, 0, buf, size, 500);
 	kfree(buf);
 	return ret;
 }
 
 static void async_set_reg_cb(struct urb *urb)
