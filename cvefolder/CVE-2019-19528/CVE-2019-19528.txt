CVE Number : CVE-2019-19528
Commit Message : 
USB: iowarrior: fix use-after-free on disconnect
Commit Details : 
A recent fix addressing a deadlock on disconnect introduced a new bug
by moving the present flag out of the critical section protected by the
driver-data mutex. This could lead to a racing release() freeing the
driver data before disconnect() is done with it.

Due to insufficient locking a related use-after-free could be triggered
also before the above mentioned commit. Specifically, the driver needs
to hold the driver-data mutex also while checking the opened flag at
disconnect().

Fixes: c468a8aa790e ("usb: iowarrior: fix deadlock on disconnect")
Fixes: 946b960d13c1 ("USB: add driver for iowarrior devices.")
Cc: stable <stable@vger.kernel.org>	# 2.6.21
Reported-by: syzbot+0761012cebf7bdb38137@syzkaller.appspotmail.com
Signed-off-by: Johan Hovold <johan@kernel.org>
Link: https://lore.kernel.org/r/20191009104846.5925-2-johan@kernel.org
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Before patch : 
 	dev = usb_get_intfdata(interface);
 	mutex_lock(&iowarrior_open_disc_lock);
 	usb_set_intfdata(interface, NULL);
 	/* prevent device read, write and ioctl */
 	dev >present = 0;
 
 	minor = dev >minor;
 	mutex_unlock(&iowarrior_open_disc_lock);
 	mutex_lock(&dev >mutex);
 
 	/* prevent device read, write and ioctl */
 
 	mutex_unlock(&dev >mutex);
 
 	if (dev >opened) {
 		/* There is a process that holds a filedescriptor to the device ,
 		usb_kill_urb(dev >int_in_urb);
 		wake_up_interruptible(&dev >read_wait);
 		wake_up_interruptible(&dev >write_wait);
 	} else {
 		/* no process is using the device, cleanup now */
 		iowarrior_delete(dev);
 	}
 
After patch : 
 	dev = usb_get_intfdata(interface);
 	mutex_lock(&iowarrior_open_disc_lock);
 	usb_set_intfdata(interface, NULL);
 
 	minor = dev >minor;
 	mutex_unlock(&iowarrior_open_disc_lock);
 	mutex_lock(&dev >mutex);
 
 	/* prevent device read, write and ioctl */
 	dev >present = 0;
 
 	if (dev >opened) {
 		/* There is a process that holds a filedescriptor to the device ,
 		usb_kill_urb(dev >int_in_urb);
 		wake_up_interruptible(&dev >read_wait);
 		wake_up_interruptible(&dev >write_wait);
 		mutex_unlock(&dev >mutex);
 	} else {
 		/* no process is using the device, cleanup now */
 		mutex_unlock(&dev >mutex);
 		iowarrior_delete(dev);
 	}
 
