CVE Number : CVE-2015-7513
Commit Message : 
KVM: x86: Reload pit counters for all channels when restoring state
Commit Details : 
Currently if userspace restores the pit counters with a count of 0
on channels 1 or 2 and the guest attempts to read the count on those
channels, then KVM will perform a mod of 0 and crash.  This will ensure
that 0 values are converted to 65536 as per the spec.

This is CVE-2015-7513.

Signed-off-by: Andy Honig <ahonig@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

Before patch : 
 
 static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 {
 	mutex_lock(&kvm >arch.vpit >pit_state.lock);
 	memcpy(&kvm >arch.vpit >pit_state, ps, sizeof(struct kvm_pit_state));
 	kvm_pit_load_count(kvm, 0, ps >channels[0].count, 0);
 	mutex_unlock(&kvm >arch.vpit >pit_state.lock);
 	return 0;
 }
 static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm >arch.vpit >pit_state.lock);
 	prev_legacy = kvm >arch.vpit >pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
 	memcpy(&kvm >arch.vpit >pit_state.channels, &ps >channels,
 	       sizeof(kvm >arch.vpit >pit_state.channels));
 	kvm >arch.vpit >pit_state.flags = ps >flags;
 	kvm_pit_load_count(kvm, 0, kvm >arch.vpit >pit_state.channels[0].count, start);
 	mutex_unlock(&kvm >arch.vpit >pit_state.lock);
 	return 0;
 }
After patch : 
 
 static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 {
 	int i;
 	mutex_lock(&kvm >arch.vpit >pit_state.lock);
 	memcpy(&kvm >arch.vpit >pit_state, ps, sizeof(struct kvm_pit_state));
 	for (i = 0; i < 3; i  )
 		kvm_pit_load_count(kvm, i, ps >channels[i].count, 0);
 	mutex_unlock(&kvm >arch.vpit >pit_state.lock);
 	return 0;
 }
 static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
 	int i;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm >arch.vpit >pit_state.lock);
 	prev_legacy = kvm >arch.vpit >pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
 	memcpy(&kvm >arch.vpit >pit_state.channels, &ps >channels,
 	       sizeof(kvm >arch.vpit >pit_state.channels));
 	kvm >arch.vpit >pit_state.flags = ps >flags;
 	for (i = 0; i < 3; i  )
 		kvm_pit_load_count(kvm, i, kvm >arch.vpit >pit_state.channels[i].count, start);
 	mutex_unlock(&kvm >arch.vpit >pit_state.lock);
 	return 0;
 }
