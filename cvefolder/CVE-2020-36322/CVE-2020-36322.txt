CVE Number : CVE-2020-36322
Commit Message : 
fuse: fix bad inode
Commit Details : 
Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
Tested-by: Jan Kara <jack@suse.cz>
Cc: <stable@vger.kernel.org>

Before patch : 
 	void *value = NULL;
 	struct posix_acl *acl;
 
 	if (!fc >posix_acl || fc >no_getxattr)
 		return NULL;
 
 	const char *name;
 	int ret;
 
 	if (!fc >posix_acl || fc >no_setxattr)
 		return  EOPNOTSUPP;
 
 	int ret;
 
 	inode = d_inode_rcu(entry);
 	if (inode && is_bad_inode(inode))
 		goto invalid;
 	else if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||
 		 (flags & (LOOKUP_EXCL | LOOKUP_REVAL))) {
 	bool outarg_valid = true;
 	bool locked;
 
 	locked = fuse_lock_inode(dir);
 	err = fuse_lookup_name(dir >i_sb, get_node_id(dir), &entry >d_name,
 			       &outarg, &inode);
 	struct fuse_conn *fc = get_fuse_conn(dir);
 	struct dentry *res = NULL;
 
 	if (d_in_lookup(entry)) {
 		res = fuse_lookup(dir, entry, 0);
 		if (IS_ERR(res))
 	int err;
 	struct fuse_forget_link *forget;
 
 	forget = fuse_alloc_forget();
 	if (!forget)
 		return  ENOMEM;
 	struct fuse_mount *fm = get_fuse_mount(dir);
 	FUSE_ARGS(args);
 
 	args.opcode = FUSE_UNLINK;
 	args.nodeid = get_node_id(dir);
 	args.in_numargs = 1;
 	struct fuse_mount *fm = get_fuse_mount(dir);
 	FUSE_ARGS(args);
 
 	args.opcode = FUSE_RMDIR;
 	args.nodeid = get_node_id(dir);
 	args.in_numargs = 1;
 	struct fuse_conn *fc = get_fuse_conn(olddir);
 	int err;
 
 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
 		return  EINVAL;
 
 	if (!err) {
 		if (fuse_invalid_attr(&outarg.attr) ||
 		    (inode >i_mode ^ outarg.attr.mode) & S_IFMT) {
 			make_bad_inode(inode);
 			err =  EIO;
 		} else {
 			fuse_change_attributes(inode, &outarg.attr,
 	bool refreshed = false;
 	int err = 0;
 
 	if (!fuse_allow_current_process(fc))
 		return  EACCES;
 
 	int err;
 
 	err =  EIO;
 	if (is_bad_inode(inode))
 		goto out_err;
 
 	if (fc >cache_symlinks)
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
 	if (is_bad_inode(inode))
 		return  EIO;
 
 	if (fc >no_fsyncdir)
 
 	if (fuse_invalid_attr(&outarg.attr) ||
 	    (inode >i_mode ^ outarg.attr.mode) & S_IFMT) {
 		make_bad_inode(inode);
 		err =  EIO;
 		goto error;
 	}
 	struct file *file = (attr >ia_valid & ATTR_FILE) ? attr >ia_file : NULL;
 	int ret;
 
 	if (!fuse_allow_current_process(get_fuse_conn(inode)))
 		return  EACCES;
 
 	struct inode *inode = d_inode(path >dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 
 	if (!fuse_allow_current_process(fc)) {
 		if (!request_mask) {
 			/*
 	bool dax_truncate = (file >f_flags & O_TRUNC) &&
 			  fc >atomic_o_trunc && FUSE_IS_DAX(inode);
 
 	err = generic_file_open(inode, file);
 	if (err)
 		return err;
 	FUSE_ARGS(args);
 	int err;
 
 	if (is_bad_inode(inode))
 		return  EIO;
 
 	err = write_inode_now(inode, 1);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
 	if (is_bad_inode(inode))
 		return  EIO;
 
 	inode_lock(inode);
 	int err;
 
 	err =  EIO;
 	if (is_bad_inode(inode))
 		goto out;
 
 	err = fuse_do_readpage(file, page);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	unsigned int i, max_pages, nr_pages = 0;
 
 	if (is_bad_inode(inode))
 		return;
 
 	max_pages = min_t(unsigned int, fc >max_pages,
 	struct fuse_file *ff = file >private_data;
 	struct inode *inode = file_inode(file);
 
 	if (is_bad_inode(inode))
 		return  EIO;
 
 	if (FUSE_IS_DAX(inode))
 	struct fuse_file *ff = file >private_data;
 	struct inode *inode = file_inode(file);
 
 	if (is_bad_inode(inode))
 		return  EIO;
 
 	if (FUSE_IS_DAX(inode))
 	int err;
 
 	err =  EIO;
 	if (is_bad_inode(inode))
 		goto out;
 
 	data.inode = inode;
 	if (!fuse_allow_current_process(fc))
 		return  EACCES;
 
 	if (is_bad_inode(inode))
 		return  EIO;
 
 	return fuse_do_ioctl(file, cmd, arg, flags);
 	FUSE_I_INIT_RDPLUS,
 	/** An operation changing file size is in progress  */
 	FUSE_I_SIZE_UNSTABLE,
 };
 
 struct fuse_conn;
 	return atomic64_read(&fc >attr_version);
 }
 
 /** Device operations */
 extern const struct file_operations fuse_dev_operations;
 
 			fi >forget = NULL;
 		}
 	}
 	if (S_ISREG(inode >i_mode) && !is_bad_inode(inode)) {
 		WARN_ON(!list_empty(&fi >write_files));
 		WARN_ON(!list_empty(&fi >queued_writes));
 	}
 		unlock_new_inode(inode);
 	} else if ((inode >i_mode ^ attr >mode) & S_IFMT) {
 		/* Inode has changed type, any I/O on the old should fail */
 		make_bad_inode(inode);
 		iput(inode);
 		goto retry;
 	}
 			dput(dentry);
 			goto retry;
 		}
 		if (is_bad_inode(inode)) {
 			dput(dentry);
 			return  EIO;
 		}
 	struct inode *inode = file_inode(file);
 	int err;
 
 	if (is_bad_inode(inode))
 		return  EIO;
 
 	mutex_lock(&ff >readdir.lock);
 	struct fuse_getxattr_out outarg;
 	ssize_t ret;
 
 	if (!fuse_allow_current_process(fm >fc))
 		return  EACCES;
 
 			 struct dentry *dentry, struct inode *inode,
 			 const char *name, void *value, size_t size)
 {
 	return fuse_getxattr(inode, name, value, size);
 }
 
 			  const char *name, const void *value, size_t size,
 			  int flags)
 {
 	if (!value)
 		return fuse_removexattr(inode, name);
 
After patch : 
 	void *value = NULL;
 	struct posix_acl *acl;
 
 	if (fuse_is_bad(inode))
 		return ERR_PTR( EIO);
 
 	if (!fc >posix_acl || fc >no_getxattr)
 		return NULL;
 
 	const char *name;
 	int ret;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (!fc >posix_acl || fc >no_setxattr)
 		return  EOPNOTSUPP;
 
 	int ret;
 
 	inode = d_inode_rcu(entry);
 	if (inode && fuse_is_bad(inode))
 		goto invalid;
 	else if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||
 		 (flags & (LOOKUP_EXCL | LOOKUP_REVAL))) {
 	bool outarg_valid = true;
 	bool locked;
 
 	if (fuse_is_bad(dir))
 		return ERR_PTR( EIO);
 
 	locked = fuse_lock_inode(dir);
 	err = fuse_lookup_name(dir >i_sb, get_node_id(dir), &entry >d_name,
 			       &outarg, &inode);
 	struct fuse_conn *fc = get_fuse_conn(dir);
 	struct dentry *res = NULL;
 
 	if (fuse_is_bad(dir))
 		return  EIO;
 
 	if (d_in_lookup(entry)) {
 		res = fuse_lookup(dir, entry, 0);
 		if (IS_ERR(res))
 	int err;
 	struct fuse_forget_link *forget;
 
 	if (fuse_is_bad(dir))
 		return  EIO;
 
 	forget = fuse_alloc_forget();
 	if (!forget)
 		return  ENOMEM;
 	struct fuse_mount *fm = get_fuse_mount(dir);
 	FUSE_ARGS(args);
 
 	if (fuse_is_bad(dir))
 		return  EIO;
 
 	args.opcode = FUSE_UNLINK;
 	args.nodeid = get_node_id(dir);
 	args.in_numargs = 1;
 	struct fuse_mount *fm = get_fuse_mount(dir);
 	FUSE_ARGS(args);
 
 	if (fuse_is_bad(dir))
 		return  EIO;
 
 	args.opcode = FUSE_RMDIR;
 	args.nodeid = get_node_id(dir);
 	args.in_numargs = 1;
 	struct fuse_conn *fc = get_fuse_conn(olddir);
 	int err;
 
 	if (fuse_is_bad(olddir))
 		return  EIO;
 
 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
 		return  EINVAL;
 
 	if (!err) {
 		if (fuse_invalid_attr(&outarg.attr) ||
 		    (inode >i_mode ^ outarg.attr.mode) & S_IFMT) {
 			fuse_make_bad(inode);
 			err =  EIO;
 		} else {
 			fuse_change_attributes(inode, &outarg.attr,
 	bool refreshed = false;
 	int err = 0;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (!fuse_allow_current_process(fc))
 		return  EACCES;
 
 	int err;
 
 	err =  EIO;
 	if (fuse_is_bad(inode))
 		goto out_err;
 
 	if (fc >cache_symlinks)
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (fc >no_fsyncdir)
 
 	if (fuse_invalid_attr(&outarg.attr) ||
 	    (inode >i_mode ^ outarg.attr.mode) & S_IFMT) {
 		fuse_make_bad(inode);
 		err =  EIO;
 		goto error;
 	}
 	struct file *file = (attr >ia_valid & ATTR_FILE) ? attr >ia_file : NULL;
 	int ret;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (!fuse_allow_current_process(get_fuse_conn(inode)))
 		return  EACCES;
 
 	struct inode *inode = d_inode(path >dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (!fuse_allow_current_process(fc)) {
 		if (!request_mask) {
 			/*
 	bool dax_truncate = (file >f_flags & O_TRUNC) &&
 			  fc >atomic_o_trunc && FUSE_IS_DAX(inode);
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	err = generic_file_open(inode, file);
 	if (err)
 		return err;
 	FUSE_ARGS(args);
 	int err;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	err = write_inode_now(inode, 1);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	inode_lock(inode);
 	int err;
 
 	err =  EIO;
 	if (fuse_is_bad(inode))
 		goto out;
 
 	err = fuse_do_readpage(file, page);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	unsigned int i, max_pages, nr_pages = 0;
 
 	if (fuse_is_bad(inode))
 		return;
 
 	max_pages = min_t(unsigned int, fc >max_pages,
 	struct fuse_file *ff = file >private_data;
 	struct inode *inode = file_inode(file);
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (FUSE_IS_DAX(inode))
 	struct fuse_file *ff = file >private_data;
 	struct inode *inode = file_inode(file);
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (FUSE_IS_DAX(inode))
 	int err;
 
 	err =  EIO;
 	if (fuse_is_bad(inode))
 		goto out;
 
 	data.inode = inode;
 	if (!fuse_allow_current_process(fc))
 		return  EACCES;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	return fuse_do_ioctl(file, cmd, arg, flags);
 	FUSE_I_INIT_RDPLUS,
 	/** An operation changing file size is in progress  */
 	FUSE_I_SIZE_UNSTABLE,
 	/* Bad inode */
 	FUSE_I_BAD,
 };
 
 struct fuse_conn;
 	return atomic64_read(&fc >attr_version);
 }
 
 static inline void fuse_make_bad(struct inode *inode)
 {
 	set_bit(FUSE_I_BAD, &get_fuse_inode(inode) >state);
 }
 
 static inline bool fuse_is_bad(struct inode *inode)
 {
 	return unlikely(test_bit(FUSE_I_BAD, &get_fuse_inode(inode) >state));
 }
 
 /** Device operations */
 extern const struct file_operations fuse_dev_operations;
 
 			fi >forget = NULL;
 		}
 	}
 	if (S_ISREG(inode >i_mode) && !fuse_is_bad(inode)) {
 		WARN_ON(!list_empty(&fi >write_files));
 		WARN_ON(!list_empty(&fi >queued_writes));
 	}
 		unlock_new_inode(inode);
 	} else if ((inode >i_mode ^ attr >mode) & S_IFMT) {
 		/* Inode has changed type, any I/O on the old should fail */
 		fuse_make_bad(inode);
 		iput(inode);
 		goto retry;
 	}
 			dput(dentry);
 			goto retry;
 		}
 		if (fuse_is_bad(inode)) {
 			dput(dentry);
 			return  EIO;
 		}
 	struct inode *inode = file_inode(file);
 	int err;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	mutex_lock(&ff >readdir.lock);
 	struct fuse_getxattr_out outarg;
 	ssize_t ret;
 
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (!fuse_allow_current_process(fm >fc))
 		return  EACCES;
 
 			 struct dentry *dentry, struct inode *inode,
 			 const char *name, void *value, size_t size)
 {
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	return fuse_getxattr(inode, name, value, size);
 }
 
 			  const char *name, const void *value, size_t size,
 			  int flags)
 {
 	if (fuse_is_bad(inode))
 		return  EIO;
 
 	if (!value)
 		return fuse_removexattr(inode, name);
 
