CVE Number : CVE-2009-0065
Commit Message : 
sctp: Avoid memory overflow while FWD-TSN chunk is received with bad stream ID
Commit Details : 
If FWD-TSN chunk is received with bad stream ID, the sctp will not do the
validity check, this may cause memory overflow when overwrite the TSN of
the stream ID.

The FORWARD-TSN chunk is like this:

FORWARD-TSN chunk
  Type                       = 192
  Flags                      = 0
  Length                     = 172
  NewTSN                     = 99
  Stream                     = 10000
  StreamSequence             = 0xFFFF

This patch fix this problem by discard the chunk if stream ID is not
less than MIS.

Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 {
 	struct sctp_chunk *chunk = arg;
 	struct sctp_fwdtsn_hdr *fwdtsn_hdr;
 	__u16 len;
 	__u32 tsn;
 
 	if (sctp_tsnmap_check(&asoc >peer.tsn_map, tsn) < 0)
 		goto discard_noforce;
 
 	sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));
 	if (len > sizeof(struct sctp_fwdtsn_hdr))
 		sctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,
 {
 	struct sctp_chunk *chunk = arg;
 	struct sctp_fwdtsn_hdr *fwdtsn_hdr;
 	__u16 len;
 	__u32 tsn;
 
 	if (sctp_tsnmap_check(&asoc >peer.tsn_map, tsn) < 0)
 		goto gen_shutdown;
 
 	sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));
 	if (len > sizeof(struct sctp_fwdtsn_hdr))
 		sctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,
After patch : 
 {
 	struct sctp_chunk *chunk = arg;
 	struct sctp_fwdtsn_hdr *fwdtsn_hdr;
 	struct sctp_fwdtsn_skip *skip;
 	__u16 len;
 	__u32 tsn;
 
 	if (sctp_tsnmap_check(&asoc >peer.tsn_map, tsn) < 0)
 		goto discard_noforce;
 
 	/* Silently discard the chunk if stream id is not valid */
 	sctp_walk_fwdtsn(skip, chunk) {
 		if (ntohs(skip >stream) >= asoc >c.sinit_max_instreams)
 			goto discard_noforce;
 	}
 
 	sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));
 	if (len > sizeof(struct sctp_fwdtsn_hdr))
 		sctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,
 {
 	struct sctp_chunk *chunk = arg;
 	struct sctp_fwdtsn_hdr *fwdtsn_hdr;
 	struct sctp_fwdtsn_skip *skip;
 	__u16 len;
 	__u32 tsn;
 
 	if (sctp_tsnmap_check(&asoc >peer.tsn_map, tsn) < 0)
 		goto gen_shutdown;
 
 	/* Silently discard the chunk if stream id is not valid */
 	sctp_walk_fwdtsn(skip, chunk) {
 		if (ntohs(skip >stream) >= asoc >c.sinit_max_instreams)
 			goto gen_shutdown;
 	}
 
 	sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));
 	if (len > sizeof(struct sctp_fwdtsn_hdr))
 		sctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,
