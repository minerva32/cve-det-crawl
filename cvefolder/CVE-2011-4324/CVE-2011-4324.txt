CVE Number : CVE-2011-4324
Commit Message : 
NFSv4: Convert the open and close ops to use fmode
Commit Details : 
Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

Before patch : 
 /*
  * Given an inode, search for an open context with the desired characteristics
  */
 struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)
 {
 	struct nfs_inode *nfsi = NFS_I(inode);
 	struct nfs_open_context *pos, *ctx = NULL;
 	unsigned int n_rdonly;		/* Number of read only references */
 	unsigned int n_wronly;		/* Number of write only references */
 	unsigned int n_rdwr;		/* Number of read/write references */
 	int state;			/* State on the server (R,W, or RW) */
 	atomic_t count;
 };
 
 extern void nfs4_put_state_owner(struct nfs4_state_owner *);
 extern struct nfs4_state * nfs4_get_open_state(struct inode *, struct nfs4_state_owner *);
 extern void nfs4_put_open_state(struct nfs4_state *);
 extern void nfs4_close_state(struct path *, struct nfs4_state *, mode_t);
 extern void nfs4_close_sync(struct path *, struct nfs4_state *, mode_t);
 extern void nfs4_state_set_mode_locked(struct nfs4_state *, mode_t);
 extern void nfs4_schedule_state_recovery(struct nfs_client *);
 extern void nfs4_schedule_state_manager(struct nfs_client *);
 extern int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state);
 }
 
 static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,
 		struct nfs4_state_owner *sp, int flags,
 		const struct iattr *attrs)
 {
 	struct dentry *parent = dget_parent(path >dentry);
 	p >owner = sp;
 	atomic_inc(&sp >so_count);
 	p >o_arg.fh = NFS_FH(dir);
 	p >o_arg.open_flags = flags,
 	p >o_arg.clientid = server >nfs_client >cl_clientid;
 	p >o_arg.id = sp >so_owner_id.id;
 	p >o_arg.name = &p >path.dentry >d_name;
 	return ret;
 }
 
 static int can_open_cached(struct nfs4_state *state, int mode)
 {
 	int ret = 0;
 	switch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {
 		case FMODE_READ:
 			ret |= test_bit(NFS_O_RDONLY_STATE, &state >flags) != 0;
 			break;
 		case FMODE_READ|FMODE_WRITE:
 			ret |= test_bit(NFS_O_RDWR_STATE, &state >flags) != 0;
 	}
 	return ret;
 }
 
 static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)
 {
 	if ((delegation >type & open_flags) != open_flags)
 		return 0;
 	if (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation >flags))
 		return 0;
 	return 1;
 }
 
 static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)
 {
 	switch (open_flags) {
 		case FMODE_WRITE:
 			state >n_wronly  ;
 			break;
 		case FMODE_READ|FMODE_WRITE:
 			state >n_rdwr  ;
 	}
 	nfs4_state_set_mode_locked(state, state >state | open_flags);
 }
 
 static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)
 {
 	if (test_bit(NFS_DELEGATED_STATE, &state >flags) == 0)
 		memcpy(state >stateid.data, stateid >data, sizeof(state >stateid.data));
 	memcpy(state >open_stateid.data, stateid >data, sizeof(state >open_stateid.data));
 	switch (open_flags) {
 		case FMODE_READ:
 			set_bit(NFS_O_RDONLY_STATE, &state >flags);
 			break;
 	}
 }
 
 static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)
 {
 	write_seqlock(&state >seqlock);
 	nfs_set_open_stateid_locked(state, stateid, open_flags);
 	write_sequnlock(&state >seqlock);
 }
 
 static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)
 {
 	/*
 	 * Protect the call to nfs4_state_set_mode_locked and
 		set_bit(NFS_DELEGATED_STATE, &state >flags);
 	}
 	if (open_stateid != NULL)
 		nfs_set_open_stateid_locked(state, open_stateid, open_flags);
 	write_sequnlock(&state >seqlock);
 	spin_lock(&state >owner >so_lock);
 	update_open_stateflags(state, open_flags);
 	spin_unlock(&state >owner >so_lock);
 }
 
 static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)
 {
 	struct nfs_inode *nfsi = NFS_I(state >inode);
 	struct nfs_delegation *deleg_cur;
 	int ret = 0;
 
 	open_flags &= (FMODE_READ|FMODE_WRITE);
 
 	rcu_read_lock();
 	deleg_cur = rcu_dereference(nfsi >delegation);
 
 	spin_lock(&deleg_cur >lock);
 	if (nfsi >delegation != deleg_cur ||
 	    (deleg_cur >type & open_flags) != open_flags)
 		goto no_delegation_unlock;
 
 	if (delegation == NULL)
 		goto no_delegation_unlock;
 
 	nfs_mark_delegation_referenced(deleg_cur);
 	__update_open_stateid(state, open_stateid, &deleg_cur >stateid, open_flags);
 	ret = 1;
 no_delegation_unlock:
 	spin_unlock(&deleg_cur >lock);
 	rcu_read_unlock();
 
 	if (!ret && open_stateid != NULL) {
 		__update_open_stateid(state, open_stateid, NULL, open_flags);
 		ret = 1;
 	}
 
 }
 
 
 static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)
 {
 	struct nfs_delegation *delegation;
 
 	rcu_read_lock();
 	delegation = rcu_dereference(NFS_I(inode) >delegation);
 	if (delegation == NULL || (delegation >type & open_flags) == open_flags) {
 		rcu_read_unlock();
 		return;
 	}
 	struct nfs4_state *state = opendata >state;
 	struct nfs_inode *nfsi = NFS_I(state >inode);
 	struct nfs_delegation *delegation;
 	int open_mode = opendata >o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);
 	nfs4_stateid stateid;
 	int ret =  EAGAIN;
 
 	for (;;) {
 		if (can_open_cached(state, open_mode)) {
 			spin_lock(&state >owner >so_lock);
 			if (can_open_cached(state, open_mode)) {
 				update_open_stateflags(state, open_mode);
 				spin_unlock(&state >owner >so_lock);
 				goto out_return_state;
 			}
 		rcu_read_lock();
 		delegation = rcu_dereference(nfsi >delegation);
 		if (delegation == NULL ||
 		    !can_open_delegated(delegation, open_mode)) {
 			rcu_read_unlock();
 			break;
 		}
 		ret =  EAGAIN;
 
 		/* Try to update the stateid using the delegation */
 		if (update_open_stateid(state, NULL, &stateid, open_mode))
 			goto out_return_state;
 	}
 out:
 	}
 
 	update_open_stateid(state, &data >o_res.stateid, NULL,
 			data >o_arg.open_flags);
 	iput(inode);
 out:
 	return state;
 {
 	struct nfs4_opendata *opendata;
 
 	opendata = nfs4_opendata_alloc(&ctx >path, state >owner, 0, NULL);
 	if (opendata == NULL)
 		return ERR_PTR( ENOMEM);
 	opendata >state = state;
 	return opendata;
 }
 
 static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)
 {
 	struct nfs4_state *newstate;
 	int ret;
 
 	opendata >o_arg.open_flags = openflags;
 	memset(&opendata >o_res, 0, sizeof(opendata >o_res));
 	memset(&opendata >c_res, 0, sizeof(opendata >c_res));
 	nfs4_init_opendata_res(opendata);
 	newstate = nfs4_opendata_to_nfs4_state(opendata);
 	if (IS_ERR(newstate))
 		return PTR_ERR(newstate);
 	nfs4_close_state(&opendata >path, newstate, openflags);
 	*res = newstate;
 	return 0;
 }
 {
 	struct nfs_delegation *delegation;
 	struct nfs4_opendata *opendata;
 	int delegation_type = 0;
 	int status;
 
 	opendata = nfs4_open_recoverdata_alloc(ctx, state);
 		goto out_free;
 	state = nfs4_opendata_to_nfs4_state(data);
 	if (!IS_ERR(state))
 		nfs4_close_state(&data >path, state, data >o_arg.open_flags);
 out_free:
 	nfs4_opendata_put(data);
 }
 	if (data >state != NULL) {
 		struct nfs_delegation *delegation;
 
 		if (can_open_cached(data >state, data >o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))
 			goto out_no_action;
 		rcu_read_lock();
 		delegation = rcu_dereference(NFS_I(data >state >inode) >delegation);
 		goto out_free;
 	state = nfs4_opendata_to_nfs4_state(data);
 	if (!IS_ERR(state))
 		nfs4_close_state(&data >path, state, data >o_arg.open_flags);
 out_free:
 	nfs4_opendata_put(data);
 }
 /*
  * Returns a referenced nfs4_state
  */
 static int _nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)
 {
 	struct nfs4_state_owner  *sp;
 	struct nfs4_state     *state = NULL;
 	if (status != 0)
 		goto err_put_state_owner;
 	if (path >dentry >d_inode != NULL)
 		nfs4_return_incompatible_delegation(path >dentry >d_inode, flags & (FMODE_READ|FMODE_WRITE));
 	status =  ENOMEM;
 	opendata = nfs4_opendata_alloc(path, sp, flags, sattr);
 	if (opendata == NULL)
 		goto err_put_state_owner;
 
 }
 
 
 static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)
 {
 	struct nfs4_exception exception = { };
 	struct nfs4_state *res;
 	int status;
 
 	do {
 		status = _nfs4_do_open(dir, path, flags, sattr, cred, &res);
 		if (status == 0)
 			break;
 		/* NOTE: BAD_SEQID means the server and client disagree about the
 		case  NFS4ERR_OLD_STATEID:
 		case  NFS4ERR_BAD_STATEID:
 		case  NFS4ERR_EXPIRED:
 			if (calldata >arg.open_flags == 0)
 				break;
 		default:
 			if (nfs4_async_handle_error(task, server, state) ==  EAGAIN) {
 	nfs_fattr_init(calldata >res.fattr);
 	if (test_bit(NFS_O_RDONLY_STATE, &state >flags) != 0) {
 		task >tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];
 		calldata >arg.open_flags = FMODE_READ;
 	} else if (test_bit(NFS_O_WRONLY_STATE, &state >flags) != 0) {
 		task >tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];
 		calldata >arg.open_flags = FMODE_WRITE;
 	}
 	calldata >timestamp = jiffies;
 	rpc_call_start(task);
 	calldata >arg.seqid = nfs_alloc_seqid(&state >owner >so_seqid);
 	if (calldata >arg.seqid == NULL)
 		goto out_free_calldata;
 	calldata >arg.open_flags = 0;
 	calldata >arg.bitmask = server >attr_bitmask;
 	calldata >res.fattr = &calldata >fattr;
 	calldata >res.seqid = calldata >arg.seqid;
 	return status;
 }
 
 static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)
 {
 	struct file *filp;
 	int ret;
 
 	/* If the open_intent is for execute, we have an extra check to make */
 	if (nd >intent.open.flags & FMODE_EXEC) {
 		ret = nfs_may_open(state >inode,
 				state >owner >so_cred,
 				nd >intent.open.flags);
 	}
 	ret = PTR_ERR(filp);
 out_close:
 	nfs4_close_sync(path, state, nd >intent.open.flags);
 	return ret;
 }
 
 	struct rpc_cred *cred;
 	struct nfs4_state *state;
 	struct dentry *res;
 
 	if (nd >flags & LOOKUP_CREATE) {
 		attr.ia_mode = nd >intent.open.create_mode;
 	parent = dentry >d_parent;
 	/* Protect against concurrent sillydeletes */
 	nfs_block_sillyrename(parent);
 	state = nfs4_do_open(dir, &path, nd >intent.open.flags, &attr, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state)) {
 		if (PTR_ERR(state) ==  ENOENT) {
 		path.dentry = res;
 	nfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));
 	nfs_unblock_sillyrename(parent);
 	nfs4_intent_set_file(nd, &path, state);
 	return res;
 }
 
 	};
 	struct rpc_cred *cred;
 	struct nfs4_state *state;
 
 	cred = rpc_lookup_cred();
 	if (IS_ERR(cred))
 		return PTR_ERR(cred);
 	state = nfs4_do_open(dir, &path, openflags, NULL, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state)) {
 		switch (PTR_ERR(state)) {
 	}
 	if (state >inode == dentry >d_inode) {
 		nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
 		nfs4_intent_set_file(nd, &path, state);
 		return 1;
 	}
 	nfs4_close_sync(&path, state, openflags);
 out_drop:
 	d_drop(dentry);
 	return 0;
 	};
 	struct nfs4_state *state;
 	struct rpc_cred *cred;
 	int status = 0;
 
 	cred = rpc_lookup_cred();
 		status = PTR_ERR(cred);
 		goto out;
 	}
 	state = nfs4_do_open(dir, &path, flags, sattr, cred);
 	d_drop(dentry);
 	if (IS_ERR(state)) {
 		status = PTR_ERR(state);
 		nfs_post_op_update_inode(state >inode, &fattr);
 	}
 	if (status == 0 && (nd >flags & LOOKUP_OPEN) != 0)
 		status = nfs4_intent_set_file(nd, &path, state);
 	else
 		nfs4_close_sync(&path, state, flags);
 out_putcred:
 	put_rpccred(cred);
 out:
 }
 
 void
 nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)
 {
 	if (state >state == mode)
 		return;
 	/* NB! List reordering   see the reclaim code for why.  */
 	if ((mode & FMODE_WRITE) != (state >state & FMODE_WRITE)) {
 		if (mode & FMODE_WRITE)
 			list_move(&state >open_states, &state >owner >so_states);
 		else
 			list_move_tail(&state >open_states, &state >owner >so_states);
 	}
 	state >state = mode;
 }
 
 static struct nfs4_state *
 /*
  * Close the current file.
  */
 static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)
 {
 	struct nfs4_state_owner *owner = state >owner;
 	int call_close = 0;
 	int newstate;
 
 	atomic_inc(&owner >so_count);
 	/* Protect against nfs4_find_state() */
 	spin_lock(&owner >so_lock);
 	switch (mode & (FMODE_READ | FMODE_WRITE)) {
 		case FMODE_READ:
 			state >n_rdonly  ;
 			break;
 		nfs4_do_close(path, state, wait);
 }
 
 void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)
 {
 	__nfs4_close(path, state, mode, 0);
 }
 
 void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)
 {
 	__nfs4_close(path, state, mode, 1);
 }
 
 /*
 	return 0;
 }
 
 static void encode_share_access(struct xdr_stream *xdr, int open_flags)
 {
 	__be32 *p;
 
 	RESERVE_SPACE(8);
 	switch (open_flags & (FMODE_READ|FMODE_WRITE)) {
 		case FMODE_READ:
 			WRITE32(NFS4_SHARE_ACCESS_READ);
 			break;
 			WRITE32(NFS4_SHARE_ACCESS_BOTH);
 			break;
 		default:
 			BUG();
 	}
 	WRITE32(0);		/* for linux, share_deny = 0 always */
 }
 	RESERVE_SPACE(8);
 	WRITE32(OP_OPEN);
 	WRITE32(arg >seqid >sequence >counter);
 	encode_share_access(xdr, arg >open_flags);
 	RESERVE_SPACE(28);
 	WRITE64(arg >clientid);
 	WRITE32(16);
 	WRITE32(OP_OPEN_DOWNGRADE);
 	WRITEMEM(arg >stateid >data, NFS4_STATEID_SIZE);
 	WRITE32(arg >seqid >sequence >counter);
 	encode_share_access(xdr, arg >open_flags);
 	return 0;
 }
 
 	struct rpc_cred *cred;
 	struct nfs4_state *state;
 	fl_owner_t lockowner;
 	int mode;
 
 	unsigned long flags;
 #define NFS_CONTEXT_ERROR_WRITE		(0)
 extern void nfs_setattr_update_inode(struct inode *inode, struct iattr *attr);
 extern struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx);
 extern void put_nfs_open_context(struct nfs_open_context *ctx);
 extern struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode);
 extern u64 nfs_compat_user_ino64(u64 fileid);
 extern void nfs_fattr_init(struct nfs_fattr *fattr);
 
 	const struct nfs_fh *	fh;
 	struct nfs_seqid *	seqid;
 	int			open_flags;
 	__u64                   clientid;
 	__u64                   id;
 	union {
 	struct nfs_fh *         fh;
 	nfs4_stateid *		stateid;
 	struct nfs_seqid *	seqid;
 	int			open_flags;
 	const u32 *		bitmask;
 };
 
After patch : 
 /*
  * Given an inode, search for an open context with the desired characteristics
  */
 struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)
 {
 	struct nfs_inode *nfsi = NFS_I(inode);
 	struct nfs_open_context *pos, *ctx = NULL;
 	unsigned int n_rdonly;		/* Number of read only references */
 	unsigned int n_wronly;		/* Number of write only references */
 	unsigned int n_rdwr;		/* Number of read/write references */
 	fmode_t state;			/* State on the server (R,W, or RW) */
 	atomic_t count;
 };
 
 extern void nfs4_put_state_owner(struct nfs4_state_owner *);
 extern struct nfs4_state * nfs4_get_open_state(struct inode *, struct nfs4_state_owner *);
 extern void nfs4_put_open_state(struct nfs4_state *);
 extern void nfs4_close_state(struct path *, struct nfs4_state *, fmode_t);
 extern void nfs4_close_sync(struct path *, struct nfs4_state *, fmode_t);
 extern void nfs4_state_set_mode_locked(struct nfs4_state *, fmode_t);
 extern void nfs4_schedule_state_recovery(struct nfs_client *);
 extern void nfs4_schedule_state_manager(struct nfs_client *);
 extern int nfs4_state_mark_reclaim_nograce(struct nfs_client *clp, struct nfs4_state *state);
 }
 
 static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,
 		struct nfs4_state_owner *sp, fmode_t fmode, int flags,
 		const struct iattr *attrs)
 {
 	struct dentry *parent = dget_parent(path >dentry);
 	p >owner = sp;
 	atomic_inc(&sp >so_count);
 	p >o_arg.fh = NFS_FH(dir);
 	p >o_arg.open_flags = flags;
 	p >o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);
 	p >o_arg.clientid = server >nfs_client >cl_clientid;
 	p >o_arg.id = sp >so_owner_id.id;
 	p >o_arg.name = &p >path.dentry >d_name;
 	return ret;
 }
 
 static int can_open_cached(struct nfs4_state *state, fmode_t mode, int open_mode)
 {
 	int ret = 0;
 
 	if (open_mode & O_EXCL)
 		goto out;
 	switch (mode & (FMODE_READ|FMODE_WRITE)) {
 		case FMODE_READ:
 			ret |= test_bit(NFS_O_RDONLY_STATE, &state >flags) != 0;
 			break;
 		case FMODE_READ|FMODE_WRITE:
 			ret |= test_bit(NFS_O_RDWR_STATE, &state >flags) != 0;
 	}
 out:
 	return ret;
 }
 
 static int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode)
 {
 	if ((delegation >type & fmode) != fmode)
 		return 0;
 	if (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation >flags))
 		return 0;
 	return 1;
 }
 
 static void update_open_stateflags(struct nfs4_state *state, fmode_t fmode)
 {
 	switch (fmode) {
 		case FMODE_WRITE:
 			state >n_wronly  ;
 			break;
 		case FMODE_READ|FMODE_WRITE:
 			state >n_rdwr  ;
 	}
 	nfs4_state_set_mode_locked(state, state >state | fmode);
 }
 
 static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)
 {
 	if (test_bit(NFS_DELEGATED_STATE, &state >flags) == 0)
 		memcpy(state >stateid.data, stateid >data, sizeof(state >stateid.data));
 	memcpy(state >open_stateid.data, stateid >data, sizeof(state >open_stateid.data));
 	switch (fmode) {
 		case FMODE_READ:
 			set_bit(NFS_O_RDONLY_STATE, &state >flags);
 			break;
 	}
 }
 
 static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)
 {
 	write_seqlock(&state >seqlock);
 	nfs_set_open_stateid_locked(state, stateid, fmode);
 	write_sequnlock(&state >seqlock);
 }
 
 static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, fmode_t fmode)
 {
 	/*
 	 * Protect the call to nfs4_state_set_mode_locked and
 		set_bit(NFS_DELEGATED_STATE, &state >flags);
 	}
 	if (open_stateid != NULL)
 		nfs_set_open_stateid_locked(state, open_stateid, fmode);
 	write_sequnlock(&state >seqlock);
 	spin_lock(&state >owner >so_lock);
 	update_open_stateflags(state, fmode);
 	spin_unlock(&state >owner >so_lock);
 }
 
 static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)
 {
 	struct nfs_inode *nfsi = NFS_I(state >inode);
 	struct nfs_delegation *deleg_cur;
 	int ret = 0;
 
 	fmode &= (FMODE_READ|FMODE_WRITE);
 
 	rcu_read_lock();
 	deleg_cur = rcu_dereference(nfsi >delegation);
 
 	spin_lock(&deleg_cur >lock);
 	if (nfsi >delegation != deleg_cur ||
 	    (deleg_cur >type & fmode) != fmode)
 		goto no_delegation_unlock;
 
 	if (delegation == NULL)
 		goto no_delegation_unlock;
 
 	nfs_mark_delegation_referenced(deleg_cur);
 	__update_open_stateid(state, open_stateid, &deleg_cur >stateid, fmode);
 	ret = 1;
 no_delegation_unlock:
 	spin_unlock(&deleg_cur >lock);
 	rcu_read_unlock();
 
 	if (!ret && open_stateid != NULL) {
 		__update_open_stateid(state, open_stateid, NULL, fmode);
 		ret = 1;
 	}
 
 }
 
 
 static void nfs4_return_incompatible_delegation(struct inode *inode, fmode_t fmode)
 {
 	struct nfs_delegation *delegation;
 
 	rcu_read_lock();
 	delegation = rcu_dereference(NFS_I(inode) >delegation);
 	if (delegation == NULL || (delegation >type & fmode) == fmode) {
 		rcu_read_unlock();
 		return;
 	}
 	struct nfs4_state *state = opendata >state;
 	struct nfs_inode *nfsi = NFS_I(state >inode);
 	struct nfs_delegation *delegation;
 	int open_mode = opendata >o_arg.open_flags & O_EXCL;
 	fmode_t fmode = opendata >o_arg.fmode;
 	nfs4_stateid stateid;
 	int ret =  EAGAIN;
 
 	for (;;) {
 		if (can_open_cached(state, fmode, open_mode)) {
 			spin_lock(&state >owner >so_lock);
 			if (can_open_cached(state, fmode, open_mode)) {
 				update_open_stateflags(state, fmode);
 				spin_unlock(&state >owner >so_lock);
 				goto out_return_state;
 			}
 		rcu_read_lock();
 		delegation = rcu_dereference(nfsi >delegation);
 		if (delegation == NULL ||
 		    !can_open_delegated(delegation, fmode)) {
 			rcu_read_unlock();
 			break;
 		}
 		ret =  EAGAIN;
 
 		/* Try to update the stateid using the delegation */
 		if (update_open_stateid(state, NULL, &stateid, fmode))
 			goto out_return_state;
 	}
 out:
 	}
 
 	update_open_stateid(state, &data >o_res.stateid, NULL,
 			data >o_arg.fmode);
 	iput(inode);
 out:
 	return state;
 {
 	struct nfs4_opendata *opendata;
 
 	opendata = nfs4_opendata_alloc(&ctx >path, state >owner, 0, 0, NULL);
 	if (opendata == NULL)
 		return ERR_PTR( ENOMEM);
 	opendata >state = state;
 	return opendata;
 }
 
 static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, fmode_t fmode, struct nfs4_state **res)
 {
 	struct nfs4_state *newstate;
 	int ret;
 
 	opendata >o_arg.open_flags = 0;
 	opendata >o_arg.fmode = fmode;
 	memset(&opendata >o_res, 0, sizeof(opendata >o_res));
 	memset(&opendata >c_res, 0, sizeof(opendata >c_res));
 	nfs4_init_opendata_res(opendata);
 	newstate = nfs4_opendata_to_nfs4_state(opendata);
 	if (IS_ERR(newstate))
 		return PTR_ERR(newstate);
 	nfs4_close_state(&opendata >path, newstate, fmode);
 	*res = newstate;
 	return 0;
 }
 {
 	struct nfs_delegation *delegation;
 	struct nfs4_opendata *opendata;
 	fmode_t delegation_type = 0;
 	int status;
 
 	opendata = nfs4_open_recoverdata_alloc(ctx, state);
 		goto out_free;
 	state = nfs4_opendata_to_nfs4_state(data);
 	if (!IS_ERR(state))
 		nfs4_close_state(&data >path, state, data >o_arg.fmode);
 out_free:
 	nfs4_opendata_put(data);
 }
 	if (data >state != NULL) {
 		struct nfs_delegation *delegation;
 
 		if (can_open_cached(data >state, data >o_arg.fmode, data >o_arg.open_flags))
 			goto out_no_action;
 		rcu_read_lock();
 		delegation = rcu_dereference(NFS_I(data >state >inode) >delegation);
 		goto out_free;
 	state = nfs4_opendata_to_nfs4_state(data);
 	if (!IS_ERR(state))
 		nfs4_close_state(&data >path, state, data >o_arg.fmode);
 out_free:
 	nfs4_opendata_put(data);
 }
 /*
  * Returns a referenced nfs4_state
  */
 static int _nfs4_do_open(struct inode *dir, struct path *path, fmode_t fmode, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)
 {
 	struct nfs4_state_owner  *sp;
 	struct nfs4_state     *state = NULL;
 	if (status != 0)
 		goto err_put_state_owner;
 	if (path >dentry >d_inode != NULL)
 		nfs4_return_incompatible_delegation(path >dentry >d_inode, fmode);
 	status =  ENOMEM;
 	opendata = nfs4_opendata_alloc(path, sp, fmode, flags, sattr);
 	if (opendata == NULL)
 		goto err_put_state_owner;
 
 }
 
 
 static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, fmode_t fmode, int flags, struct iattr *sattr, struct rpc_cred *cred)
 {
 	struct nfs4_exception exception = { };
 	struct nfs4_state *res;
 	int status;
 
 	do {
 		status = _nfs4_do_open(dir, path, fmode, flags, sattr, cred, &res);
 		if (status == 0)
 			break;
 		/* NOTE: BAD_SEQID means the server and client disagree about the
 		case  NFS4ERR_OLD_STATEID:
 		case  NFS4ERR_BAD_STATEID:
 		case  NFS4ERR_EXPIRED:
 			if (calldata >arg.fmode == 0)
 				break;
 		default:
 			if (nfs4_async_handle_error(task, server, state) ==  EAGAIN) {
 	nfs_fattr_init(calldata >res.fattr);
 	if (test_bit(NFS_O_RDONLY_STATE, &state >flags) != 0) {
 		task >tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];
 		calldata >arg.fmode = FMODE_READ;
 	} else if (test_bit(NFS_O_WRONLY_STATE, &state >flags) != 0) {
 		task >tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];
 		calldata >arg.fmode = FMODE_WRITE;
 	}
 	calldata >timestamp = jiffies;
 	rpc_call_start(task);
 	calldata >arg.seqid = nfs_alloc_seqid(&state >owner >so_seqid);
 	if (calldata >arg.seqid == NULL)
 		goto out_free_calldata;
 	calldata >arg.fmode = 0;
 	calldata >arg.bitmask = server >attr_bitmask;
 	calldata >res.fattr = &calldata >fattr;
 	calldata >res.seqid = calldata >arg.seqid;
 	return status;
 }
 
 static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state, fmode_t fmode)
 {
 	struct file *filp;
 	int ret;
 
 	/* If the open_intent is for execute, we have an extra check to make */
 	if (fmode & FMODE_EXEC) {
 		ret = nfs_may_open(state >inode,
 				state >owner >so_cred,
 				nd >intent.open.flags);
 	}
 	ret = PTR_ERR(filp);
 out_close:
 	nfs4_close_sync(path, state, fmode & (FMODE_READ|FMODE_WRITE));
 	return ret;
 }
 
 	struct rpc_cred *cred;
 	struct nfs4_state *state;
 	struct dentry *res;
 	fmode_t fmode = nd >intent.open.flags & (FMODE_READ | FMODE_WRITE | FMODE_EXEC);
 
 	if (nd >flags & LOOKUP_CREATE) {
 		attr.ia_mode = nd >intent.open.create_mode;
 	parent = dentry >d_parent;
 	/* Protect against concurrent sillydeletes */
 	nfs_block_sillyrename(parent);
 	state = nfs4_do_open(dir, &path, fmode, nd >intent.open.flags, &attr, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state)) {
 		if (PTR_ERR(state) ==  ENOENT) {
 		path.dentry = res;
 	nfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));
 	nfs_unblock_sillyrename(parent);
 	nfs4_intent_set_file(nd, &path, state, fmode);
 	return res;
 }
 
 	};
 	struct rpc_cred *cred;
 	struct nfs4_state *state;
 	fmode_t fmode = openflags & (FMODE_READ | FMODE_WRITE);
 
 	cred = rpc_lookup_cred();
 	if (IS_ERR(cred))
 		return PTR_ERR(cred);
 	state = nfs4_do_open(dir, &path, fmode, openflags, NULL, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state)) {
 		switch (PTR_ERR(state)) {
 	}
 	if (state >inode == dentry >d_inode) {
 		nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
 		nfs4_intent_set_file(nd, &path, state, fmode);
 		return 1;
 	}
 	nfs4_close_sync(&path, state, fmode);
 out_drop:
 	d_drop(dentry);
 	return 0;
 	};
 	struct nfs4_state *state;
 	struct rpc_cred *cred;
 	fmode_t fmode = flags & (FMODE_READ | FMODE_WRITE);
 	int status = 0;
 
 	cred = rpc_lookup_cred();
 		status = PTR_ERR(cred);
 		goto out;
 	}
 	state = nfs4_do_open(dir, &path, fmode, flags, sattr, cred);
 	d_drop(dentry);
 	if (IS_ERR(state)) {
 		status = PTR_ERR(state);
 		nfs_post_op_update_inode(state >inode, &fattr);
 	}
 	if (status == 0 && (nd >flags & LOOKUP_OPEN) != 0)
 		status = nfs4_intent_set_file(nd, &path, state, fmode);
 	else
 		nfs4_close_sync(&path, state, fmode);
 out_putcred:
 	put_rpccred(cred);
 out:
 }
 
 void
 nfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)
 {
 	if (state >state == fmode)
 		return;
 	/* NB! List reordering   see the reclaim code for why.  */
 	if ((fmode & FMODE_WRITE) != (state >state & FMODE_WRITE)) {
 		if (fmode & FMODE_WRITE)
 			list_move(&state >open_states, &state >owner >so_states);
 		else
 			list_move_tail(&state >open_states, &state >owner >so_states);
 	}
 	state >state = fmode;
 }
 
 static struct nfs4_state *
 /*
  * Close the current file.
  */
 static void __nfs4_close(struct path *path, struct nfs4_state *state, fmode_t fmode, int wait)
 {
 	struct nfs4_state_owner *owner = state >owner;
 	int call_close = 0;
 	fmode_t newstate;
 
 	atomic_inc(&owner >so_count);
 	/* Protect against nfs4_find_state() */
 	spin_lock(&owner >so_lock);
 	switch (fmode & (FMODE_READ | FMODE_WRITE)) {
 		case FMODE_READ:
 			state >n_rdonly  ;
 			break;
 		nfs4_do_close(path, state, wait);
 }
 
 void nfs4_close_state(struct path *path, struct nfs4_state *state, fmode_t fmode)
 {
 	__nfs4_close(path, state, fmode, 0);
 }
 
 void nfs4_close_sync(struct path *path, struct nfs4_state *state, fmode_t fmode)
 {
 	__nfs4_close(path, state, fmode, 1);
 }
 
 /*
 	return 0;
 }
 
 static void encode_share_access(struct xdr_stream *xdr, fmode_t fmode)
 {
 	__be32 *p;
 
 	RESERVE_SPACE(8);
 	switch (fmode & (FMODE_READ|FMODE_WRITE)) {
 		case FMODE_READ:
 			WRITE32(NFS4_SHARE_ACCESS_READ);
 			break;
 			WRITE32(NFS4_SHARE_ACCESS_BOTH);
 			break;
 		default:
 			WRITE32(0);
 	}
 	WRITE32(0);		/* for linux, share_deny = 0 always */
 }
 	RESERVE_SPACE(8);
 	WRITE32(OP_OPEN);
 	WRITE32(arg >seqid >sequence >counter);
 	encode_share_access(xdr, arg >fmode);
 	RESERVE_SPACE(28);
 	WRITE64(arg >clientid);
 	WRITE32(16);
 	WRITE32(OP_OPEN_DOWNGRADE);
 	WRITEMEM(arg >stateid >data, NFS4_STATEID_SIZE);
 	WRITE32(arg >seqid >sequence >counter);
 	encode_share_access(xdr, arg >fmode);
 	return 0;
 }
 
 	struct rpc_cred *cred;
 	struct nfs4_state *state;
 	fl_owner_t lockowner;
 	fmode_t mode;
 
 	unsigned long flags;
 #define NFS_CONTEXT_ERROR_WRITE		(0)
 extern void nfs_setattr_update_inode(struct inode *inode, struct iattr *attr);
 extern struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx);
 extern void put_nfs_open_context(struct nfs_open_context *ctx);
 extern struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode);
 extern u64 nfs_compat_user_ino64(u64 fileid);
 extern void nfs_fattr_init(struct nfs_fattr *fattr);
 
 	const struct nfs_fh *	fh;
 	struct nfs_seqid *	seqid;
 	int			open_flags;
 	fmode_t			fmode;
 	__u64                   clientid;
 	__u64                   id;
 	union {
 	struct nfs_fh *         fh;
 	nfs4_stateid *		stateid;
 	struct nfs_seqid *	seqid;
 	fmode_t			fmode;
 	const u32 *		bitmask;
 };
 
