CVE Number : CVE-2013-7269
Commit Message : 
net: rework recvmsg handler msg_name and msg_namelen logic
Commit Details : 
This patch now always passes msg->msg_namelen as 0. recvmsg handlers must
set msg_namelen to the proper size <= sizeof(struct sockaddr_storage)
to return msg_name to the user.

This prevents numerous uninitialized memory leaks we had in the
recvmsg handlers and makes it harder for new code to accidentally leak
uninitialized memory.

Optimize for the case recvfrom is called with NULL as address. We don't
need to copy the address at all, so set it to NULL before invoking the
recvmsg handler. We can do so, because all the recvmsg handlers must
cope with the case a plain read() is called on them. read() also sets
msg_name to NULL.

Also document these changes in include/linux/net.h as suggested by David
Miller.

Changes since RFC:

Set msg->msg_name = NULL if user specified a NULL in msg_name but had a
non-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't
affect sendto as it would bail out earlier while trying to copy-in the
address. It also more naturally reflects the logic by the callers of
verify_iovec.

With this change in place I could remove "
if (!uaddr || msg_sys->msg_namelen == 0)
	msg->msg_name = NULL
".

This change does not alter the user visible error logic as we ignore
msg_namelen as long as msg_name is NULL.

Also remove two unnecessary curly brackets in ___sys_recvmsg and change
comments to netdev style.

Cc: David Miller <davem@davemloft.net>
Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 	else if (len < ds)
 		msg >msg_flags |= MSG_TRUNC;
 
 	msg >msg_namelen = 0;
 
 	lock_sock(sk);
 	if (ctx >more) {
 		ctx >more = 0;
 	long copied = 0;
 
 	lock_sock(sk);
 	msg >msg_namelen = 0;
 	for (iov = msg >msg_iov, iovlen = msg >msg_iovlen; iovlen > 0;
 	     iovlen  , iov  ) {
 		unsigned long seglen = iov >iov_len;
 {
 	struct sk_buff		*skb;
 	struct sock		*sk = sock >sk;
 	struct sockaddr_mISDN	*maddr;
 
 	int		copied, err;
 
 	if (!skb)
 		return err;
 
 	if (msg >msg_namelen >= sizeof(struct sockaddr_mISDN)) {
 		msg >msg_namelen = sizeof(struct sockaddr_mISDN);
 		maddr = (struct sockaddr_mISDN *)msg >msg_name;
 		maddr >family = AF_ISDN;
 		maddr >dev = _pms(sk) >dev >id;
 		if ((sk >sk_protocol == ISDN_P_LAPD_TE) ||
 			maddr >sapi = _pms(sk) >ch.addr & 0xFF;
 			maddr >tei =  (_pms(sk) >ch.addr >> 8) & 0xFF;
 		}
 	} else {
 		if (msg >msg_namelen)
 			printk(KERN_WARNING "%s: too small namelen %d\n",
 			       __func__, msg >msg_namelen);
 		msg >msg_namelen = 0;
 	}
 
 	copied = skb >len   MISDN_HEADER_LEN;
 	if (error < 0)
 		goto end;
 
 	m >msg_namelen = 0;
 
 	if (skb) {
 		total_len = min_t(size_t, total_len, skb >len);
 		error = skb_copy_datagram_iovec(skb, 0, m >msg_iov, total_len);
 #endif
 	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
 				      struct msghdr *m, size_t total_len);
 	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,
 				      struct msghdr *m, size_t total_len,
 				      int flags);
 			 size_t size, int flags)
 {
 	struct sock *sk = sock >sk;
 	struct sockaddr_at *sat = (struct sockaddr_at *)msg >msg_name;
 	struct ddpehdr *ddp;
 	int copied = 0;
 	int offset = 0;
 	}
 	err = skb_copy_datagram_iovec(skb, offset, msg >msg_iov, copied);
 
 	if (!err) {
 		if (sat) {
 			sat >sat_family      = AF_APPLETALK;
 			sat >sat_port        = ddp >deh_sport;
 			sat >sat_addr.s_node = ddp >deh_snode;
 			sat >sat_addr.s_net  = ddp >deh_snet;
 		}
 		msg >msg_namelen = sizeof(*sat);
 	}
 
 	skb_free_datagram(sk, skb);	/* Free the datagram. */
 	struct sk_buff *skb;
 	int copied, error =  EINVAL;
 
 	msg >msg_namelen = 0;
 
 	if (sock >state != SS_CONNECTED)
 		return  ENOTCONN;
 
 
 	skb_copy_datagram_iovec(skb, 0, msg >msg_iov, copied);
 
 	if (msg >msg_namelen != 0) {
 		struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg >msg_name;
 		ax25_digi digi;
 		ax25_address src;
 		const unsigned char *mac = skb_mac_header(skb);
 
 		memset(sax, 0, sizeof(struct full_sockaddr_ax25));
 		ax25_addr_parse(mac   1, skb >data   mac   1, &src, NULL,
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk >sk_shutdown & RCV_SHUTDOWN) {
 			msg >msg_namelen = 0;
 			return 0;
 		}
 		return err;
 	}
 
 		if (bt_sk(sk) >skb_msg_name)
 			bt_sk(sk) >skb_msg_name(skb, msg >msg_name,
 						&msg >msg_namelen);
 		else
 			msg >msg_namelen = 0;
 	}
 
 	skb_free_datagram(sk, skb);
 	if (flags & MSG_OOB)
 		return  EOPNOTSUPP;
 
 	msg >msg_namelen = 0;
 
 	BT_DBG("sk %p size %zu", sk, size);
 
 	lock_sock(sk);
 	if (!skb)
 		return err;
 
 	msg >msg_namelen = 0;
 
 	copied = skb >len;
 	if (len < copied) {
 		msg >msg_flags |= MSG_TRUNC;
 
 	if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d >flags)) {
 		rfcomm_dlc_accept(d);
 		msg >msg_namelen = 0;
 		return 0;
 	}
 
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk) >flags)) {
 		sco_conn_defer_accept(pi >conn >hcon, pi >setting);
 		sk >sk_state = BT_CONFIG;
 		msg >msg_namelen = 0;
 
 		release_sock(sk);
 		return 0;
 	if (m >msg_flags&MSG_OOB)
 		goto read_error;
 
 	m >msg_namelen = 0;
 
 	skb = skb_recv_datagram(sk, flags, 0 , &ret);
 	if (!skb)
 		goto read_error;
 	if (flags&MSG_OOB)
 		goto out;
 
 	msg >msg_namelen = 0;
 
 	/*
 	 * Lock the socket to prevent queue disordering
 	 * while sleeps in memcpy_tomsg
 			if (err < 0)
 				return err;
 		}
 		kern_msg >msg_name = kern_address;
 	} else
 		kern_msg >msg_name = NULL;
 
 			if (err < 0)
 				return err;
 		}
 		m >msg_name = address;
 	} else {
 		m >msg_name = NULL;
 	}
 	if (skb >tstamp.tv64)
 		sk >sk_stamp = skb >tstamp;
 
 	msg >msg_namelen = sizeof(*sipx);
 
 	if (sipx) {
 		sipx >sipx_family	= AF_IPX;
 		sipx >sipx_port		= ipx >ipx_source.sock;
 		sipx >sipx_network	= IPX_SKB_CB(skb) >ipx_source_net;
 		sipx >sipx_type 	= ipx >ipx_type;
 		sipx >sipx_zero		= 0;
 	}
 	rc = copied;
 
 
 	IRDA_DEBUG(4, "%s()\n", __func__);
 
 	msg >msg_namelen = 0;
 
 	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
 				flags & MSG_DONTWAIT, &err);
 	if (!skb)
 	target = sock_rcvlowat(sk, flags & MSG_WAITALL, size);
 	timeo = sock_rcvtimeo(sk, noblock);
 
 	msg >msg_namelen = 0;
 
 	do {
 		int chunk;
 		struct sk_buff *skb = skb_dequeue(&sk >sk_receive_queue);
 	int err = 0;
 	u32 offset;
 
 	msg >msg_namelen = 0;
 
 	if ((sk >sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv >backlog_skb_q) &&
 	    skb_queue_empty(&sk >sk_receive_queue) &&
 	if (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))
 		goto out;
 
 	msg >msg_namelen = 0;
 	skb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);
 	if (skb == NULL)
 		goto out;
 	if (sk >sk_state & PPPOX_BOUND)
 		goto end;
 
 	msg >msg_namelen = 0;
 
 	err = 0;
 	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
 				flags & MSG_DONTWAIT, &err);
 	int target;	/* Read at least this many bytes */
 	long timeo;
 
 	msg >msg_namelen = 0;
 
 	lock_sock(sk);
 	copied =  ENOTCONN;
 	if (unlikely(sk >sk_type == SOCK_STREAM && sk >sk_state == TCP_LISTEN))
 	}
 #endif
 
 	msg >msg_namelen = 0;
 
 	copied = data_skb >len;
 	if (len < copied) {
 		msg >msg_flags |= MSG_TRUNC;
 		sax >sax25_family = AF_NETROM;
 		skb_copy_from_linear_data_offset(skb, 7, sax >sax25_call.ax25_call,
 			      AX25_ADDR_LEN);
 	}
 
 	msg >msg_namelen = sizeof(*sax);
 
 	skb_free_datagram(sk, skb);
 
 	release_sock(sk);
 
 	pr_debug("%p %zu\n", sk, len);
 
 	msg >msg_namelen = 0;
 
 	lock_sock(sk);
 
 	if (sk >sk_state == LLCP_CLOSED &&
 	if (!skb)
 		return rc;
 
 	msg >msg_namelen = 0;
 
 	copied = skb >len;
 	if (len < copied) {
 		msg >msg_flags |= MSG_TRUNC;
 	struct sock *sk = sock >sk;
 	struct sk_buff *skb;
 	int copied, err;
 	struct sockaddr_ll *sll;
 	int vnet_hdr_len = 0;
 
 	err =  EINVAL;
 			goto out_free;
 	}
 
 	/*
 	 *	If the address length field is there to be filled in, we fill
 	 *	it in now.
 	 */
 
 	sll = &PACKET_SKB_CB(skb) >sa.ll;
 	if (sock >type == SOCK_PACKET)
 		msg >msg_namelen = sizeof(struct sockaddr_pkt);
 	else
 		msg >msg_namelen = sll >sll_halen   offsetof(struct sockaddr_ll, sll_addr);
 
 	/*
 	 *	You lose any data beyond the buffer you gave. If it worries a
 	 *	user program they can ask the device for its MTU anyway.
 	 */
 
 	copied = skb >len;
 	if (copied > len) {
 		copied = len;
 
 	sock_recv_ts_and_drops(msg, sk, skb);
 
 	if (msg >msg_name)
 		memcpy(msg >msg_name, &PACKET_SKB_CB(skb) >sa,
 		       msg >msg_namelen);
 
 	if (pkt_sk(sk) >auxdata) {
 		struct tpacket_auxdata aux;
 
 	rdsdebug("size %zu flags 0x%x timeo %ld\n", size, msg_flags, timeo);
 
 	msg >msg_namelen = 0;
 
 	if (msg_flags & MSG_OOB)
 		goto out;
 
 {
 	struct sock *sk = sock >sk;
 	struct rose_sock *rose = rose_sk(sk);
 	struct sockaddr_rose *srose = (struct sockaddr_rose *)msg >msg_name;
 	size_t copied;
 	unsigned char *asmptr;
 	struct sk_buff *skb;
 
 	skb_copy_datagram_iovec(skb, 0, msg >msg_iov, copied);
 
 	if (srose != NULL) {
 		memset(srose, 0, msg >msg_namelen);
 		srose >srose_family = AF_ROSE;
 		srose >srose_addr   = rose >dest_addr;
 		srose >srose_call   = rose >dest_call;
 
 		/* copy the peer address and timestamp */
 		if (!continue_call) {
 			if (msg >msg_name && msg >msg_namelen > 0)
 				memcpy(msg >msg_name,
 				       &call >conn >trans >peer >srx,
 				       sizeof(call >conn >trans >peer >srx));
 			sock_recv_ts_and_drops(msg, &rx >sk, skb);
 		}
 
 	msg.msg_iov = &iov;
 	iov.iov_len = size;
 	iov.iov_base = ubuf;
 	msg.msg_name = (struct sockaddr *)&address;
 	msg.msg_namelen = sizeof(address);
 	if (sock >file >f_flags & O_NONBLOCK)
 		flags |= MSG_DONTWAIT;
 	err = sock_recvmsg(sock, &msg, size, flags);
 			goto out;
 	}
 
 	/*
 	 *      Save the user mode address (verify_iovec will change the
 	 *      kernel msghdr to use the kernel address space)
 	 */
 
 	uaddr = (__force void __user *)msg_sys >msg_name;
 	uaddr_len = COMPAT_NAMELEN(msg);
 	if (MSG_CMSG_COMPAT & flags) {
 		err = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);
 	} else
 		err = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);
 	if (err < 0)
 		goto out_freeiov;
 	cmsg_ptr = (unsigned long)msg_sys >msg_control;
 	msg_sys >msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);
 
 	if (sock >file >f_flags & O_NONBLOCK)
 		flags |= MSG_DONTWAIT;
 	err = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,
 		goto exit;
 	}
 
 	/* will be updated in set_orig_addr() if needed */
 	m >msg_namelen = 0;
 
 	timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 restart:
 
 		goto exit;
 	}
 
 	/* will be updated in set_orig_addr() if needed */
 	m >msg_namelen = 0;
 
 	target = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);
 	timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 
 {
 	struct unix_sock *u = unix_sk(sk);
 
 	msg >msg_namelen = 0;
 	if (u >addr) {
 		msg >msg_namelen = u >addr >len;
 		memcpy(msg >msg_name, u >addr >name, u >addr >len);
 	if (flags&MSG_OOB)
 		goto out;
 
 	msg >msg_namelen = 0;
 
 	err = mutex_lock_interruptible(&u >readlock);
 	if (err) {
 		err = sock_intr_errno(sock_rcvtimeo(sk, noblock));
 	target = sock_rcvlowat(sk, flags&MSG_WAITALL, size);
 	timeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);
 
 	msg >msg_namelen = 0;
 
 	/* Lock the socket to prevent queue disordering
 	 * while sleeps in memcpy_tomsg
 	 */
 	vsk = vsock_sk(sk);
 	err = 0;
 
 	msg >msg_namelen = 0;
 
 	lock_sock(sk);
 
 	if (sk >sk_state != SS_CONNECTED) {
 	if (flags & MSG_OOB || flags & MSG_ERRQUEUE)
 		return  EOPNOTSUPP;
 
 	msg >msg_namelen = 0;
 
 	/* Retrieve the head sk_buff from the socket's receive queue. */
 	err = 0;
 	skb = skb_recv_datagram(&vsk >sk, flags, noblock, &err);
 	if (sx25) {
 		sx25 >sx25_family = AF_X25;
 		sx25 >sx25_addr   = x25 >dest_addr;
 	}
 
 	msg >msg_namelen = sizeof(struct sockaddr_x25);
 
 	x25_check_rbuf(sk);
 	rc = copied;
 out_free_dgram:
After patch : 
 	else if (len < ds)
 		msg >msg_flags |= MSG_TRUNC;
 
 	lock_sock(sk);
 	if (ctx >more) {
 		ctx >more = 0;
 	long copied = 0;
 
 	lock_sock(sk);
 	for (iov = msg >msg_iov, iovlen = msg >msg_iovlen; iovlen > 0;
 	     iovlen  , iov  ) {
 		unsigned long seglen = iov >iov_len;
 {
 	struct sk_buff		*skb;
 	struct sock		*sk = sock >sk;
 
 	int		copied, err;
 
 	if (!skb)
 		return err;
 
 	if (msg >msg_name) {
 		struct sockaddr_mISDN *maddr = msg >msg_name;
 
 		maddr >family = AF_ISDN;
 		maddr >dev = _pms(sk) >dev >id;
 		if ((sk >sk_protocol == ISDN_P_LAPD_TE) ||
 			maddr >sapi = _pms(sk) >ch.addr & 0xFF;
 			maddr >tei =  (_pms(sk) >ch.addr >> 8) & 0xFF;
 		}
 		msg >msg_namelen = sizeof(*maddr);
 	}
 
 	copied = skb >len   MISDN_HEADER_LEN;
 	if (error < 0)
 		goto end;
 
 	if (skb) {
 		total_len = min_t(size_t, total_len, skb >len);
 		error = skb_copy_datagram_iovec(skb, 0, m >msg_iov, total_len);
 #endif
 	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
 				      struct msghdr *m, size_t total_len);
 	/* Notes for implementing recvmsg:
 	 * ===============================
 	 * msg >msg_namelen should get updated by the recvmsg handlers
 	 * iff msg_name != NULL. It is by default 0 to prevent
 	 * returning uninitialized memory to user space.  The recvfrom
 	 * handlers can assume that msg.msg_name is either NULL or has
 	 * a minimum size of sizeof(struct sockaddr_storage).
 	 */
 	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,
 				      struct msghdr *m, size_t total_len,
 				      int flags);
 			 size_t size, int flags)
 {
 	struct sock *sk = sock >sk;
 	struct ddpehdr *ddp;
 	int copied = 0;
 	int offset = 0;
 	}
 	err = skb_copy_datagram_iovec(skb, offset, msg >msg_iov, copied);
 
 	if (!err && msg >msg_name) {
 		struct sockaddr_at *sat = msg >msg_name;
 		sat >sat_family      = AF_APPLETALK;
 		sat >sat_port        = ddp >deh_sport;
 		sat >sat_addr.s_node = ddp >deh_snode;
 		sat >sat_addr.s_net  = ddp >deh_snet;
 		msg >msg_namelen     = sizeof(*sat);
 	}
 
 	skb_free_datagram(sk, skb);	/* Free the datagram. */
 	struct sk_buff *skb;
 	int copied, error =  EINVAL;
 
 	if (sock >state != SS_CONNECTED)
 		return  ENOTCONN;
 
 
 	skb_copy_datagram_iovec(skb, 0, msg >msg_iov, copied);
 
 	if (msg >msg_name) {
 		ax25_digi digi;
 		ax25_address src;
 		const unsigned char *mac = skb_mac_header(skb);
 		struct sockaddr_ax25 *sax = msg >msg_name;
 
 		memset(sax, 0, sizeof(struct full_sockaddr_ax25));
 		ax25_addr_parse(mac   1, skb >data   mac   1, &src, NULL,
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk >sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 
 		return err;
 	}
 
 		if (bt_sk(sk) >skb_msg_name)
 			bt_sk(sk) >skb_msg_name(skb, msg >msg_name,
 						&msg >msg_namelen);
 	}
 
 	skb_free_datagram(sk, skb);
 	if (flags & MSG_OOB)
 		return  EOPNOTSUPP;
 
 	BT_DBG("sk %p size %zu", sk, size);
 
 	lock_sock(sk);
 	if (!skb)
 		return err;
 
 	copied = skb >len;
 	if (len < copied) {
 		msg >msg_flags |= MSG_TRUNC;
 
 	if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d >flags)) {
 		rfcomm_dlc_accept(d);
 		return 0;
 	}
 
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk) >flags)) {
 		sco_conn_defer_accept(pi >conn >hcon, pi >setting);
 		sk >sk_state = BT_CONFIG;
 
 		release_sock(sk);
 		return 0;
 	if (m >msg_flags&MSG_OOB)
 		goto read_error;
 
 	skb = skb_recv_datagram(sk, flags, 0 , &ret);
 	if (!skb)
 		goto read_error;
 	if (flags&MSG_OOB)
 		goto out;
 
 	/*
 	 * Lock the socket to prevent queue disordering
 	 * while sleeps in memcpy_tomsg
 			if (err < 0)
 				return err;
 		}
 		if (kern_msg >msg_name)
 			kern_msg >msg_name = kern_address;
 	} else
 		kern_msg >msg_name = NULL;
 
 			if (err < 0)
 				return err;
 		}
 		if (m >msg_name)
 			m >msg_name = address;
 	} else {
 		m >msg_name = NULL;
 	}
 	if (skb >tstamp.tv64)
 		sk >sk_stamp = skb >tstamp;
 
 	if (sipx) {
 		sipx >sipx_family	= AF_IPX;
 		sipx >sipx_port		= ipx >ipx_source.sock;
 		sipx >sipx_network	= IPX_SKB_CB(skb) >ipx_source_net;
 		sipx >sipx_type 	= ipx >ipx_type;
 		sipx >sipx_zero		= 0;
 		msg >msg_namelen	= sizeof(*sipx);
 	}
 	rc = copied;
 
 
 	IRDA_DEBUG(4, "%s()\n", __func__);
 
 	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
 				flags & MSG_DONTWAIT, &err);
 	if (!skb)
 	target = sock_rcvlowat(sk, flags & MSG_WAITALL, size);
 	timeo = sock_rcvtimeo(sk, noblock);
 
 	do {
 		int chunk;
 		struct sk_buff *skb = skb_dequeue(&sk >sk_receive_queue);
 	int err = 0;
 	u32 offset;
 
 	if ((sk >sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv >backlog_skb_q) &&
 	    skb_queue_empty(&sk >sk_receive_queue) &&
 	if (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))
 		goto out;
 
 	skb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);
 	if (skb == NULL)
 		goto out;
 	if (sk >sk_state & PPPOX_BOUND)
 		goto end;
 
 	err = 0;
 	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
 				flags & MSG_DONTWAIT, &err);
 	int target;	/* Read at least this many bytes */
 	long timeo;
 
 	lock_sock(sk);
 	copied =  ENOTCONN;
 	if (unlikely(sk >sk_type == SOCK_STREAM && sk >sk_state == TCP_LISTEN))
 	}
 #endif
 
 	copied = data_skb >len;
 	if (len < copied) {
 		msg >msg_flags |= MSG_TRUNC;
 		sax >sax25_family = AF_NETROM;
 		skb_copy_from_linear_data_offset(skb, 7, sax >sax25_call.ax25_call,
 			      AX25_ADDR_LEN);
 		msg >msg_namelen = sizeof(*sax);
 	}
 
 	skb_free_datagram(sk, skb);
 
 	release_sock(sk);
 
 	pr_debug("%p %zu\n", sk, len);
 
 	lock_sock(sk);
 
 	if (sk >sk_state == LLCP_CLOSED &&
 	if (!skb)
 		return rc;
 
 	copied = skb >len;
 	if (len < copied) {
 		msg >msg_flags |= MSG_TRUNC;
 	struct sock *sk = sock >sk;
 	struct sk_buff *skb;
 	int copied, err;
 	int vnet_hdr_len = 0;
 
 	err =  EINVAL;
 			goto out_free;
 	}
 
 	/* You lose any data beyond the buffer you gave. If it worries
 	 * a user program they can ask the device for its MTU
 	 * anyway.
 	 */
 	copied = skb >len;
 	if (copied > len) {
 		copied = len;
 
 	sock_recv_ts_and_drops(msg, sk, skb);
 
 	if (msg >msg_name) {
 		/* If the address length field is there to be filled
 		 * in, we fill it in now.
 		 */
 		if (sock >type == SOCK_PACKET) {
 			msg >msg_namelen = sizeof(struct sockaddr_pkt);
 		} else {
 			struct sockaddr_ll *sll = &PACKET_SKB_CB(skb) >sa.ll;
 			msg >msg_namelen = sll >sll_halen  
 				offsetof(struct sockaddr_ll, sll_addr);
 		}
 		memcpy(msg >msg_name, &PACKET_SKB_CB(skb) >sa,
 		       msg >msg_namelen);
 	}
 
 	if (pkt_sk(sk) >auxdata) {
 		struct tpacket_auxdata aux;
 
 	rdsdebug("size %zu flags 0x%x timeo %ld\n", size, msg_flags, timeo);
 
 	if (msg_flags & MSG_OOB)
 		goto out;
 
 {
 	struct sock *sk = sock >sk;
 	struct rose_sock *rose = rose_sk(sk);
 	size_t copied;
 	unsigned char *asmptr;
 	struct sk_buff *skb;
 
 	skb_copy_datagram_iovec(skb, 0, msg >msg_iov, copied);
 
 	if (msg >msg_name) {
 		struct sockaddr_rose *srose;
 
 		memset(msg >msg_name, 0, sizeof(struct full_sockaddr_rose));
 		srose = msg >msg_name;
 		srose >srose_family = AF_ROSE;
 		srose >srose_addr   = rose >dest_addr;
 		srose >srose_call   = rose >dest_call;
 
 		/* copy the peer address and timestamp */
 		if (!continue_call) {
 			if (msg >msg_name) {
 				size_t len =
 					sizeof(call >conn >trans >peer >srx);
 				memcpy(msg >msg_name,
 				       &call >conn >trans >peer >srx, len);
 				msg >msg_namelen = len;
 			}
 			sock_recv_ts_and_drops(msg, &rx >sk, skb);
 		}
 
 	msg.msg_iov = &iov;
 	iov.iov_len = size;
 	iov.iov_base = ubuf;
 	/* Save some cycles and don't copy the address if not needed */
 	msg.msg_name = addr ? (struct sockaddr *)&address : NULL;
 	/* We assume all kernel code knows the size of sockaddr_storage */
 	msg.msg_namelen = 0;
 	if (sock >file >f_flags & O_NONBLOCK)
 		flags |= MSG_DONTWAIT;
 	err = sock_recvmsg(sock, &msg, size, flags);
 			goto out;
 	}
 
 	/* Save the user mode address (verify_iovec will change the
 	 * kernel msghdr to use the kernel address space)
 	 */
 	uaddr = (__force void __user *)msg_sys >msg_name;
 	uaddr_len = COMPAT_NAMELEN(msg);
 	if (MSG_CMSG_COMPAT & flags)
 		err = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);
 	else
 		err = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);
 	if (err < 0)
 		goto out_freeiov;
 	cmsg_ptr = (unsigned long)msg_sys >msg_control;
 	msg_sys >msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);
 
 	/* We assume all kernel code knows the size of sockaddr_storage */
 	msg_sys >msg_namelen = 0;
 
 	if (sock >file >f_flags & O_NONBLOCK)
 		flags |= MSG_DONTWAIT;
 	err = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,
 		goto exit;
 	}
 
 	timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 restart:
 
 		goto exit;
 	}
 
 	target = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);
 	timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 
 {
 	struct unix_sock *u = unix_sk(sk);
 
 	if (u >addr) {
 		msg >msg_namelen = u >addr >len;
 		memcpy(msg >msg_name, u >addr >name, u >addr >len);
 	if (flags&MSG_OOB)
 		goto out;
 
 	err = mutex_lock_interruptible(&u >readlock);
 	if (err) {
 		err = sock_intr_errno(sock_rcvtimeo(sk, noblock));
 	target = sock_rcvlowat(sk, flags&MSG_WAITALL, size);
 	timeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);
 
 	/* Lock the socket to prevent queue disordering
 	 * while sleeps in memcpy_tomsg
 	 */
 	vsk = vsock_sk(sk);
 	err = 0;
 
 	lock_sock(sk);
 
 	if (sk >sk_state != SS_CONNECTED) {
 	if (flags & MSG_OOB || flags & MSG_ERRQUEUE)
 		return  EOPNOTSUPP;
 
 	/* Retrieve the head sk_buff from the socket's receive queue. */
 	err = 0;
 	skb = skb_recv_datagram(&vsk >sk, flags, noblock, &err);
 	if (sx25) {
 		sx25 >sx25_family = AF_X25;
 		sx25 >sx25_addr   = x25 >dest_addr;
 		msg >msg_namelen = sizeof(*sx25);
 	}
 
 	x25_check_rbuf(sk);
 	rc = copied;
 out_free_dgram:
