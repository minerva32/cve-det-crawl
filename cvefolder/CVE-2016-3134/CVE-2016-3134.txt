CVE Number : CVE-2016-3134
Commit Message : 
netfilter: x_tables: fix unconditional helper
Commit Details : 
Ben Hawkes says:

 In the mark_source_chains function (net/ipv4/netfilter/ip_tables.c) it
 is possible for a user-supplied ipt_entry structure to have a large
 next_offset field. This field is not bounds checked prior to writing a
 counter value at the supplied offset.

Problem is that mark_source_chains should not have been called --
the rule doesn't have a next entry, so its supposed to return
an absolute verdict of either ACCEPT or DROP.

However, the function conditional() doesn't work as the name implies.
It only checks that the rule is using wildcard address matching.

However, an unconditional rule must also not be using any matches
(no -m args).

The underflow validator only checked the addresses, therefore
passing the 'unconditional absolute verdict' test, while
mark_source_chains also tested for presence of matches, and thus
proceeeded to the next (not-existent) rule.

Unify this so that all the callers have same idea of 'unconditional rule'.

Reported-by: Ben Hawkes <hawkes@google.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

Before patch : 
 }
 
 /* All zeroes == unconditional rule. */
 static inline bool unconditional(const struct arpt_arp *arp)
 {
 	static const struct arpt_arp uncond;
 
 	return memcmp(arp, &uncond, sizeof(uncond)) == 0;
 }
 
 /* Figures out from what hook each rule can be called: returns 0 if
 				|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));
 
 			/* Unconditional return/END. */
 			if ((e >target_offset == sizeof(struct arpt_entry) &&
 			     (strcmp(t >target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
 			     t >verdict < 0 && unconditional(&e >arp)) ||
 			    visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t >target.u.user.name,
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
 	if (!unconditional(&e >arp))
 		return false;
 	t = arpt_get_target_c(e);
 	if (strcmp(t >u.user.name, XT_STANDARD_TARGET) != 0)
 			newinfo >hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e   base == underflows[h]) {
 			if (!check_underflow(e)) {
 				pr_err("Underflows must be unconditional and "
 				       "use the STANDARD target with "
 				       "ACCEPT/DROP\n");
 				return  EINVAL;
 			}
 			newinfo >underflow[h] = underflows[h];
 
 /* All zeroes == unconditional rule. */
 /* Mildly perf critical (only if packet tracing is on) */
 static inline bool unconditional(const struct ipt_ip *ip)
 {
 	static const struct ipt_ip uncond;
 
 	return memcmp(ip, &uncond, sizeof(uncond)) == 0;
 #undef FWINV
 }
 
 	} else if (s == e) {
 		(*rulenum)  ;
 
 		if (s >target_offset == sizeof(struct ipt_entry) &&
 		    strcmp(t >target.u.kernel.target >name,
 			   XT_STANDARD_TARGET) == 0 &&
 		   t >verdict < 0 &&
 		   unconditional(&s >ip)) {
 			/* Tail of chains: STANDARD target (return/policy) */
 			*comment = *chainname == hookname
 				? comments[NF_IP_TRACE_COMMENT_POLICY]
 			e >comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));
 
 			/* Unconditional return/END. */
 			if ((e >target_offset == sizeof(struct ipt_entry) &&
 			     (strcmp(t >target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
 			     t >verdict < 0 && unconditional(&e >ip)) ||
 			    visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t >target.u.user.name,
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
 	if (!unconditional(&e >ip))
 		return false;
 	t = ipt_get_target_c(e);
 	if (strcmp(t >u.user.name, XT_STANDARD_TARGET) != 0)
 			newinfo >hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e   base == underflows[h]) {
 			if (!check_underflow(e)) {
 				pr_err("Underflows must be unconditional and "
 				       "use the STANDARD target with "
 				       "ACCEPT/DROP\n");
 				return  EINVAL;
 			}
 			newinfo >underflow[h] = underflows[h];
 
 /* All zeroes == unconditional rule. */
 /* Mildly perf critical (only if packet tracing is on) */
 static inline bool unconditional(const struct ip6t_ip6 *ipv6)
 {
 	static const struct ip6t_ip6 uncond;
 
 	return memcmp(ipv6, &uncond, sizeof(uncond)) == 0;
 }
 
 static inline const struct xt_entry_target *
 	} else if (s == e) {
 		(*rulenum)  ;
 
 		if (s >target_offset == sizeof(struct ip6t_entry) &&
 		    strcmp(t >target.u.kernel.target >name,
 			   XT_STANDARD_TARGET) == 0 &&
 		    t >verdict < 0 &&
 		    unconditional(&s >ipv6)) {
 			/* Tail of chains: STANDARD target (return/policy) */
 			*comment = *chainname == hookname
 				? comments[NF_IP6_TRACE_COMMENT_POLICY]
 			e >comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));
 
 			/* Unconditional return/END. */
 			if ((e >target_offset == sizeof(struct ip6t_entry) &&
 			     (strcmp(t >target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
 			     t >verdict < 0 &&
 			     unconditional(&e >ipv6)) || visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t >target.u.user.name,
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
 	if (!unconditional(&e >ipv6))
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t >u.user.name, XT_STANDARD_TARGET) != 0)
 			newinfo >hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e   base == underflows[h]) {
 			if (!check_underflow(e)) {
 				pr_err("Underflows must be unconditional and "
 				       "use the STANDARD target with "
 				       "ACCEPT/DROP\n");
 				return  EINVAL;
 			}
 			newinfo >underflow[h] = underflows[h];
After patch : 
 }
 
 /* All zeroes == unconditional rule. */
 static inline bool unconditional(const struct arpt_entry *e)
 {
 	static const struct arpt_arp uncond;
 
 	return e >target_offset == sizeof(struct arpt_entry) &&
 	       memcmp(&e >arp, &uncond, sizeof(uncond)) == 0;
 }
 
 /* Figures out from what hook each rule can be called: returns 0 if
 				|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));
 
 			/* Unconditional return/END. */
 			if ((unconditional(e) &&
 			     (strcmp(t >target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
 			     t >verdict < 0) || visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t >target.u.user.name,
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
 	if (!unconditional(e))
 		return false;
 	t = arpt_get_target_c(e);
 	if (strcmp(t >u.user.name, XT_STANDARD_TARGET) != 0)
 			newinfo >hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e   base == underflows[h]) {
 			if (!check_underflow(e)) {
 				pr_debug("Underflows must be unconditional and "
 					 "use the STANDARD target with "
 					 "ACCEPT/DROP\n");
 				return  EINVAL;
 			}
 			newinfo >underflow[h] = underflows[h];
 
 /* All zeroes == unconditional rule. */
 /* Mildly perf critical (only if packet tracing is on) */
 static inline bool unconditional(const struct ipt_entry *e)
 {
 	static const struct ipt_ip uncond;
 
 	return e >target_offset == sizeof(struct ipt_entry) &&
 	       memcmp(&e >ip, &uncond, sizeof(uncond)) == 0;
 #undef FWINV
 }
 
 	} else if (s == e) {
 		(*rulenum)  ;
 
 		if (unconditional(s) &&
 		    strcmp(t >target.u.kernel.target >name,
 			   XT_STANDARD_TARGET) == 0 &&
 		   t >verdict < 0) {
 			/* Tail of chains: STANDARD target (return/policy) */
 			*comment = *chainname == hookname
 				? comments[NF_IP_TRACE_COMMENT_POLICY]
 			e >comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));
 
 			/* Unconditional return/END. */
 			if ((unconditional(e) &&
 			     (strcmp(t >target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
 			     t >verdict < 0) || visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t >target.u.user.name,
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
 	if (!unconditional(e))
 		return false;
 	t = ipt_get_target_c(e);
 	if (strcmp(t >u.user.name, XT_STANDARD_TARGET) != 0)
 			newinfo >hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e   base == underflows[h]) {
 			if (!check_underflow(e)) {
 				pr_debug("Underflows must be unconditional and "
 					 "use the STANDARD target with "
 					 "ACCEPT/DROP\n");
 				return  EINVAL;
 			}
 			newinfo >underflow[h] = underflows[h];
 
 /* All zeroes == unconditional rule. */
 /* Mildly perf critical (only if packet tracing is on) */
 static inline bool unconditional(const struct ip6t_entry *e)
 {
 	static const struct ip6t_ip6 uncond;
 
 	return e >target_offset == sizeof(struct ip6t_entry) &&
 	       memcmp(&e >ipv6, &uncond, sizeof(uncond)) == 0;
 }
 
 static inline const struct xt_entry_target *
 	} else if (s == e) {
 		(*rulenum)  ;
 
 		if (unconditional(s) &&
 		    strcmp(t >target.u.kernel.target >name,
 			   XT_STANDARD_TARGET) == 0 &&
 		    t >verdict < 0) {
 			/* Tail of chains: STANDARD target (return/policy) */
 			*comment = *chainname == hookname
 				? comments[NF_IP6_TRACE_COMMENT_POLICY]
 			e >comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));
 
 			/* Unconditional return/END. */
 			if ((unconditional(e) &&
 			     (strcmp(t >target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
 			     t >verdict < 0) || visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t >target.u.user.name,
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
 	if (!unconditional(e))
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t >u.user.name, XT_STANDARD_TARGET) != 0)
 			newinfo >hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e   base == underflows[h]) {
 			if (!check_underflow(e)) {
 				pr_debug("Underflows must be unconditional and "
 					 "use the STANDARD target with "
 					 "ACCEPT/DROP\n");
 				return  EINVAL;
 			}
 			newinfo >underflow[h] = underflows[h];
