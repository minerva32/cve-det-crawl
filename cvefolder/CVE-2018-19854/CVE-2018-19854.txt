CVE Number : CVE-2018-19854
Commit Message : 
crypto: user - fix leaking uninitialized memory to userspace
Commit Details : 
All bytes of the NETLINK_CRYPTO report structures must be initialized,
since they are copied to userspace.  The change from strncpy() to
strlcpy() broke this.  As a minimal fix, change it back.

Fixes: 4473710df1f8 ("crypto: user - Prepare for CRYPTO_MAX_ALG_NAME expansion")
Cc: <stable@vger.kernel.org> # v4.12+
Signed-off-by: Eric Biggers <ebiggers@google.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

Before patch : 
 {
 	struct crypto_report_cipher rcipher;
 
 	strlcpy(rcipher.type, "cipher", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg >cra_blocksize;
 	rcipher.min_keysize = alg >cra_cipher.cia_min_keysize;
 {
 	struct crypto_report_comp rcomp;
 
 	strlcpy(rcomp.type, "compression", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
 {
 	struct crypto_report_acomp racomp;
 
 	strlcpy(racomp.type, "acomp", sizeof(racomp.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,
 		    sizeof(struct crypto_report_acomp), &racomp))
 {
 	struct crypto_report_akcipher rakcipher;
 
 	strlcpy(rakcipher.type, "akcipher", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
 {
 	struct crypto_report_kpp rkpp;
 
 	strlcpy(rkpp.type, "kpp", sizeof(rkpp.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
 		    sizeof(struct crypto_report_kpp), &rkpp))
 static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
 	strlcpy(ualg >cru_name, alg >cra_name, sizeof(ualg >cru_name));
 	strlcpy(ualg >cru_driver_name, alg >cra_driver_name,
 		sizeof(ualg >cru_driver_name));
 	strlcpy(ualg >cru_module_name, module_name(alg >cra_module),
 		sizeof(ualg >cru_module_name));
 
 	ualg >cru_type = 0;
 	if (alg >cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
 		strlcpy(rl.type, "larval", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;
After patch : 
 {
 	struct crypto_report_cipher rcipher;
 
 	strncpy(rcipher.type, "cipher", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg >cra_blocksize;
 	rcipher.min_keysize = alg >cra_cipher.cia_min_keysize;
 {
 	struct crypto_report_comp rcomp;
 
 	strncpy(rcomp.type, "compression", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
 {
 	struct crypto_report_acomp racomp;
 
 	strncpy(racomp.type, "acomp", sizeof(racomp.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,
 		    sizeof(struct crypto_report_acomp), &racomp))
 {
 	struct crypto_report_akcipher rakcipher;
 
 	strncpy(rakcipher.type, "akcipher", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
 {
 	struct crypto_report_kpp rkpp;
 
 	strncpy(rkpp.type, "kpp", sizeof(rkpp.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
 		    sizeof(struct crypto_report_kpp), &rkpp))
 static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
 	strncpy(ualg >cru_name, alg >cra_name, sizeof(ualg >cru_name));
 	strncpy(ualg >cru_driver_name, alg >cra_driver_name,
 		sizeof(ualg >cru_driver_name));
 	strncpy(ualg >cru_module_name, module_name(alg >cra_module),
 		sizeof(ualg >cru_module_name));
 
 	ualg >cru_type = 0;
 	if (alg >cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
 		strncpy(rl.type, "larval", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;
