CVE Number : CVE-2013-4588
Commit Message : 
ipvs: Add boundary check on ioctl arguments
Commit Details : 
The ipvs code has a nifty system for doing the size of ioctl command
copies; it defines an array with values into which it indexes the cmd
to find the right length.

Unfortunately, the ipvs code forgot to check if the cmd was in the
range that the array provides, allowing for an index outside of the
array, which then gives a "garbage" result into the length, which
then gets used for copying into a stack buffer.

Fix this by adding sanity checks on these as well as the copy size.

 horms@verge.net.au: adjusted limit to IP_VS_SO_GET_MAX 
Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
Acked-by: Julian Anastasov <ja@ssi.bg>
Signed-off-by: Simon Horman <horms@verge.net.au>
Signed-off-by: Patrick McHardy <kaber@trash.net>

Before patch : 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (len != set_arglen[SET_CMDID(cmd)]) {
 		pr_err("set_ctl: len %u != %u\n",
 		       len, set_arglen[SET_CMDID(cmd)]);
 {
 	unsigned char arg[128];
 	int ret = 0;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (*len < get_arglen[GET_CMDID(cmd)]) {
 		pr_err("get_ctl: len %u < %u\n",
 		       *len, get_arglen[GET_CMDID(cmd)]);
 		return  EINVAL;
 	}
 
 	if (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)
 		return  EFAULT;
 
 	if (mutex_lock_interruptible(&__ip_vs_mutex))
After patch : 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)
 		return  EINVAL;
 	if (len < 0 || len >  MAX_ARG_LEN)
 		return  EINVAL;
 	if (len != set_arglen[SET_CMDID(cmd)]) {
 		pr_err("set_ctl: len %u != %u\n",
 		       len, set_arglen[SET_CMDID(cmd)]);
 {
 	unsigned char arg[128];
 	int ret = 0;
 	unsigned int copylen;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)
 		return  EINVAL;
 
 	if (*len < get_arglen[GET_CMDID(cmd)]) {
 		pr_err("get_ctl: len %u < %u\n",
 		       *len, get_arglen[GET_CMDID(cmd)]);
 		return  EINVAL;
 	}
 
 	copylen = get_arglen[GET_CMDID(cmd)];
 	if (copylen > 128)
 		return  EINVAL;
 
 	if (copy_from_user(arg, user, copylen) != 0)
 		return  EFAULT;
 
 	if (mutex_lock_interruptible(&__ip_vs_mutex))
