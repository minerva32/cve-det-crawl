CVE Number : CVE-2021-3732
Commit Message : 
ovl: prevent private clone if bind mount is not allowed
Commit Details : 
Add the following checks from __do_loopback() to clone_private_mount() as
well:

 - verify that the mount is in the current namespace

 - verify that there are no locked children

Reported-by: Alois Wohlschlager <alois1@gmx-topmail.de>
Fixes: c771d683a62e ("vfs: introduce clone_private_mount()")
Cc: <stable@vger.kernel.org> # v3.18
Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

Before patch : 
 	namespace_unlock();
 }
 
 /**
  * clone_private_mount   create a private clone of a path
  * @path: path to clone
 	struct mount *old_mnt = real_mount(path >mnt);
 	struct mount *new_mnt;
 
 	if (IS_MNT_UNBINDABLE(old_mnt))
 		return ERR_PTR( EINVAL);
 
 	new_mnt = clone_mnt(old_mnt, path >dentry, CL_PRIVATE);
 	if (IS_ERR(new_mnt))
 		return ERR_CAST(new_mnt);
 
 	new_mnt >mnt_ns = MNT_NS_INTERNAL;
 
 	return &new_mnt >mnt;
 }
 EXPORT_SYMBOL_GPL(clone_private_mount);
 
 	return err;
 }
 
 static bool has_locked_children(struct mount *mnt, struct dentry *dentry)
 {
 	struct mount *child;
 	list_for_each_entry(child, &mnt >mnt_mounts, mnt_child) {
 		if (!is_subdir(child >mnt_mountpoint, dentry))
 			continue;
 
 		if (child >mnt.mnt_flags & MNT_LOCKED)
 			return true;
 	}
 	return false;
 }
 
 static struct mount *__do_loopback(struct path *old_path, int recurse)
 {
 	struct mount *mnt = ERR_PTR( EINVAL), *old = real_mount(old_path >mnt);
After patch : 
 	namespace_unlock();
 }
 
 static bool has_locked_children(struct mount *mnt, struct dentry *dentry)
 {
 	struct mount *child;
 
 	list_for_each_entry(child, &mnt >mnt_mounts, mnt_child) {
 		if (!is_subdir(child >mnt_mountpoint, dentry))
 			continue;
 
 		if (child >mnt.mnt_flags & MNT_LOCKED)
 			return true;
 	}
 	return false;
 }
 
 /**
  * clone_private_mount   create a private clone of a path
  * @path: path to clone
 	struct mount *old_mnt = real_mount(path >mnt);
 	struct mount *new_mnt;
 
 	down_read(&namespace_sem);
 	if (IS_MNT_UNBINDABLE(old_mnt))
 		goto invalid;
 
 	if (!check_mnt(old_mnt))
 		goto invalid;
 
 	if (has_locked_children(old_mnt, path >dentry))
 		goto invalid;
 
 	new_mnt = clone_mnt(old_mnt, path >dentry, CL_PRIVATE);
 	up_read(&namespace_sem);
 
 	if (IS_ERR(new_mnt))
 		return ERR_CAST(new_mnt);
 
 	new_mnt >mnt_ns = MNT_NS_INTERNAL;
 
 	return &new_mnt >mnt;
 
 invalid:
 	up_read(&namespace_sem);
 	return ERR_PTR( EINVAL);
 }
 EXPORT_SYMBOL_GPL(clone_private_mount);
 
 	return err;
 }
 
 static struct mount *__do_loopback(struct path *old_path, int recurse)
 {
 	struct mount *mnt = ERR_PTR( EINVAL), *old = real_mount(old_path >mnt);
