CVE Number : CVE-2011-2689
Commit Message : 
GFS2: make sure fallocate bytes is a multiple of blksize
Commit Details : 
The GFS2 fallocate code chooses a target size to for allocating chunks of
space.  Whenever it can't find any resource groups with enough space free, it
halves its target. Since this target is in bytes, eventually it will no longer
be a multiple of blksize.  As long as there is more space available in the
resource group than the target, this isn't a problem, since gfs2 will use the
actual space available, which is always a multiple of blksize.  However,
when gfs couldn't fallocate a bigger chunk than the target, it was using the
non-blksize aligned number. This caused a BUG in later code that required
blksize aligned offsets.  GFS2 now ensures that bytes is always a multiple of
blksize

Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

Before patch : 
 	loff_t bytes, max_bytes;
 	struct gfs2_alloc *al;
 	int error;
 	loff_t next = (offset   len   1) >> sdp >sd_sb.sb_bsize_shift;
 	next = (next   1) << sdp >sd_sb.sb_bsize_shift;
 
 	if (mode & ~FALLOC_FL_KEEP_SIZE)
 		return  EOPNOTSUPP;
 
 	offset = (offset >> sdp >sd_sb.sb_bsize_shift) <<
 		 sdp >sd_sb.sb_bsize_shift;
 
 	len = next   offset;
 	bytes = sdp >sd_max_rg_data * sdp >sd_sb.sb_bsize / 2;
 	if (!bytes)
 		bytes = UINT_MAX;
 
 	gfs2_holder_init(ip >i_gl, LM_ST_EXCLUSIVE, 0, &ip >i_gh);
 	error = gfs2_glock_nq(&ip >i_gh);
 		if (error) {
 			if (error ==  ENOSPC && bytes > sdp >sd_sb.sb_bsize) {
 				bytes >>= 1;
 				goto retry;
 			}
 			goto out_qunlock;
After patch : 
 	loff_t bytes, max_bytes;
 	struct gfs2_alloc *al;
 	int error;
 	loff_t bsize_mask = ~((loff_t)sdp >sd_sb.sb_bsize   1);
 	loff_t next = (offset   len   1) >> sdp >sd_sb.sb_bsize_shift;
 	next = (next   1) << sdp >sd_sb.sb_bsize_shift;
 
 	if (mode & ~FALLOC_FL_KEEP_SIZE)
 		return  EOPNOTSUPP;
 
 	offset &= bsize_mask;
 
 	len = next   offset;
 	bytes = sdp >sd_max_rg_data * sdp >sd_sb.sb_bsize / 2;
 	if (!bytes)
 		bytes = UINT_MAX;
 	bytes &= bsize_mask;
 	if (bytes == 0)
 		bytes = sdp >sd_sb.sb_bsize;
 
 	gfs2_holder_init(ip >i_gl, LM_ST_EXCLUSIVE, 0, &ip >i_gh);
 	error = gfs2_glock_nq(&ip >i_gh);
 		if (error) {
 			if (error ==  ENOSPC && bytes > sdp >sd_sb.sb_bsize) {
 				bytes >>= 1;
 				bytes &= bsize_mask;
 				if (bytes == 0)
 					bytes = sdp >sd_sb.sb_bsize;
 				goto retry;
 			}
 			goto out_qunlock;
