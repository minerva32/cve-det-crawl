CVE Number : CVE-2018-1066
Commit Message : 
CIFS: Enable encryption during session setup phase
Commit Details : 
In order to allow encryption on SMB connection we need to exchange
a session key and generate encryption and decryption keys.

Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>

Before patch : 
 	/* BB is NTLMV2 session security format easier to use here? */
 	flags = NTLMSSP_NEGOTIATE_56 |	NTLMSSP_REQUEST_TARGET |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
 		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
 	if (ses >server >sign) {
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
 		if (!ses >server >session_estab ||
 				ses >ntlmssp >sesskey_per_smbsess)
 			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 	}
 
 	sec_blob >NegotiateFlags = cpu_to_le32(flags);
 
 	flags = NTLMSSP_NEGOTIATE_56 |
 		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
 		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;
 	if (ses >server >sign) {
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
 		if (!ses >server >session_estab ||
 				ses >ntlmssp >sesskey_per_smbsess)
 			flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 	}
 
 	tmp = *pbuffer   sizeof(AUTHENTICATE_MESSAGE);
 	sec_blob >NegotiateFlags = cpu_to_le32(flags);
 	struct cifs_ses *ses = sess_data >ses;
 
 	mutex_lock(&ses >server >srv_mutex);
 	if (ses >server >sign && ses >server >ops >generate_signingkey) {
 		rc = ses >server >ops >generate_signingkey(ses);
 		kfree(ses >auth_key.response);
 		ses >auth_key.response = NULL;
 		if (rc) {
 			cifs_dbg(FYI,
 				"SMB3 session key generation failed\n");
 			mutex_unlock(&ses >server >srv_mutex);
 			goto keygen_exit;
 		}
 	}
 	if (!ses >server >session_estab) {
 	ses >status = CifsGood;
 	ses >need_reconnect = false;
 	spin_unlock(&GlobalMid_Lock);
 
 keygen_exit:
 	if (!ses >server >sign) {
 		kfree(ses >auth_key.response);
 		ses >auth_key.response = NULL;
 	}
 	return rc;
 }
 
After patch : 
 	/* BB is NTLMV2 session security format easier to use here? */
 	flags = NTLMSSP_NEGOTIATE_56 |	NTLMSSP_REQUEST_TARGET |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
 		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
 		NTLMSSP_NEGOTIATE_SEAL;
 	if (ses >server >sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
 	if (!ses >server >session_estab || ses >ntlmssp >sesskey_per_smbsess)
 		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	sec_blob >NegotiateFlags = cpu_to_le32(flags);
 
 	flags = NTLMSSP_NEGOTIATE_56 |
 		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
 		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
 		NTLMSSP_NEGOTIATE_SEAL;
 	if (ses >server >sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
 	if (!ses >server >session_estab || ses >ntlmssp >sesskey_per_smbsess)
 		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	tmp = *pbuffer   sizeof(AUTHENTICATE_MESSAGE);
 	sec_blob >NegotiateFlags = cpu_to_le32(flags);
 	struct cifs_ses *ses = sess_data >ses;
 
 	mutex_lock(&ses >server >srv_mutex);
 	if (ses >server >ops >generate_signingkey) {
 		rc = ses >server >ops >generate_signingkey(ses);
 		if (rc) {
 			cifs_dbg(FYI,
 				"SMB3 session key generation failed\n");
 			mutex_unlock(&ses >server >srv_mutex);
 			return rc;
 		}
 	}
 	if (!ses >server >session_estab) {
 	ses >status = CifsGood;
 	ses >need_reconnect = false;
 	spin_unlock(&GlobalMid_Lock);
 	return rc;
 }
 
