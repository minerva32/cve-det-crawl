CVE Number : CVE-2009-3726
Commit Message : 
NFSv4: Fix a problem whereby a buggy server can oops the kernel
Commit Details : 
We just had a case in which a buggy server occasionally returns the wrong
attributes during an OPEN call. While the client does catch this sort of
condition in nfs4_open_done(), and causes the nfs4_atomic_open() to return
-EISDIR, the logic in nfs_atomic_lookup() is broken, since it causes a
fallback to an ordinary lookup instead of just returning the error.

When the buggy server then returns a regular file for the fallback lookup,
the VFS allows the open, and bad things start to happen, since the open
file doesn't have any associated NFSv4 state.

The fix is firstly to return the EISDIR/ENOTDIR errors immediately, and
secondly to ensure that we are always careful when dereferencing the
nfs_open_context state pointer.

Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

Before patch : 
 				res = NULL;
 				goto out;
 			/* This turned out not to be a regular file */
 			case  EISDIR:
 			case  ENOTDIR:
 				goto no_open;
 			case  ELOOP:
 				if (!(nd >intent.open.flags & O_NOFOLLOW))
 					goto no_open;
 			/* case  EINVAL: */
 			default:
 				goto out;
 	if (request >fl_start < 0 || request >fl_end < 0)
 		return  EINVAL;
 
 	if (IS_GETLK(cmd))
 		return nfs4_proc_getlk(state, F_GETLK, request);
 
 	if (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))
 		return  EINVAL;
 
 	if (request >fl_type == F_UNLCK)
 		return nfs4_proc_unlck(state, cmd, request);
 
 	do {
 		status = nfs4_proc_setlk(state, cmd, request);
 		if ((status !=  EAGAIN) || IS_SETLK(cmd))
After patch : 
 				res = NULL;
 				goto out;
 			/* This turned out not to be a regular file */
 			case  ENOTDIR:
 				goto no_open;
 			case  ELOOP:
 				if (!(nd >intent.open.flags & O_NOFOLLOW))
 					goto no_open;
 			/* case  EISDIR: */
 			/* case  EINVAL: */
 			default:
 				goto out;
 	if (request >fl_start < 0 || request >fl_end < 0)
 		return  EINVAL;
 
 	if (IS_GETLK(cmd)) {
 		if (state != NULL)
 			return nfs4_proc_getlk(state, F_GETLK, request);
 		return 0;
 	}
 
 	if (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))
 		return  EINVAL;
 
 	if (request >fl_type == F_UNLCK) {
 		if (state != NULL)
 			return nfs4_proc_unlck(state, cmd, request);
 		return 0;
 	}
 
 	if (state == NULL)
 		return  ENOLCK;
 	do {
 		status = nfs4_proc_setlk(state, cmd, request);
 		if ((status !=  EAGAIN) || IS_SETLK(cmd))
