CVE Number : CVE-2013-4127
Commit Message : 
vhost-net: fix use-after-free in vhost_net_flush
Commit Details : 
vhost_net_ubuf_put_and_wait has a confusing name:
it will actually also free it's argument.
Thus since commit 1280c27f8e29acf4af2da914e80ec27c3dbd5c01
    "vhost-net: flush outstanding DMAs on memory change"
vhost_net_flush tries to use the argument after passing it
to vhost_net_ubuf_put_and_wait, this results
in use after free.
To fix, don't free the argument in vhost_net_ubuf_put_and_wait,
add an new API for callers that want to free ubufs.

Acked-by: Asias He <asias@redhat.com>
Acked-by: Jason Wang <jasowang@redhat.com>
Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 {
 	kref_put(&ubufs >kref, vhost_net_zerocopy_done_signal);
 	wait_event(ubufs >wait, !atomic_read(&ubufs >kref.refcount));
 	kfree(ubufs);
 }
 
 	mutex_unlock(&vq >mutex);
 
 	if (oldubufs) {
 		vhost_net_ubuf_put_and_wait(oldubufs);
 		mutex_lock(&vq >mutex);
 		vhost_zerocopy_signal_used(n, vq);
 		mutex_unlock(&vq >mutex);
 	rcu_assign_pointer(vq >private_data, oldsock);
 	vhost_net_enable_vq(n, vq);
 	if (ubufs)
 		vhost_net_ubuf_put_and_wait(ubufs);
 err_ubufs:
 	fput(sock >file);
 err_vq:
After patch : 
 {
 	kref_put(&ubufs >kref, vhost_net_zerocopy_done_signal);
 	wait_event(ubufs >wait, !atomic_read(&ubufs >kref.refcount));
 }
 
 static void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)
 {
 	vhost_net_ubuf_put_and_wait(ubufs);
 	kfree(ubufs);
 }
 
 	mutex_unlock(&vq >mutex);
 
 	if (oldubufs) {
 		vhost_net_ubuf_put_wait_and_free(oldubufs);
 		mutex_lock(&vq >mutex);
 		vhost_zerocopy_signal_used(n, vq);
 		mutex_unlock(&vq >mutex);
 	rcu_assign_pointer(vq >private_data, oldsock);
 	vhost_net_enable_vq(n, vq);
 	if (ubufs)
 		vhost_net_ubuf_put_wait_and_free(ubufs);
 err_ubufs:
 	fput(sock >file);
 err_vq:
