CVE Number : CVE-2018-14656
Commit Message : 
x86/dumpstack: Don't dump kernel memory based on usermode RIP
Commit Details : 
show_opcodes() is used both for dumping kernel instructions and for dumping
user instructions. If userspace causes #PF by jumping to a kernel address,
show_opcodes() can be reached with regs->ip controlled by the user,
pointing to kernel code. Make sure that userspace can't trick us into
dumping kernel memory into dmesg.

Fixes: 7cccf0725cf7 ("x86/dumpstack: Add a show_ip() function")
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: Borislav Petkov <bp@suse.de>
Cc: "H. Peter Anvin" <hpa@zytor.com>
Cc: Andy Lutomirski <luto@kernel.org>
Cc: security@kernel.org
Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/r/20180828154901.112726-1-jannh@google.com

Before patch : 
 	return (unsigned long)frame;
 }
 
 void show_opcodes(u8 *rip, const char *loglvl);
 void show_ip(struct pt_regs *regs, const char *loglvl);
 #endif /* _ASM_X86_STACKTRACE_H */
  * Thus, the 2/3rds prologue and 64 byte OPCODE_BUFSIZE is just a random
  * guesstimate in attempt to achieve all of the above.
  */
 void show_opcodes(u8 *rip, const char *loglvl)
 {
 #define PROLOGUE_SIZE 42
 #define EPILOGUE_SIZE 21
 #define OPCODE_BUFSIZE (PROLOGUE_SIZE   1   EPILOGUE_SIZE)
 	u8 opcodes[OPCODE_BUFSIZE];
 
 	if (probe_kernel_read(opcodes, rip   PROLOGUE_SIZE, OPCODE_BUFSIZE)) {
 		printk("%sCode: Bad RIP value.\n", loglvl);
 	} else {
 		printk("%sCode: %" __stringify(PROLOGUE_SIZE) "ph <%02x> %"
 #else
 	printk("%sRIP: %04x:%pS\n", loglvl, (int)regs >cs, (void *)regs >ip);
 #endif
 	show_opcodes((u8 *)regs >ip, loglvl);
 }
 
 void show_iret_regs(struct pt_regs *regs)
 
 	printk(KERN_CONT "\n");
 
 	show_opcodes((u8 *)regs >ip, loglvl);
 }
 
 static void
After patch : 
 	return (unsigned long)frame;
 }
 
 void show_opcodes(struct pt_regs *regs, const char *loglvl);
 void show_ip(struct pt_regs *regs, const char *loglvl);
 #endif /* _ASM_X86_STACKTRACE_H */
  * Thus, the 2/3rds prologue and 64 byte OPCODE_BUFSIZE is just a random
  * guesstimate in attempt to achieve all of the above.
  */
 void show_opcodes(struct pt_regs *regs, const char *loglvl)
 {
 #define PROLOGUE_SIZE 42
 #define EPILOGUE_SIZE 21
 #define OPCODE_BUFSIZE (PROLOGUE_SIZE   1   EPILOGUE_SIZE)
 	u8 opcodes[OPCODE_BUFSIZE];
 	unsigned long prologue = regs >ip   PROLOGUE_SIZE;
 	bool bad_ip;
 
 	/*
 	 * Make sure userspace isn't trying to trick us into dumping kernel
 	 * memory by pointing the userspace instruction pointer at it.
 	 */
 	bad_ip = user_mode(regs) &&
 		__chk_range_not_ok(prologue, OPCODE_BUFSIZE, TASK_SIZE_MAX);
 
 	if (bad_ip || probe_kernel_read(opcodes, (u8 *)prologue,
 					OPCODE_BUFSIZE)) {
 		printk("%sCode: Bad RIP value.\n", loglvl);
 	} else {
 		printk("%sCode: %" __stringify(PROLOGUE_SIZE) "ph <%02x> %"
 #else
 	printk("%sRIP: %04x:%pS\n", loglvl, (int)regs >cs, (void *)regs >ip);
 #endif
 	show_opcodes(regs, loglvl);
 }
 
 void show_iret_regs(struct pt_regs *regs)
 
 	printk(KERN_CONT "\n");
 
 	show_opcodes(regs, loglvl);
 }
 
 static void
