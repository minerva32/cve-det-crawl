CVE Number : CVE-2016-8645
Commit Message : 
tcp: take care of truncations done by sk_filter()
Commit Details : 
With syzkaller help, Marco Grassi found a bug in TCP stack,
crashing in tcp_collapse()

Root cause is that sk_filter() can truncate the incoming skb,
but TCP stack was not really expecting this to happen.
It probably was expecting a simple DROP or ACCEPT behavior.

We first need to make sure no part of TCP header could be removed.
Then we need to adjust TCP_SKB_CB(skb)->end_seq

Many thanks to syzkaller team and Marco for giving us a reproducer.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Marco Grassi <marco.gra@gmail.com>
Reported-by: Vladis Dronov <vdronov@redhat.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);
 bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);
 
 #undef STATE_TRACE
 
 }
 EXPORT_SYMBOL(tcp_add_backlog);
 
 /*
  *	From tcp_input.c
  */
 
 	nf_reset(skb);
 
 	if (sk_filter(sk, skb))
 		goto discard_and_relse;
 
 	skb >dev = NULL;
 
 	if (skb >protocol == htons(ETH_P_IP))
 		return tcp_v4_do_rcv(sk, skb);
 
 	if (sk_filter(sk, skb))
 		goto discard;
 
 	/*
 	if (tcp_v6_inbound_md5_hash(sk, skb))
 		goto discard_and_relse;
 
 	if (sk_filter(sk, skb))
 		goto discard_and_relse;
 
 	skb >dev = NULL;
 
After patch : 
 
 bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);
 bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);
 int tcp_filter(struct sock *sk, struct sk_buff *skb);
 
 #undef STATE_TRACE
 
 }
 EXPORT_SYMBOL(tcp_add_backlog);
 
 int tcp_filter(struct sock *sk, struct sk_buff *skb)
 {
 	struct tcphdr *th = (struct tcphdr *)skb >data;
 	unsigned int eaten = skb >len;
 	int err;
 
 	err = sk_filter_trim_cap(sk, skb, th >doff * 4);
 	if (!err) {
 		eaten  = skb >len;
 		TCP_SKB_CB(skb) >end_seq  = eaten;
 	}
 	return err;
 }
 EXPORT_SYMBOL(tcp_filter);
 
 /*
  *	From tcp_input.c
  */
 
 	nf_reset(skb);
 
 	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
 	th = (const struct tcphdr *)skb >data;
 	iph = ip_hdr(skb);
 
 	skb >dev = NULL;
 
 	if (skb >protocol == htons(ETH_P_IP))
 		return tcp_v4_do_rcv(sk, skb);
 
 	if (tcp_filter(sk, skb))
 		goto discard;
 
 	/*
 	if (tcp_v6_inbound_md5_hash(sk, skb))
 		goto discard_and_relse;
 
 	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
 	th = (const struct tcphdr *)skb >data;
 	hdr = ipv6_hdr(skb);
 
 	skb >dev = NULL;
 
