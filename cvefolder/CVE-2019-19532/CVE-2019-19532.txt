CVE Number : CVE-2019-19532
Commit Message : 
HID: Fix assumption that devices have inputs
Commit Details : 
The syzbot fuzzer found a slab-out-of-bounds write bug in the hid-gaff
driver.  The problem is caused by the driver's assumption that the
device must have an input report.  While this will be true for all
normal HID input devices, a suitably malicious device can violate the
assumption.

The same assumption is present in over a dozen other HID drivers.
This patch fixes them by checking that the list of hid_inputs for the
hid_device is nonempty before allowing it to be used.

Reported-and-tested-by: syzbot+403741a091bf41d4ae79@syzkaller.appspotmail.com
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
CC: <stable@vger.kernel.org>
Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>

Before patch : 
 {
 	struct axff_device *axff;
 	struct hid_report *report;
 	struct hid_input *hidinput = list_first_entry(&hid >inputs, struct hid_input, list);
 	struct list_head *report_list =&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct input_dev *dev = hidinput >input;
 	int field_count = 0;
 	int i, j;
 	int error;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return  ENODEV;
 {
 	struct drff_device *drff;
 	struct hid_report *report;
 	struct hid_input *hidinput = list_first_entry(&hid >inputs,
 						struct hid_input, list);
 	struct list_head *report_list =
 			&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct input_dev *dev = hidinput >input;
 	int error;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return  ENODEV;
 {
 	struct emsff_device *emsff;
 	struct hid_report *report;
 	struct hid_input *hidinput = list_first_entry(&hid >inputs,
 						struct hid_input, list);
 	struct list_head *report_list =
 			&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct input_dev *dev = hidinput >input;
 	int error;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return  ENODEV;
 {
 	struct gaff_device *gaff;
 	struct hid_report *report;
 	struct hid_input *hidinput = list_entry(hid >inputs.next,
 						struct hid_input, list);
 	struct list_head *report_list =
 			&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct list_head *report_ptr = report_list;
 	struct input_dev *dev = hidinput >input;
 	int error;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return  ENODEV;
 {
 	struct holtekff_device *holtekff;
 	struct hid_report *report;
 	struct hid_input *hidinput = list_entry(hid >inputs.next,
 						struct hid_input, list);
 	struct list_head *report_list =
 			&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct input_dev *dev = hidinput >input;
 	int error;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output report found\n");
 		return  ENODEV;
 {
 	struct lg2ff_device *lg2ff;
 	struct hid_report *report;
 	struct hid_input *hidinput = list_entry(hid >inputs.next,
 						struct hid_input, list);
 	struct input_dev *dev = hidinput >input;
 	int error;
 
 	/* Check that the report looks ok */
 	report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);
 	if (!report)
 
 int lg3ff_init(struct hid_device *hid)
 {
 	struct hid_input *hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	struct input_dev *dev = hidinput >input;
 	const signed short *ff_bits = ff3_joystick_ac;
 	int error;
 	int i;
 
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 35))
 		return  ENODEV;
 
 int lg4ff_init(struct hid_device *hid)
 {
 	struct hid_input *hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	struct input_dev *dev = hidinput >input;
 	struct list_head *report_list = &hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct hid_report *report = list_entry(report_list >next, struct hid_report, list);
 	const struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid) >descriptor);
 	int mmode_ret, mmode_idx =  1;
 	u16 real_product_id;
 
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
 		return  1;
 
 int lgff_init(struct hid_device* hid)
 {
 	struct hid_input *hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	struct input_dev *dev = hidinput >input;
 	const signed short *ff_bits = ff_joystick;
 	int error;
 	int i;
 
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
 		return  ENODEV;
 static int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)
 {
 	struct hid_device *hid = hidpp >hid_dev;
 	struct hid_input *hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	struct input_dev *dev = hidinput >input;
 	const struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid) >descriptor);
 	const u16 bcdDevice = le16_to_cpu(udesc >bcdDevice);
 	struct ff_device *ff;
 	int error, j, num_slots;
 	u8 version;
 
 	if (!dev) {
 		hid_err(hid, "Struct input_dev not set!\n");
 		return  EINVAL;
 
 static int ms_init_ff(struct hid_device *hdev)
 {
 	struct hid_input *hidinput = list_entry(hdev >inputs.next,
 						struct hid_input, list);
 	struct input_dev *input_dev = hidinput >input;
 	struct ms_data *ms = hid_get_drvdata(hdev);
 
 	if (!(ms >quirks & MS_QUIRK_FF))
 		return 0;
 
 
 static int sony_init_ff(struct sony_sc *sc)
 {
 	struct hid_input *hidinput = list_entry(sc >hdev >inputs.next,
 						struct hid_input, list);
 	struct input_dev *input_dev = hidinput >input;
 
 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
 	struct tmff_device *tmff;
 	struct hid_report *report;
 	struct list_head *report_list;
 	struct hid_input *hidinput = list_entry(hid >inputs.next,
 							struct hid_input, list);
 	struct input_dev *input_dev = hidinput >input;
 	int error;
 	int i;
 
 	tmff = kzalloc(sizeof(struct tmff_device), GFP_KERNEL);
 	if (!tmff)
 		return  ENOMEM;
 {
 	struct zpff_device *zpff;
 	struct hid_report *report;
 	struct hid_input *hidinput = list_entry(hid >inputs.next,
 						struct hid_input, list);
 	struct input_dev *dev = hidinput >input;
 	int i, error;
 
 	for (i = 0; i < 4; i  ) {
 		report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);
 		if (!report)
After patch : 
 {
 	struct axff_device *axff;
 	struct hid_report *report;
 	struct hid_input *hidinput;
 	struct list_head *report_list =&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct input_dev *dev;
 	int field_count = 0;
 	int i, j;
 	int error;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_first_entry(&hid >inputs, struct hid_input, list);
 	dev = hidinput >input;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return  ENODEV;
 {
 	struct drff_device *drff;
 	struct hid_report *report;
 	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct input_dev *dev;
 	int error;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_first_entry(&hid >inputs, struct hid_input, list);
 	dev = hidinput >input;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return  ENODEV;
 {
 	struct emsff_device *emsff;
 	struct hid_report *report;
 	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct input_dev *dev;
 	int error;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_first_entry(&hid >inputs, struct hid_input, list);
 	dev = hidinput >input;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return  ENODEV;
 {
 	struct gaff_device *gaff;
 	struct hid_report *report;
 	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct list_head *report_ptr = report_list;
 	struct input_dev *dev;
 	int error;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	dev = hidinput >input;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return  ENODEV;
 {
 	struct holtekff_device *holtekff;
 	struct hid_report *report;
 	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct input_dev *dev;
 	int error;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	dev = hidinput >input;
 
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output report found\n");
 		return  ENODEV;
 {
 	struct lg2ff_device *lg2ff;
 	struct hid_report *report;
 	struct hid_input *hidinput;
 	struct input_dev *dev;
 	int error;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	dev = hidinput >input;
 
 	/* Check that the report looks ok */
 	report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);
 	if (!report)
 
 int lg3ff_init(struct hid_device *hid)
 {
 	struct hid_input *hidinput;
 	struct input_dev *dev;
 	const signed short *ff_bits = ff3_joystick_ac;
 	int error;
 	int i;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	dev = hidinput >input;
 
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 35))
 		return  ENODEV;
 
 int lg4ff_init(struct hid_device *hid)
 {
 	struct hid_input *hidinput;
 	struct input_dev *dev;
 	struct list_head *report_list = &hid >report_enum[HID_OUTPUT_REPORT].report_list;
 	struct hid_report *report = list_entry(report_list >next, struct hid_report, list);
 	const struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid) >descriptor);
 	int mmode_ret, mmode_idx =  1;
 	u16 real_product_id;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	dev = hidinput >input;
 
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
 		return  1;
 
 int lgff_init(struct hid_device* hid)
 {
 	struct hid_input *hidinput;
 	struct input_dev *dev;
 	const signed short *ff_bits = ff_joystick;
 	int error;
 	int i;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	dev = hidinput >input;
 
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
 		return  ENODEV;
 static int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)
 {
 	struct hid_device *hid = hidpp >hid_dev;
 	struct hid_input *hidinput;
 	struct input_dev *dev;
 	const struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid) >descriptor);
 	const u16 bcdDevice = le16_to_cpu(udesc >bcdDevice);
 	struct ff_device *ff;
 	int error, j, num_slots;
 	u8 version;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	dev = hidinput >input;
 
 	if (!dev) {
 		hid_err(hid, "Struct input_dev not set!\n");
 		return  EINVAL;
 
 static int ms_init_ff(struct hid_device *hdev)
 {
 	struct hid_input *hidinput;
 	struct input_dev *input_dev;
 	struct ms_data *ms = hid_get_drvdata(hdev);
 
 	if (list_empty(&hdev >inputs)) {
 		hid_err(hdev, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hdev >inputs.next, struct hid_input, list);
 	input_dev = hidinput >input;
 
 	if (!(ms >quirks & MS_QUIRK_FF))
 		return 0;
 
 
 static int sony_init_ff(struct sony_sc *sc)
 {
 	struct hid_input *hidinput;
 	struct input_dev *input_dev;
 
 	if (list_empty(&sc >hdev >inputs)) {
 		hid_err(sc >hdev, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(sc >hdev >inputs.next, struct hid_input, list);
 	input_dev = hidinput >input;
 
 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
 	struct tmff_device *tmff;
 	struct hid_report *report;
 	struct list_head *report_list;
 	struct hid_input *hidinput;
 	struct input_dev *input_dev;
 	int error;
 	int i;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	input_dev = hidinput >input;
 
 	tmff = kzalloc(sizeof(struct tmff_device), GFP_KERNEL);
 	if (!tmff)
 		return  ENOMEM;
 {
 	struct zpff_device *zpff;
 	struct hid_report *report;
 	struct hid_input *hidinput;
 	struct input_dev *dev;
 	int i, error;
 
 	if (list_empty(&hid >inputs)) {
 		hid_err(hid, "no inputs found\n");
 		return  ENODEV;
 	}
 	hidinput = list_entry(hid >inputs.next, struct hid_input, list);
 	dev = hidinput >input;
 
 	for (i = 0; i < 4; i  ) {
 		report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);
 		if (!report)
