CVE Number : CVE-2020-25668
Commit Message : 
tty: make FONTX ioctl use the tty pointer they were actually passed
Commit Details : 
Some of the font tty ioctl's always used the current foreground VC for
their operations.  Don't do that then.

This fixes a data race on fg_console.

Side note: both Michael Ellerman and Jiri Slaby point out that all these
ioctls are deprecated, and should probably have been removed long ago,
and everything seems to be using the KDFONTOP ioctl instead.

In fact, Michael points out that it looks like busybox's loadfont
program seems to have switched over to using KDFONTOP exactly _because_
of this bug (ahem.. 12 years ago ;-).

Reported-by: Minh Yuan <yuanmingbuaa@gmail.com>
Acked-by: Michael Ellerman <mpe@ellerman.id.au>
Acked-by: Jiri Slaby <jirislaby@kernel.org>
Cc: Greg KH <greg@kroah.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 	return 0;
 }
 
 static inline int do_fontx_ioctl(int cmd,
 		struct consolefontdesc __user *user_cfd,
 		struct console_font_op *op)
 {
 		op >height = cfdarg.charheight;
 		op >charcount = cfdarg.charcount;
 		op >data = cfdarg.chardata;
 		return con_font_op(vc_cons[fg_console].d, op);
 	case GIO_FONTX: {
 		op >op = KD_FONT_OP_GET;
 		op >flags = KD_FONT_FLAG_OLD;
 		op >width = 8;
 		op >height = cfdarg.charheight;
 		op >charcount = cfdarg.charcount;
 		op >data = cfdarg.chardata;
 		i = con_font_op(vc_cons[fg_console].d, op);
 		if (i)
 			return i;
 		cfdarg.charheight = op >height;
 		if (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))
 			return  EFAULT;
 		return 0;
 		}
 	}
 	return  EINVAL;
 }
 
 static int vt_io_fontreset(struct console_font_op *op)
 {
 	int ret;
 
 
 	op >op = KD_FONT_OP_SET_DEFAULT;
 	op >data = NULL;
 	ret = con_font_op(vc_cons[fg_console].d, op);
 	if (ret)
 		return ret;
 
 	console_lock();
 	con_set_default_unimap(vc_cons[fg_console].d);
 	console_unlock();
 
 	return 0;
 		op.height = 0;
 		op.charcount = 256;
 		op.data = up;
 		return con_font_op(vc_cons[fg_console].d, &op);
 
 	case GIO_FONT:
 		op.op = KD_FONT_OP_GET;
 		op.height = 32;
 		op.charcount = 256;
 		op.data = up;
 		return con_font_op(vc_cons[fg_console].d, &op);
 
 	case PIO_CMAP:
                 if (!perm)
 
 		fallthrough;
 	case GIO_FONTX:
 		return do_fontx_ioctl(cmd, up, &op);
 
 	case PIO_FONTRESET:
 		if (!perm)
 			return  EPERM;
 
 		return vt_io_fontreset(&op);
 
 	case PIO_SCRNMAP:
 		if (!perm)
 };
 
 static inline int
 compat_fontx_ioctl(int cmd, struct compat_consolefontdesc __user *user_cfd,
 			 int perm, struct console_font_op *op)
 {
 	struct compat_consolefontdesc cfdarg;
 	int i;
 		op >height = cfdarg.charheight;
 		op >charcount = cfdarg.charcount;
 		op >data = compat_ptr(cfdarg.chardata);
 		return con_font_op(vc_cons[fg_console].d, op);
 	case GIO_FONTX:
 		op >op = KD_FONT_OP_GET;
 		op >flags = KD_FONT_FLAG_OLD;
 		op >height = cfdarg.charheight;
 		op >charcount = cfdarg.charcount;
 		op >data = compat_ptr(cfdarg.chardata);
 		i = con_font_op(vc_cons[fg_console].d, op);
 		if (i)
 			return i;
 		cfdarg.charheight = op >height;
 	 */
 	case PIO_FONTX:
 	case GIO_FONTX:
 		return compat_fontx_ioctl(cmd, up, perm, &op);
 
 	case KDFONTOP:
 		return compat_kdfontop_ioctl(up, perm, &op, vc);
After patch : 
 	return 0;
 }
 
 static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,
 		struct consolefontdesc __user *user_cfd,
 		struct console_font_op *op)
 {
 		op >height = cfdarg.charheight;
 		op >charcount = cfdarg.charcount;
 		op >data = cfdarg.chardata;
 		return con_font_op(vc, op);
 
 	case GIO_FONTX:
 		op >op = KD_FONT_OP_GET;
 		op >flags = KD_FONT_FLAG_OLD;
 		op >width = 8;
 		op >height = cfdarg.charheight;
 		op >charcount = cfdarg.charcount;
 		op >data = cfdarg.chardata;
 		i = con_font_op(vc, op);
 		if (i)
 			return i;
 		cfdarg.charheight = op >height;
 		if (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))
 			return  EFAULT;
 		return 0;
 	}
 	return  EINVAL;
 }
 
 static int vt_io_fontreset(struct vc_data *vc, struct console_font_op *op)
 {
 	int ret;
 
 
 	op >op = KD_FONT_OP_SET_DEFAULT;
 	op >data = NULL;
 	ret = con_font_op(vc, op);
 	if (ret)
 		return ret;
 
 	console_lock();
 	con_set_default_unimap(vc);
 	console_unlock();
 
 	return 0;
 		op.height = 0;
 		op.charcount = 256;
 		op.data = up;
 		return con_font_op(vc, &op);
 
 	case GIO_FONT:
 		op.op = KD_FONT_OP_GET;
 		op.height = 32;
 		op.charcount = 256;
 		op.data = up;
 		return con_font_op(vc, &op);
 
 	case PIO_CMAP:
                 if (!perm)
 
 		fallthrough;
 	case GIO_FONTX:
 		return do_fontx_ioctl(vc, cmd, up, &op);
 
 	case PIO_FONTRESET:
 		if (!perm)
 			return  EPERM;
 
 		return vt_io_fontreset(vc, &op);
 
 	case PIO_SCRNMAP:
 		if (!perm)
 };
 
 static inline int
 compat_fontx_ioctl(struct vc_data *vc, int cmd,
 		   struct compat_consolefontdesc __user *user_cfd,
 		   int perm, struct console_font_op *op)
 {
 	struct compat_consolefontdesc cfdarg;
 	int i;
 		op >height = cfdarg.charheight;
 		op >charcount = cfdarg.charcount;
 		op >data = compat_ptr(cfdarg.chardata);
 		return con_font_op(vc, op);
 
 	case GIO_FONTX:
 		op >op = KD_FONT_OP_GET;
 		op >flags = KD_FONT_FLAG_OLD;
 		op >height = cfdarg.charheight;
 		op >charcount = cfdarg.charcount;
 		op >data = compat_ptr(cfdarg.chardata);
 		i = con_font_op(vc, op);
 		if (i)
 			return i;
 		cfdarg.charheight = op >height;
 	 */
 	case PIO_FONTX:
 	case GIO_FONTX:
 		return compat_fontx_ioctl(vc, cmd, up, perm, &op);
 
 	case KDFONTOP:
 		return compat_kdfontop_ioctl(up, perm, &op, vc);
