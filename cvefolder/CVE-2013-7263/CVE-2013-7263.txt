CVE Number : CVE-2013-7263
Commit Message : 
inet: prevent leakage of uninitialized memory to user in recv syscalls
Commit Details : 
Only update *addr_len when we actually fill in sockaddr, otherwise we
can return uninitialized memory from the stack to the caller in the
recvfrom, recvmmsg and recvmsg syscalls. Drop the the (addr_len == NULL)
checks because we only get called with a valid addr_len pointer either
from sock_common_recvmsg or inet_recvmsg.

If a blocking read waits on a socket which is concurrently shut down we
now return zero and set msg_msgnamelen to 0.

Reported-by: mpb <mpb.mail@gmail.com>
Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 	if (saddr) {
 		saddr >family = AF_IEEE802154;
 		saddr >addr = mac_cb(skb) >sa;
 	}
 	if (addr_len)
 		*addr_len = sizeof(*saddr);
 
 	if (flags & MSG_TRUNC)
 		copied = skb >len;
 {
 	struct inet_sock *isk = inet_sk(sk);
 	int family = sk >sk_family;
 	struct sockaddr_in *sin;
 	struct sockaddr_in6 *sin6;
 	struct sk_buff *skb;
 	int copied, err;
 
 	if (flags & MSG_OOB)
 		goto out;
 
 	if (addr_len) {
 		if (family == AF_INET)
 			*addr_len = sizeof(*sin);
 		else if (family == AF_INET6 && addr_len)
 			*addr_len = sizeof(*sin6);
 	}
 
 	if (flags & MSG_ERRQUEUE) {
 		if (family == AF_INET) {
 			return ip_recv_error(sk, msg, len);
 
 	/* Copy the address and add cmsg data. */
 	if (family == AF_INET) {
 		sin = (struct sockaddr_in *) msg >msg_name;
 		sin >sin_family = AF_INET;
 		sin >sin_port = 0 /* skb >h.uh >source */;
 		sin >sin_addr.s_addr = ip_hdr(skb) >saddr;
 		memset(sin >sin_zero, 0, sizeof(sin >sin_zero));
 
 		if (isk >cmsg_flags)
 			ip_cmsg_recv(msg, skb);
 	} else if (family == AF_INET6) {
 		struct ipv6_pinfo *np = inet6_sk(sk);
 		struct ipv6hdr *ip6 = ipv6_hdr(skb);
 		sin6 = (struct sockaddr_in6 *) msg >msg_name;
 		sin6 >sin6_family = AF_INET6;
 		sin6 >sin6_port = 0;
 		sin6 >sin6_addr = ip6 >saddr;
 
 		sin6 >sin6_flowinfo = 0;
 		if (np >sndflow)
 			sin6 >sin6_flowinfo = ip6_flowinfo(ip6);
 
 		sin6 >sin6_scope_id = ipv6_iface_scope_id(&sin6 >sin6_addr,
 							  IP6CB(skb) >iif);
 
 		if (inet6_sk(sk) >rxopt.all)
 			pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);
 	if (flags & MSG_OOB)
 		goto out;
 
 	if (addr_len)
 		*addr_len = sizeof(*sin);
 
 	if (flags & MSG_ERRQUEUE) {
 		err = ip_recv_error(sk, msg, len);
 		goto out;
 		sin >sin_addr.s_addr = ip_hdr(skb) >saddr;
 		sin >sin_port = 0;
 		memset(&sin >sin_zero, 0, sizeof(sin >sin_zero));
 	}
 	if (inet >cmsg_flags)
 		ip_cmsg_recv(msg, skb);
 	int is_udplite = IS_UDPLITE(sk);
 	bool slow;
 
 	/*
 	 *	Check any passed addresses
 	 */
 	if (addr_len)
 		*addr_len = sizeof(*sin);
 
 	if (flags & MSG_ERRQUEUE)
 		return ip_recv_error(sk, msg, len);
 
 		sin >sin_port = udp_hdr(skb) >source;
 		sin >sin_addr.s_addr = ip_hdr(skb) >saddr;
 		memset(sin >sin_zero, 0, sizeof(sin >sin_zero));
 	}
 	if (inet >cmsg_flags)
 		ip_cmsg_recv(msg, skb);
 	if (flags & MSG_OOB)
 		return  EOPNOTSUPP;
 
 	if (addr_len)
 		*addr_len=sizeof(*sin6);
 
 	if (flags & MSG_ERRQUEUE)
 		return ipv6_recv_error(sk, msg, len);
 
 		sin6 >sin6_flowinfo = 0;
 		sin6 >sin6_scope_id = ipv6_iface_scope_id(&sin6 >sin6_addr,
 							  IP6CB(skb) >iif);
 	}
 
 	sock_recv_ts_and_drops(msg, sk, skb);
 	int is_udp4;
 	bool slow;
 
 	if (addr_len)
 		*addr_len = sizeof(struct sockaddr_in6);
 
 	if (flags & MSG_ERRQUEUE)
 		return ipv6_recv_error(sk, msg, len);
 
 				ipv6_iface_scope_id(&sin6 >sin6_addr,
 						    IP6CB(skb) >iif);
 		}
 
 	}
 	if (is_udp4) {
 		if (inet >cmsg_flags)
 	if (flags & MSG_OOB)
 		goto out;
 
 	if (addr_len)
 		*addr_len = sizeof(*sin);
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;
 		sin >sin_addr.s_addr = ip_hdr(skb) >saddr;
 		sin >sin_port = 0;
 		memset(&sin >sin_zero, 0, sizeof(sin >sin_zero));
 	}
 	if (inet >cmsg_flags)
 		ip_cmsg_recv(msg, skb);
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
 	if (addr_len)
 		*addr_len = sizeof(sa);
 
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;
 
 	rval = (flags & MSG_TRUNC) ? skb >len : copylen;
 
 	if (msg >msg_name != NULL)
 		memcpy(msg >msg_name, &sa, sizeof(struct sockaddr_pn));
 
 out:
 	skb_free_datagram(sk, skb);
After patch : 
 	if (saddr) {
 		saddr >family = AF_IEEE802154;
 		saddr >addr = mac_cb(skb) >sa;
 		*addr_len = sizeof(*saddr);
 	}
 
 	if (flags & MSG_TRUNC)
 		copied = skb >len;
 {
 	struct inet_sock *isk = inet_sk(sk);
 	int family = sk >sk_family;
 	struct sk_buff *skb;
 	int copied, err;
 
 	if (flags & MSG_OOB)
 		goto out;
 
 	if (flags & MSG_ERRQUEUE) {
 		if (family == AF_INET) {
 			return ip_recv_error(sk, msg, len);
 
 	/* Copy the address and add cmsg data. */
 	if (family == AF_INET) {
 		struct sockaddr_in *sin = (struct sockaddr_in *)msg >msg_name;
 
 		sin >sin_family = AF_INET;
 		sin >sin_port = 0 /* skb >h.uh >source */;
 		sin >sin_addr.s_addr = ip_hdr(skb) >saddr;
 		memset(sin >sin_zero, 0, sizeof(sin >sin_zero));
 		*addr_len = sizeof(*sin);
 
 		if (isk >cmsg_flags)
 			ip_cmsg_recv(msg, skb);
 	} else if (family == AF_INET6) {
 		struct ipv6_pinfo *np = inet6_sk(sk);
 		struct ipv6hdr *ip6 = ipv6_hdr(skb);
 		struct sockaddr_in6 *sin6 =
 			(struct sockaddr_in6 *)msg >msg_name;
 
 		sin6 >sin6_family = AF_INET6;
 		sin6 >sin6_port = 0;
 		sin6 >sin6_addr = ip6 >saddr;
 		sin6 >sin6_flowinfo = 0;
 		if (np >sndflow)
 			sin6 >sin6_flowinfo = ip6_flowinfo(ip6);
 
 		sin6 >sin6_scope_id = ipv6_iface_scope_id(&sin6 >sin6_addr,
 							  IP6CB(skb) >iif);
 		*addr_len = sizeof(*sin6);
 
 		if (inet6_sk(sk) >rxopt.all)
 			pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);
 	if (flags & MSG_OOB)
 		goto out;
 
 	if (flags & MSG_ERRQUEUE) {
 		err = ip_recv_error(sk, msg, len);
 		goto out;
 		sin >sin_addr.s_addr = ip_hdr(skb) >saddr;
 		sin >sin_port = 0;
 		memset(&sin >sin_zero, 0, sizeof(sin >sin_zero));
 		*addr_len = sizeof(*sin);
 	}
 	if (inet >cmsg_flags)
 		ip_cmsg_recv(msg, skb);
 	int is_udplite = IS_UDPLITE(sk);
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
 		return ip_recv_error(sk, msg, len);
 
 		sin >sin_port = udp_hdr(skb) >source;
 		sin >sin_addr.s_addr = ip_hdr(skb) >saddr;
 		memset(sin >sin_zero, 0, sizeof(sin >sin_zero));
 		*addr_len = sizeof(*sin);
 	}
 	if (inet >cmsg_flags)
 		ip_cmsg_recv(msg, skb);
 	if (flags & MSG_OOB)
 		return  EOPNOTSUPP;
 
 	if (flags & MSG_ERRQUEUE)
 		return ipv6_recv_error(sk, msg, len);
 
 		sin6 >sin6_flowinfo = 0;
 		sin6 >sin6_scope_id = ipv6_iface_scope_id(&sin6 >sin6_addr,
 							  IP6CB(skb) >iif);
 		*addr_len = sizeof(*sin6);
 	}
 
 	sock_recv_ts_and_drops(msg, sk, skb);
 	int is_udp4;
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
 		return ipv6_recv_error(sk, msg, len);
 
 				ipv6_iface_scope_id(&sin6 >sin6_addr,
 						    IP6CB(skb) >iif);
 		}
 		*addr_len = sizeof(*sin6);
 	}
 	if (is_udp4) {
 		if (inet >cmsg_flags)
 	if (flags & MSG_OOB)
 		goto out;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;
 		sin >sin_addr.s_addr = ip_hdr(skb) >saddr;
 		sin >sin_port = 0;
 		memset(&sin >sin_zero, 0, sizeof(sin >sin_zero));
 		*addr_len = sizeof(*sin);
 	}
 	if (inet >cmsg_flags)
 		ip_cmsg_recv(msg, skb);
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;
 
 	rval = (flags & MSG_TRUNC) ? skb >len : copylen;
 
 	if (msg >msg_name != NULL) {
 		memcpy(msg >msg_name, &sa, sizeof(sa));
 		*addr_len = sizeof(sa);
 	}
 
 out:
 	skb_free_datagram(sk, skb);
