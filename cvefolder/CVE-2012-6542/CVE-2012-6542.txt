CVE Number : CVE-2012-6542
Commit Message : 
llc: fix info leak via getsockname()
Commit Details : 
The LLC code wrongly returns 0, i.e. "success", when the socket is
zapped. Together with the uninitialized uaddrlen pointer argument from
sys_getsockname this leads to an arbitrary memory leak of up to 128
bytes kernel stack via the getsockname() syscall.

Return an error instead when the socket is zapped to prevent the info
leak. Also remove the unnecessary memset(0). We don't directly write to
the memory pointed by uaddr but memcpy() a local structure at the end of
the function that is properly initialized.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 	struct sockaddr_llc sllc;
 	struct sock *sk = sock >sk;
 	struct llc_sock *llc = llc_sk(sk);
 	int rc = 0;
 
 	memset(&sllc, 0, sizeof(sllc));
 	lock_sock(sk);
 	if (sock_flag(sk, SOCK_ZAPPED))
 		goto out;
 	*uaddrlen = sizeof(sllc);
 	memset(uaddr, 0, *uaddrlen);
 	if (peer) {
 		rc =  ENOTCONN;
 		if (sk >sk_state != TCP_ESTABLISHED)
After patch : 
 	struct sockaddr_llc sllc;
 	struct sock *sk = sock >sk;
 	struct llc_sock *llc = llc_sk(sk);
 	int rc =  EBADF;
 
 	memset(&sllc, 0, sizeof(sllc));
 	lock_sock(sk);
 	if (sock_flag(sk, SOCK_ZAPPED))
 		goto out;
 	*uaddrlen = sizeof(sllc);
 	if (peer) {
 		rc =  ENOTCONN;
 		if (sk >sk_state != TCP_ESTABLISHED)
