CVE Number : CVE-2018-14734
Commit Message : 
infiniband: fix a possible use-after-free bug
Commit Details : 
ucma_process_join() will free the new allocated "mc" struct,
if there is any error after that, especially the copy_to_user().

But in parallel, ucma_leave_multicast() could find this "mc"
through idr_find() before ucma_process_join() frees it, since it
is already published.

So "mc" could be used in ucma_leave_multicast() after it is been
allocated and freed in ucma_process_join(), since we don't refcnt
it.

Fix this by separating "publish" from ID allocation, so that we
can get an ID first and publish it later after copy_to_user().

Fixes: c8f6a362bf3e ("RDMA/cma: Add multicast communication support")
Reported-by: Noam Rathaus <noamr@beyondsecurity.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

Before patch : 
 		return NULL;
 
 	mutex_lock(&mut);
 	mc >id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
 	mutex_unlock(&mut);
 	if (mc >id < 0)
 		goto error;
 		goto err3;
 	}
 
 	mutex_unlock(&file >mut);
 	ucma_put_ctx(ctx);
 	return 0;
After patch : 
 		return NULL;
 
 	mutex_lock(&mut);
 	mc >id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);
 	mutex_unlock(&mut);
 	if (mc >id < 0)
 		goto error;
 		goto err3;
 	}
 
 	mutex_lock(&mut);
 	idr_replace(&multicast_idr, mc, mc >id);
 	mutex_unlock(&mut);
 
 	mutex_unlock(&file >mut);
 	ucma_put_ctx(ctx);
 	return 0;
