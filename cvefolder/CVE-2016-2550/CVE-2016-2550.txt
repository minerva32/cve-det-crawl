CVE Number : CVE-2016-2550
Commit Message : 
unix: correctly track in-flight fds in sending process user_struct
Commit Details : 
The commit referenced in the Fixes tag incorrectly accounted the number
of in-flight fds over a unix domain socket to the original opener
of the file-descriptor. This allows another process to arbitrary
deplete the original file-openers resource limit for the maximum of
open files. Instead the sending processes and its struct cred should
be credited.

To do so, we add a reference counted struct user_struct pointer to the
scm_fp_list and use it to account for the number of inflight unix fds.

Fixes: 712f4aad406bb1 ("unix: properly account for FDs passed over unix sockets")
Reported-by: David Herrmann <dh.herrmann@gmail.com>
Cc: David Herrmann <dh.herrmann@gmail.com>
Cc: Willy Tarreau <w@1wt.eu>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 #include <linux/mutex.h>
 #include <net/sock.h>
 
 void unix_inflight(struct file *fp);
 void unix_notinflight(struct file *fp);
 void unix_gc(void);
 void wait_for_unix_gc(void);
 struct sock *unix_get_socket(struct file *filp);
 struct scm_fp_list {
 	short			count;
 	short			max;
 	struct file		*fp[SCM_MAX_FD];
 };
 
 		*fplp = fpl;
 		fpl >count = 0;
 		fpl >max = SCM_MAX_FD;
 	}
 	fpp = &fpl >fp[fpl >count];
 
 		*fpp   = file;
 		fpl >count  ;
 	}
 	return num;
 }
 
 		scm >fp = NULL;
 		for (i=fpl >count 1; i>=0; i  )
 			fput(fpl >fp[i]);
 		kfree(fpl);
 	}
 }
 		for (i = 0; i < fpl >count; i  )
 			get_file(fpl >fp[i]);
 		new_fpl >max = new_fpl >count;
 	}
 	return new_fpl;
 }
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm >fp >count 1; i >= 0; i  )
 		unix_notinflight(scm >fp >fp[i]);
 }
 
 static void unix_destruct_scm(struct sk_buff *skb)
 		return  ENOMEM;
 
 	for (i = scm >fp >count   1; i >= 0; i  )
 		unix_inflight(scm >fp >fp[i]);
 	return max_level;
 }
 
  * descriptor if it is for an AF_UNIX socket.
  */
 
 void unix_inflight(struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 
 		}
 		unix_tot_inflight  ;
 	}
 	fp >f_cred >user >unix_inflight  ;
 	spin_unlock(&unix_gc_lock);
 }
 
 void unix_notinflight(struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 
 			list_del_init(&u >link);
 		unix_tot_inflight  ;
 	}
 	fp >f_cred >user >unix_inflight  ;
 	spin_unlock(&unix_gc_lock);
 }
 
After patch : 
 #include <linux/mutex.h>
 #include <net/sock.h>
 
 void unix_inflight(struct user_struct *user, struct file *fp);
 void unix_notinflight(struct user_struct *user, struct file *fp);
 void unix_gc(void);
 void wait_for_unix_gc(void);
 struct sock *unix_get_socket(struct file *filp);
 struct scm_fp_list {
 	short			count;
 	short			max;
 	struct user_struct	*user;
 	struct file		*fp[SCM_MAX_FD];
 };
 
 		*fplp = fpl;
 		fpl >count = 0;
 		fpl >max = SCM_MAX_FD;
 		fpl >user = NULL;
 	}
 	fpp = &fpl >fp[fpl >count];
 
 		*fpp   = file;
 		fpl >count  ;
 	}
 
 	if (!fpl >user)
 		fpl >user = get_uid(current_user());
 
 	return num;
 }
 
 		scm >fp = NULL;
 		for (i=fpl >count 1; i>=0; i  )
 			fput(fpl >fp[i]);
 		free_uid(fpl >user);
 		kfree(fpl);
 	}
 }
 		for (i = 0; i < fpl >count; i  )
 			get_file(fpl >fp[i]);
 		new_fpl >max = new_fpl >count;
 		new_fpl >user = get_uid(fpl >user);
 	}
 	return new_fpl;
 }
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm >fp >count 1; i >= 0; i  )
 		unix_notinflight(scm >fp >user, scm >fp >fp[i]);
 }
 
 static void unix_destruct_scm(struct sk_buff *skb)
 		return  ENOMEM;
 
 	for (i = scm >fp >count   1; i >= 0; i  )
 		unix_inflight(scm >fp >user, scm >fp >fp[i]);
 	return max_level;
 }
 
  * descriptor if it is for an AF_UNIX socket.
  */
 
 void unix_inflight(struct user_struct *user, struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 
 		}
 		unix_tot_inflight  ;
 	}
 	user >unix_inflight  ;
 	spin_unlock(&unix_gc_lock);
 }
 
 void unix_notinflight(struct user_struct *user, struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 
 			list_del_init(&u >link);
 		unix_tot_inflight  ;
 	}
 	user >unix_inflight  ;
 	spin_unlock(&unix_gc_lock);
 }
 
