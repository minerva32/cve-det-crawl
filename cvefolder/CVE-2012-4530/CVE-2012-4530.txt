CVE Number : CVE-2012-4530
Commit Message : 
exec: do not leave bprm->interp on stack
Commit Details : 
If a series of scripts are executed, each triggering module loading via
unprintable bytes in the script header, kernel stack contents can leak
into the command line.

Normally execution of binfmt_script and binfmt_misc happens recursively.
However, when modules are enabled, and unprintable bytes exist in the
bprm->buf, execution will restart after attempting to load matching
binfmt modules.  Unfortunately, the logic in binfmt_script and
binfmt_misc does not expect to get restarted.  They leave bprm->interp
pointing to their local stack.  This means on restart bprm->interp is
left pointing into unused stack memory which can then be copied into the
userspace argv areas.

After additional study, it seems that both recursion and restart remains
the desirable way to handle exec with scripts, misc, and modules.  As
such, we need to protect the changes to interp.

This changes the logic to require allocation for any changes to the
bprm->interp.  To avoid adding a new kmalloc to every exec, the default
value is left as-is.  Only when passing through binfmt_script or
binfmt_misc does an allocation take place.

For a proof of concept, see DoTest.sh from:

   http://www.halfdog.net/Security/2012/LinuxKernelBinfmtScriptStackDataDisclosure/

Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: halfdog <me@halfdog.net>
Cc: P J P <ppandit@redhat.com>
Cc: Alexander Viro <viro@zeniv.linux.org.uk>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 		goto _error;
 	bprm >argc   ;
 
 	bprm >interp = iname;	/* for binfmt_script */
 
 	interp_file = open_exec (iname);
 	retval = PTR_ERR (interp_file);
 	retval = copy_strings_kernel(1, &i_name, bprm);
 	if (retval) return retval; 
 	bprm >argc  ;
 	bprm >interp = interp;
 
 	/*
 	 * OK, now restart the process with the interpreter's dentry.
 		mutex_unlock(&current >signal >cred_guard_mutex);
 		abort_creds(bprm >cred);
 	}
 	kfree(bprm);
 }
 
 /*
  * install the new credentials for this executable
  */
 			   unsigned long stack_top,
 			   int executable_stack);
 extern int bprm_mm_init(struct linux_binprm *bprm);
 extern int copy_strings_kernel(int argc, const char *const *argv,
 			       struct linux_binprm *bprm);
 extern int prepare_bprm_creds(struct linux_binprm *bprm);
After patch : 
 		goto _error;
 	bprm >argc   ;
 
 	/* Update interp in case binfmt_script needs it. */
 	retval = bprm_change_interp(iname, bprm);
 	if (retval < 0)
 		goto _error;
 
 	interp_file = open_exec (iname);
 	retval = PTR_ERR (interp_file);
 	retval = copy_strings_kernel(1, &i_name, bprm);
 	if (retval) return retval; 
 	bprm >argc  ;
 	retval = bprm_change_interp(interp, bprm);
 	if (retval < 0)
 		return retval;
 
 	/*
 	 * OK, now restart the process with the interpreter's dentry.
 		mutex_unlock(&current >signal >cred_guard_mutex);
 		abort_creds(bprm >cred);
 	}
 	/* If a binfmt changed the interp, free it. */
 	if (bprm >interp != bprm >filename)
 		kfree(bprm >interp);
 	kfree(bprm);
 }
 
 int bprm_change_interp(char *interp, struct linux_binprm *bprm)
 {
 	/* If a binfmt changed the interp, free it first. */
 	if (bprm >interp != bprm >filename)
 		kfree(bprm >interp);
 	bprm >interp = kstrdup(interp, GFP_KERNEL);
 	if (!bprm >interp)
 		return  ENOMEM;
 	return 0;
 }
 EXPORT_SYMBOL(bprm_change_interp);
 
 /*
  * install the new credentials for this executable
  */
 			   unsigned long stack_top,
 			   int executable_stack);
 extern int bprm_mm_init(struct linux_binprm *bprm);
 extern int bprm_change_interp(char *interp, struct linux_binprm *bprm);
 extern int copy_strings_kernel(int argc, const char *const *argv,
 			       struct linux_binprm *bprm);
 extern int prepare_bprm_creds(struct linux_binprm *bprm);
