CVE Number : CVE-2018-5344
Commit Message : 
loop: fix concurrent lo_open/lo_release
Commit Details : 
范龙飞 reports that KASAN can report a use-after-free in __lock_acquire.
The reason is due to insufficient serialization in lo_release(), which
will continue to use the loop device even after it has decremented the
lo_refcnt to zero.

In the meantime, another process can come in, open the loop device
again as it is being shut down. Confusion ensues.

Reported-by: 范龙飞 <long7573@126.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Jens Axboe <axboe@kernel.dk>

Before patch : 
 	return err;
 }
 
 static void lo_release(struct gendisk *disk, fmode_t mode)
 {
 	struct loop_device *lo = disk >private_data;
 	int err;
 
 	if (atomic_dec_return(&lo >lo_refcnt))
 	mutex_unlock(&lo >lo_ctl_mutex);
 }
 
 static const struct block_device_operations lo_fops = {
 	.owner =	THIS_MODULE,
 	.open =		lo_open,
After patch : 
 	return err;
 }
 
 static void __lo_release(struct loop_device *lo)
 {
 	int err;
 
 	if (atomic_dec_return(&lo >lo_refcnt))
 	mutex_unlock(&lo >lo_ctl_mutex);
 }
 
 static void lo_release(struct gendisk *disk, fmode_t mode)
 {
 	mutex_lock(&loop_index_mutex);
 	__lo_release(disk >private_data);
 	mutex_unlock(&loop_index_mutex);
 }
 
 static const struct block_device_operations lo_fops = {
 	.owner =	THIS_MODULE,
 	.open =		lo_open,
