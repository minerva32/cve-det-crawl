CVE Number : CVE-2015-2925
Commit Message : 
vfs: Test for and handle paths that are unreachable from their mnt_root
Commit Details : 
In rare cases a directory can be renamed out from under a bind mount.
In those cases without special handling it becomes possible to walk up
the directory tree to the root dentry of the filesystem and down
from the root dentry to every other file or directory on the filesystem.

Like division by zero .. from an unconnected path can not be given
a useful semantic as there is no predicting at which path component
the code will realize it is unconnected.  We certainly can not match
the current behavior as the current behavior is a security hole.

Therefore when encounting .. when following an unconnected path
return -ENOENT.

- Add a function path_connected to verify path->dentry is reachable
  from path->mnt.mnt_root.  AKA to validate that rename did not do
  something nasty to the bind mount.

  To avoid races path_connected must be called after following a path
  component to it's next path component.

Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

Before patch : 
 	return 0;
 }
 
 static inline int nd_alloc_stack(struct nameidata *nd)
 {
 	if (likely(nd >depth != EMBEDDED_LEVELS))
 				return  ECHILD;
 			nd >path.dentry = parent;
 			nd >seq = seq;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd >path.mnt);
 	}
 }
 
 static void follow_dotdot(struct nameidata *nd)
 {
 	if (!nd >root.mnt)
 		set_root(nd);
 			/* rare case of legitimate dget_parent()... */
 			nd >path.dentry = dget_parent(nd >path.dentry);
 			dput(old);
 			break;
 		}
 		if (!follow_up(&nd >path))
 	}
 	follow_mount(&nd >path);
 	nd >inode = nd >path.dentry >d_inode;
 }
 
 /*
 		if (nd >flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
 			follow_dotdot(nd);
 	}
 	return 0;
 }
After patch : 
 	return 0;
 }
 
 /**
  * path_connected   Verify that a path >dentry is below path >mnt.mnt_root
  * @path: nameidate to verify
  *
  * Rename can sometimes move a file or directory outside of a bind
  * mount, path_connected allows those cases to be detected.
  */
 static bool path_connected(const struct path *path)
 {
 	struct vfsmount *mnt = path >mnt;
 
 	/* Only bind mounts can have disconnected paths */
 	if (mnt >mnt_root == mnt >mnt_sb >s_root)
 		return true;
 
 	return is_subdir(path >dentry, mnt >mnt_root);
 }
 
 static inline int nd_alloc_stack(struct nameidata *nd)
 {
 	if (likely(nd >depth != EMBEDDED_LEVELS))
 				return  ECHILD;
 			nd >path.dentry = parent;
 			nd >seq = seq;
 			if (unlikely(!path_connected(&nd >path)))
 				return  ENOENT;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd >path.mnt);
 	}
 }
 
 static int follow_dotdot(struct nameidata *nd)
 {
 	if (!nd >root.mnt)
 		set_root(nd);
 			/* rare case of legitimate dget_parent()... */
 			nd >path.dentry = dget_parent(nd >path.dentry);
 			dput(old);
 			if (unlikely(!path_connected(&nd >path)))
 				return  ENOENT;
 			break;
 		}
 		if (!follow_up(&nd >path))
 	}
 	follow_mount(&nd >path);
 	nd >inode = nd >path.dentry >d_inode;
 	return 0;
 }
 
 /*
 		if (nd >flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
 			return follow_dotdot(nd);
 	}
 	return 0;
 }
