CVE Number : CVE-2010-4529
Commit Message : 
irda: prevent integer underflow in IRLMP_ENUMDEVICES
Commit Details : 
If the user-provided len is less than the expected offset, the
IRLMP_ENUMDEVICES getsockopt will do a copy_to_user() with a very large
size value.  While this isn't be a security issue on x86 because it will
get caught by the access_ok() check, it may leak large amounts of kernel
heap on other architectures.  In any event, this patch fixes it.

Signed-off-by: Dan Rosenberg <drosenberg@vsecurity.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 	switch (optname) {
 	case IRLMP_ENUMDEVICES:
 		/* Ask lmp for the current discovery log */
 		discoveries = irlmp_get_discoveries(&list.len, self >mask.word,
 						    self >nslots);
 		}
 
 		/* Write total list length back to client */
 		if (copy_to_user(optval, &list,
 				 sizeof(struct irda_device_list)  
 				 sizeof(struct irda_device_info)))
 			err =  EFAULT;
 
 		/* Offset to first device entry */
 		offset = sizeof(struct irda_device_list)  
 			sizeof(struct irda_device_info);
 
 		/* Copy the list itself   watch for overflow */
 		if (list.len > 2048) {
 			err =  EINVAL;
After patch : 
 
 	switch (optname) {
 	case IRLMP_ENUMDEVICES:
 
 		/* Offset to first device entry */
 		offset = sizeof(struct irda_device_list)  
 			sizeof(struct irda_device_info);
 
 		if (len < offset) {
 			err =  EINVAL;
 			goto out;
 		}
 
 		/* Ask lmp for the current discovery log */
 		discoveries = irlmp_get_discoveries(&list.len, self >mask.word,
 						    self >nslots);
 		}
 
 		/* Write total list length back to client */
 		if (copy_to_user(optval, &list, offset))
 			err =  EFAULT;
 
 		/* Copy the list itself   watch for overflow */
 		if (list.len > 2048) {
 			err =  EINVAL;
