CVE Number : CVE-2013-1860
Commit Message : 
USB: cdc-wdm: fix buffer overflow
Commit Details : 
The buffer for responses must not overflow.
If this would happen, set a flag, drop the data and return
an error after user space has read all remaining data.

Signed-off-by: Oliver Neukum <oliver@neukum.org>
CC: stable@kernel.org
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Before patch : 
 #define WDM_RESPONDING		7
 #define WDM_SUSPENDING		8
 #define WDM_RESETTING		9
 
 #define WDM_MAX			16
 
 {
 	struct wdm_device *desc = urb >context;
 	int status = urb >status;
 
 	spin_lock(&desc >iuspin);
 	clear_bit(WDM_RESPONDING, &desc >flags);
 	}
 
 	desc >rerr = status;
 	desc >reslength = urb >actual_length;
 	memmove(desc >ubuf   desc >length, desc >inbuf, desc >reslength);
 	desc >length  = desc >reslength;
 skip_error:
 	wake_up(&desc >wait);
 
 			rv =  ENODEV;
 			goto err;
 		}
 		i  ;
 		if (file >f_flags & O_NONBLOCK) {
 			if (!test_bit(WDM_READ, &desc >flags)) {
 			spin_unlock_irq(&desc >iuspin);
 			goto retry;
 		}
 		if (!desc >reslength) { /* zero length read */
 			dev_dbg(&desc >intf >dev, "%s: zero length   clearing WDM_READ\n", __func__);
 			clear_bit(WDM_READ, &desc >flags);
 	struct wdm_device *desc = wdm_find_device(intf);
 	int rv;
 
 	clear_bit(WDM_RESETTING, &desc >flags);
 	rv = recover_from_urb_loss(desc);
 	mutex_unlock(&desc >wlock);
After patch : 
 #define WDM_RESPONDING		7
 #define WDM_SUSPENDING		8
 #define WDM_RESETTING		9
 #define WDM_OVERFLOW		10
 
 #define WDM_MAX			16
 
 {
 	struct wdm_device *desc = urb >context;
 	int status = urb >status;
 	int length = urb >actual_length;
 
 	spin_lock(&desc >iuspin);
 	clear_bit(WDM_RESPONDING, &desc >flags);
 	}
 
 	desc >rerr = status;
 	if (length   desc >length > desc >wMaxCommand) {
 		/* The buffer would overflow */
 		set_bit(WDM_OVERFLOW, &desc >flags);
 	} else {
 		/* we may already be in overflow */
 		if (!test_bit(WDM_OVERFLOW, &desc >flags)) {
 			memmove(desc >ubuf   desc >length, desc >inbuf, length);
 			desc >length  = length;
 			desc >reslength = length;
 		}
 	}
 skip_error:
 	wake_up(&desc >wait);
 
 			rv =  ENODEV;
 			goto err;
 		}
 		if (test_bit(WDM_OVERFLOW, &desc >flags)) {
 			clear_bit(WDM_OVERFLOW, &desc >flags);
 			rv =  ENOBUFS;
 			goto err;
 		}
 		i  ;
 		if (file >f_flags & O_NONBLOCK) {
 			if (!test_bit(WDM_READ, &desc >flags)) {
 			spin_unlock_irq(&desc >iuspin);
 			goto retry;
 		}
 
 		if (!desc >reslength) { /* zero length read */
 			dev_dbg(&desc >intf >dev, "%s: zero length   clearing WDM_READ\n", __func__);
 			clear_bit(WDM_READ, &desc >flags);
 	struct wdm_device *desc = wdm_find_device(intf);
 	int rv;
 
 	clear_bit(WDM_OVERFLOW, &desc >flags);
 	clear_bit(WDM_RESETTING, &desc >flags);
 	rv = recover_from_urb_loss(desc);
 	mutex_unlock(&desc >wlock);
