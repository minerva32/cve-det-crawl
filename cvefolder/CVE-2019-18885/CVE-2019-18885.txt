CVE Number : CVE-2019-18885
Commit Message : 
btrfs: merge btrfs_find_device and find_device
Commit Details : 
Both btrfs_find_device() and find_device() does the same thing except
that the latter does not take the seed device onto account in the device
scanning context. We can merge them.

Signed-off-by: Anand Jain <anand.jain@oracle.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>

Before patch : 
 	case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:
 	case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:
 		dev_replace >srcdev = btrfs_find_device(fs_info >fs_devices,
 							src_devid, NULL, NULL);
 		dev_replace >tgtdev = btrfs_find_device(fs_info >fs_devices,
 							BTRFS_DEV_REPLACE_DEVID,
 							NULL, NULL);
 		/*
 		 * allow 'btrfs dev replace_cancel' if src/tgt device is
 		 * missing
 		btrfs_info(fs_info, "resizing devid %llu", devid);
 	}
 
 	device = btrfs_find_device(fs_info >fs_devices, devid, NULL, NULL);
 	if (!device) {
 		btrfs_info(fs_info, "resizer unable to find device %llu",
 			   devid);
 
 	rcu_read_lock();
 	dev = btrfs_find_device(fs_info >fs_devices, di_args >devid, s_uuid,
 				NULL);
 
 	if (!dev) {
 		ret =  ENODEV;
 		return PTR_ERR(sctx);
 
 	mutex_lock(&fs_info >fs_devices >device_list_mutex);
 	dev = btrfs_find_device(fs_info >fs_devices, devid, NULL, NULL);
 	if (!dev || (test_bit(BTRFS_DEV_STATE_MISSING, &dev >dev_state) &&
 		     !is_dev_replace)) {
 		mutex_unlock(&fs_info >fs_devices >device_list_mutex);
 	struct scrub_ctx *sctx = NULL;
 
 	mutex_lock(&fs_info >fs_devices >device_list_mutex);
 	dev = btrfs_find_device(fs_info >fs_devices, devid, NULL, NULL);
 	if (dev)
 		sctx = dev >scrub_ctx;
 	if (sctx)
 	return dev;
 }
 
 /*
  * Find a device specified by @devid or @uuid in the list of @fs_devices, or
  * return NULL.
  *
  * If devid and uuid are both specified, the match must be exact, otherwise
  * only devid is used.
  */
 static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,
 		u64 devid, const u8 *uuid)
 {
 	struct btrfs_device *dev;
 
 	list_for_each_entry(dev, &fs_devices >devices, dev_list) {
 		if (dev >devid == devid &&
 		    (!uuid || !memcmp(dev >uuid, uuid, BTRFS_UUID_SIZE))) {
 			return dev;
 		}
 	}
 	return NULL;
 }
 
 static noinline struct btrfs_fs_devices *find_fsid(
 		const u8 *fsid, const u8 *metadata_fsid)
 {
 		device = NULL;
 	} else {
 		mutex_lock(&fs_devices >device_list_mutex);
 		device = find_device(fs_devices, devid,
 				disk_super >dev_item.uuid);
 
 		/*
 		 * If this disk has been pulled into an fs devices created by
 	dev_uuid = disk_super >dev_item.uuid;
 	if (btrfs_fs_incompat(fs_info, METADATA_UUID))
 		device = btrfs_find_device(fs_info >fs_devices, devid, dev_uuid,
 					   disk_super >metadata_uuid);
 	else
 		device = btrfs_find_device(fs_info >fs_devices, devid, dev_uuid,
 					   disk_super >fsid);
 
 	brelse(bh);
 	if (!device)
 
 	if (devid) {
 		device = btrfs_find_device(fs_info >fs_devices, devid, NULL,
 					   NULL);
 		if (!device)
 			return ERR_PTR( ENOENT);
 		return device;
 		read_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),
 				   BTRFS_FSID_SIZE);
 		device = btrfs_find_device(fs_info >fs_devices, devid, dev_uuid,
 					   fs_uuid);
 		BUG_ON(!device); /* Logic error */
 
 		if (device >fs_devices >seeding) {
 	return BLK_STS_OK;
 }
 
 struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,
 				       u64 devid, u8 *uuid, u8 *fsid)
 {
 	struct btrfs_device *device;
 
 	while (fs_devices) {
 		if (!fsid ||
 		    !memcmp(fs_devices >metadata_uuid, fsid, BTRFS_FSID_SIZE)) {
 			device = find_device(fs_devices, devid, uuid);
 			if (device)
 				return device;
 		}
 		fs_devices = fs_devices >seed;
 	}
 	return NULL;
 }
 				   btrfs_stripe_dev_uuid_nr(chunk, i),
 				   BTRFS_UUID_SIZE);
 		map >stripes[i].dev = btrfs_find_device(fs_info >fs_devices,
 							devid, uuid, NULL);
 		if (!map >stripes[i].dev &&
 		    !btrfs_test_opt(fs_info, DEGRADED)) {
 			free_extent_map(em);
 	}
 
 	device = btrfs_find_device(fs_info >fs_devices, devid, dev_uuid,
 				   fs_uuid);
 	if (!device) {
 		if (!btrfs_test_opt(fs_info, DEGRADED)) {
 			btrfs_report_missing_device(fs_info, devid,
 	int i;
 
 	mutex_lock(&fs_devices >device_list_mutex);
 	dev = btrfs_find_device(fs_info >fs_devices, stats >devid, NULL, NULL);
 	mutex_unlock(&fs_devices >device_list_mutex);
 
 	if (!dev) {
 	}
 
 	/* Make sure no dev extent is beyond device bondary */
 	dev = btrfs_find_device(fs_info >fs_devices, devid, NULL, NULL);
 	if (!dev) {
 		btrfs_err(fs_info, "failed to find devid %llu", devid);
 		ret =  EUCLEAN;
 
 	/* It's possible this device is a dummy for seed device */
 	if (dev >disk_total_bytes == 0) {
 		dev = find_device(fs_info >fs_devices >seed, devid, NULL);
 		if (!dev) {
 			btrfs_err(fs_info, "failed to find seed devid %llu",
 				  devid);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);
 struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,
 				       u64 devid, u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);
 int btrfs_balance(struct btrfs_fs_info *fs_info,
After patch : 
 	case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:
 	case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:
 		dev_replace >srcdev = btrfs_find_device(fs_info >fs_devices,
 						src_devid, NULL, NULL, true);
 		dev_replace >tgtdev = btrfs_find_device(fs_info >fs_devices,
 							BTRFS_DEV_REPLACE_DEVID,
 							NULL, NULL, true);
 		/*
 		 * allow 'btrfs dev replace_cancel' if src/tgt device is
 		 * missing
 		btrfs_info(fs_info, "resizing devid %llu", devid);
 	}
 
 	device = btrfs_find_device(fs_info >fs_devices, devid, NULL, NULL, true);
 	if (!device) {
 		btrfs_info(fs_info, "resizer unable to find device %llu",
 			   devid);
 
 	rcu_read_lock();
 	dev = btrfs_find_device(fs_info >fs_devices, di_args >devid, s_uuid,
 				NULL, true);
 
 	if (!dev) {
 		ret =  ENODEV;
 		return PTR_ERR(sctx);
 
 	mutex_lock(&fs_info >fs_devices >device_list_mutex);
 	dev = btrfs_find_device(fs_info >fs_devices, devid, NULL, NULL, true);
 	if (!dev || (test_bit(BTRFS_DEV_STATE_MISSING, &dev >dev_state) &&
 		     !is_dev_replace)) {
 		mutex_unlock(&fs_info >fs_devices >device_list_mutex);
 	struct scrub_ctx *sctx = NULL;
 
 	mutex_lock(&fs_info >fs_devices >device_list_mutex);
 	dev = btrfs_find_device(fs_info >fs_devices, devid, NULL, NULL, true);
 	if (dev)
 		sctx = dev >scrub_ctx;
 	if (sctx)
 	return dev;
 }
 
 static noinline struct btrfs_fs_devices *find_fsid(
 		const u8 *fsid, const u8 *metadata_fsid)
 {
 		device = NULL;
 	} else {
 		mutex_lock(&fs_devices >device_list_mutex);
 		device = btrfs_find_device(fs_devices, devid,
 				disk_super >dev_item.uuid, NULL, false);
 
 		/*
 		 * If this disk has been pulled into an fs devices created by
 	dev_uuid = disk_super >dev_item.uuid;
 	if (btrfs_fs_incompat(fs_info, METADATA_UUID))
 		device = btrfs_find_device(fs_info >fs_devices, devid, dev_uuid,
 					   disk_super >metadata_uuid, true);
 	else
 		device = btrfs_find_device(fs_info >fs_devices, devid, dev_uuid,
 					   disk_super >fsid, true);
 
 	brelse(bh);
 	if (!device)
 
 	if (devid) {
 		device = btrfs_find_device(fs_info >fs_devices, devid, NULL,
 					   NULL, true);
 		if (!device)
 			return ERR_PTR( ENOENT);
 		return device;
 		read_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),
 				   BTRFS_FSID_SIZE);
 		device = btrfs_find_device(fs_info >fs_devices, devid, dev_uuid,
 					   fs_uuid, true);
 		BUG_ON(!device); /* Logic error */
 
 		if (device >fs_devices >seeding) {
 	return BLK_STS_OK;
 }
 
 /*
  * Find a device specified by @devid or @uuid in the list of @fs_devices, or
  * return NULL.
  *
  * If devid and uuid are both specified, the match must be exact, otherwise
  * only devid is used.
  *
  * If @seed is true, traverse through the seed devices.
  */
 struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,
 				       u64 devid, u8 *uuid, u8 *fsid,
 				       bool seed)
 {
 	struct btrfs_device *device;
 
 	while (fs_devices) {
 		if (!fsid ||
 		    !memcmp(fs_devices >metadata_uuid, fsid, BTRFS_FSID_SIZE)) {
 			list_for_each_entry(device, &fs_devices >devices,
 					    dev_list) {
 				if (device >devid == devid &&
 				    (!uuid || memcmp(device >uuid, uuid,
 						     BTRFS_UUID_SIZE) == 0))
 					return device;
 			}
 		}
 		if (seed)
 			fs_devices = fs_devices >seed;
 		else
 			return NULL;
 	}
 	return NULL;
 }
 				   btrfs_stripe_dev_uuid_nr(chunk, i),
 				   BTRFS_UUID_SIZE);
 		map >stripes[i].dev = btrfs_find_device(fs_info >fs_devices,
 							devid, uuid, NULL, true);
 		if (!map >stripes[i].dev &&
 		    !btrfs_test_opt(fs_info, DEGRADED)) {
 			free_extent_map(em);
 	}
 
 	device = btrfs_find_device(fs_info >fs_devices, devid, dev_uuid,
 				   fs_uuid, true);
 	if (!device) {
 		if (!btrfs_test_opt(fs_info, DEGRADED)) {
 			btrfs_report_missing_device(fs_info, devid,
 	int i;
 
 	mutex_lock(&fs_devices >device_list_mutex);
 	dev = btrfs_find_device(fs_info >fs_devices, stats >devid, NULL, NULL,
 				true);
 	mutex_unlock(&fs_devices >device_list_mutex);
 
 	if (!dev) {
 	}
 
 	/* Make sure no dev extent is beyond device bondary */
 	dev = btrfs_find_device(fs_info >fs_devices, devid, NULL, NULL, true);
 	if (!dev) {
 		btrfs_err(fs_info, "failed to find devid %llu", devid);
 		ret =  EUCLEAN;
 
 	/* It's possible this device is a dummy for seed device */
 	if (dev >disk_total_bytes == 0) {
 		dev = btrfs_find_device(fs_info >fs_devices >seed, devid, NULL,
 					NULL, false);
 		if (!dev) {
 			btrfs_err(fs_info, "failed to find seed devid %llu",
 				  devid);
 int btrfs_grow_device(struct btrfs_trans_handle *trans,
 		      struct btrfs_device *device, u64 new_size);
 struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,
 				       u64 devid, u8 *uuid, u8 *fsid, bool seed);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);
 int btrfs_balance(struct btrfs_fs_info *fs_info,
