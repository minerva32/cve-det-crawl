CVE Number : CVE-2018-18955
Commit Message : 
userns: also map extents in the reverse map to kernel IDs
Commit Details : 
The current logic first clones the extent array and sorts both copies, then
maps the lower IDs of the forward mapping into the lower namespace, but
doesn't map the lower IDs of the reverse mapping.

This means that code in a nested user namespace with >5 extents will see
incorrect IDs. It also breaks some access checks, like
inode_owner_or_capable() and privileged_wrt_inode_uidgid(), so a process
can incorrectly appear to be capable relative to an inode.

To fix it, we have to make sure that the "lower_first" members of extents
in both arrays are translated; and we have to make sure that the reverse
map is sorted *after* the translation (since otherwise the translation can
break the sorting).

This is CVE-2018-18955.

Fixes: 6397fac4915a ("userns: bump idmap limits to 340")
Cc: stable@vger.kernel.org
Signed-off-by: Jann Horn <jannh@google.com>
Tested-by: Eric W. Biederman <ebiederm@xmission.com>
Reviewed-by: Eric W. Biederman <ebiederm@xmission.com>
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

Before patch : 
 	if (!new_idmap_permitted(file, ns, cap_setid, &new_map))
 		goto out;
 
 	ret = sort_idmaps(&new_map);
 	if (ret < 0)
 		goto out;
 
 	ret =  EPERM;
 	/* Map the lower ids from the parent user namespace to the
 	 * kernel global id space.
 		e >lower_first = lower_first;
 	}
 
 	/* Install the map */
 	if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {
 		memcpy(map >extent, new_map.extent,
After patch : 
 	if (!new_idmap_permitted(file, ns, cap_setid, &new_map))
 		goto out;
 
 	ret =  EPERM;
 	/* Map the lower ids from the parent user namespace to the
 	 * kernel global id space.
 		e >lower_first = lower_first;
 	}
 
 	/*
 	 * If we want to use binary search for lookup, this clones the extent
 	 * array and sorts both copies.
 	 */
 	ret = sort_idmaps(&new_map);
 	if (ret < 0)
 		goto out;
 
 	/* Install the map */
 	if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {
 		memcpy(map >extent, new_map.extent,
