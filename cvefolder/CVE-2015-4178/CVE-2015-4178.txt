CVE Number : CVE-2015-4178
Commit Message : 
fs_pin: Allow for the possibility that m_list or s_list go unused.
Commit Details : 
This is needed to support lazily umounting locked mounts.  Because the
entire unmounted subtree needs to stay together until there are no
users with references to any part of the subtree.

To support this guarantee that the fs_pin m_list and s_list nodes
are initialized by initializing them in init_fs_pin allowing
for the possibility that pin_insert_group does not touch them.

Further use hlist_del_init in pin_remove so that there is
a hlist_unhashed test before the list we attempt to update
the previous list item.

Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

Before patch : 
 void pin_remove(struct fs_pin *pin)
 {
 	spin_lock(&pin_lock);
 	hlist_del(&pin >m_list);
 	hlist_del(&pin >s_list);
 	spin_unlock(&pin_lock);
 	spin_lock_irq(&pin >wait.lock);
 	pin >done = 1;
 static inline void init_fs_pin(struct fs_pin *p, void (*kill)(struct fs_pin *))
 {
 	init_waitqueue_head(&p >wait);
 	p >kill = kill;
 }
 
After patch : 
 void pin_remove(struct fs_pin *pin)
 {
 	spin_lock(&pin_lock);
 	hlist_del_init(&pin >m_list);
 	hlist_del_init(&pin >s_list);
 	spin_unlock(&pin_lock);
 	spin_lock_irq(&pin >wait.lock);
 	pin >done = 1;
 static inline void init_fs_pin(struct fs_pin *p, void (*kill)(struct fs_pin *))
 {
 	init_waitqueue_head(&p >wait);
 	INIT_HLIST_NODE(&p >s_list);
 	INIT_HLIST_NODE(&p >m_list);
 	p >kill = kill;
 }
 
