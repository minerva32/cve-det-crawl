CVE Number : CVE-2019-11487
Commit Message : 
fs: prevent page refcount overflow in pipe_buf_get
Commit Details : 
Change pipe_buf_get() to return a bool indicating whether it succeeded
in raising the refcount of the page (if the thing in the pipe is a page).
This removes another mechanism for overflowing the page refcount.  All
callers converted to handle a failure.

Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Matthew Wilcox <willy@infradead.org>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 		rem  = pipe >bufs[(pipe >curbuf   idx) & (pipe >buffers   1)].len;
 
 	ret =  EINVAL;
 	if (rem < len) {
 		pipe_unlock(pipe);
 		goto out;
 	}
 
 	rem = len;
 	while (rem) {
 			pipe >curbuf = (pipe >curbuf   1) & (pipe >buffers   1);
 			pipe >nrbufs  ;
 		} else {
 			pipe_buf_get(pipe, ibuf);
 			*obuf = *ibuf;
 			obuf >flags &= ~PIPE_BUF_FLAG_GIFT;
 			obuf >len = rem;
 	ret = fuse_dev_do_write(fud, &cs, len);
 
 	pipe_lock(pipe);
 	for (idx = 0; idx < nbuf; idx  )
 		pipe_buf_release(pipe, &bufs[idx]);
 	pipe_unlock(pipe);
 
 out:
 	kvfree(bufs);
 	return ret;
 }
  *	in the tee() system call, when we duplicate the buffers in one
  *	pipe into another.
  */
 void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)
 {
 	get_page(buf >page);
 }
 EXPORT_SYMBOL(generic_pipe_buf_get);
 
 			 * Get a reference to this pipe buffer,
 			 * so we can copy the contents over.
 			 */
 			pipe_buf_get(ipipe, ibuf);
 			*obuf = *ibuf;
 
 			/*
 		 * Get a reference to this pipe buffer,
 		 * so we can copy the contents over.
 		 */
 		pipe_buf_get(ipipe, ibuf);
 
 		obuf = opipe >bufs   nbuf;
 		*obuf = *ibuf;
 	/*
 	 * Get a reference to the pipe buffer.
 	 */
 	void (*get)(struct pipe_inode_info *, struct pipe_buffer *);
 };
 
 /**
  * pipe_buf_get   get a reference to a pipe_buffer
  * @pipe:	the pipe that the buffer belongs to
  * @buf:	the buffer to get a reference to
  */
 static inline void pipe_buf_get(struct pipe_inode_info *pipe,
 				struct pipe_buffer *buf)
 {
 	buf >ops >get(pipe, buf);
 }
 
 /**
 void free_pipe_info(struct pipe_inode_info *);
 
 /* Generic pipe buffer ops functions */
 void generic_pipe_buf_get(struct pipe_inode_info *, struct pipe_buffer *);
 int generic_pipe_buf_confirm(struct pipe_inode_info *, struct pipe_buffer *);
 int generic_pipe_buf_steal(struct pipe_inode_info *, struct pipe_buffer *);
 void generic_pipe_buf_release(struct pipe_inode_info *, struct pipe_buffer *);
 	buf >private = 0;
 }
 
 static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,
 				struct pipe_buffer *buf)
 {
 	struct buffer_ref *ref = (struct buffer_ref *)buf >private;
 
 	ref >ref  ;
 }
 
 /* Pipe buffer operations for a buffer. */
After patch : 
 		rem  = pipe >bufs[(pipe >curbuf   idx) & (pipe >buffers   1)].len;
 
 	ret =  EINVAL;
 	if (rem < len)
 		goto out_free;
 
 	rem = len;
 	while (rem) {
 			pipe >curbuf = (pipe >curbuf   1) & (pipe >buffers   1);
 			pipe >nrbufs  ;
 		} else {
 			if (!pipe_buf_get(pipe, ibuf))
 				goto out_free;
 
 			*obuf = *ibuf;
 			obuf >flags &= ~PIPE_BUF_FLAG_GIFT;
 			obuf >len = rem;
 	ret = fuse_dev_do_write(fud, &cs, len);
 
 	pipe_lock(pipe);
 out_free:
 	for (idx = 0; idx < nbuf; idx  )
 		pipe_buf_release(pipe, &bufs[idx]);
 	pipe_unlock(pipe);
 
 	kvfree(bufs);
 	return ret;
 }
  *	in the tee() system call, when we duplicate the buffers in one
  *	pipe into another.
  */
 bool generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)
 {
 	return try_get_page(buf >page);
 }
 EXPORT_SYMBOL(generic_pipe_buf_get);
 
 			 * Get a reference to this pipe buffer,
 			 * so we can copy the contents over.
 			 */
 			if (!pipe_buf_get(ipipe, ibuf)) {
 				if (ret == 0)
 					ret =  EFAULT;
 				break;
 			}
 			*obuf = *ibuf;
 
 			/*
 		 * Get a reference to this pipe buffer,
 		 * so we can copy the contents over.
 		 */
 		if (!pipe_buf_get(ipipe, ibuf)) {
 			if (ret == 0)
 				ret =  EFAULT;
 			break;
 		}
 
 		obuf = opipe >bufs   nbuf;
 		*obuf = *ibuf;
 	/*
 	 * Get a reference to the pipe buffer.
 	 */
 	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
 };
 
 /**
  * pipe_buf_get   get a reference to a pipe_buffer
  * @pipe:	the pipe that the buffer belongs to
  * @buf:	the buffer to get a reference to
  *
  * Return: %true if the reference was successfully obtained.
  */
 static inline __must_check bool pipe_buf_get(struct pipe_inode_info *pipe,
 				struct pipe_buffer *buf)
 {
 	return buf >ops >get(pipe, buf);
 }
 
 /**
 void free_pipe_info(struct pipe_inode_info *);
 
 /* Generic pipe buffer ops functions */
 bool generic_pipe_buf_get(struct pipe_inode_info *, struct pipe_buffer *);
 int generic_pipe_buf_confirm(struct pipe_inode_info *, struct pipe_buffer *);
 int generic_pipe_buf_steal(struct pipe_inode_info *, struct pipe_buffer *);
 void generic_pipe_buf_release(struct pipe_inode_info *, struct pipe_buffer *);
 	buf >private = 0;
 }
 
 static bool buffer_pipe_buf_get(struct pipe_inode_info *pipe,
 				struct pipe_buffer *buf)
 {
 	struct buffer_ref *ref = (struct buffer_ref *)buf >private;
 
 	if (ref >ref > INT_MAX/2)
 		return false;
 
 	ref >ref  ;
 	return true;
 }
 
 /* Pipe buffer operations for a buffer. */
