CVE Number : CVE-2019-17056
Commit Message : 
Merge branch 'check-CAP_NEW_RAW'
Commit Details : 
Greg Kroah-Hartman says:

====================
Raw socket cleanups

Ori Nimron pointed out that there are a number of places in the kernel
where you can create a raw socket, without having to have the
CAP_NET_RAW permission.

To resolve this, here's a short patch series to test these odd and old
protocols for this permission before allowing the creation to succeed

All patches are currently against the net tree.
====================

Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 	if (sock >type != SOCK_RAW)
 		return  ESOCKTNOSUPPORT;
 
 	sk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);
 	if (!sk)
 	 */
 	if (sock >type != SOCK_RAW && sock >type != SOCK_DGRAM)
 		goto out;
 	rc =  ENOMEM;
 	sk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);
 	if (!sk)
 		break;
 
 	case SOCK_RAW:
 		break;
 	default:
 		return  ESOCKTNOSUPPORT;
 
 	switch (sock >type) {
 	case SOCK_RAW:
 		proto = &ieee802154_raw_prot;
 		ops = &ieee802154_raw_ops;
 		break;
 	    sock >type != SOCK_RAW)
 		return  ESOCKTNOSUPPORT;
 
 	if (sock >type == SOCK_RAW)
 		sock >ops = &llcp_rawsock_ops;
 	else
 		sock >ops = &llcp_sock_ops;
 
 	sk = nfc_llcp_sock_alloc(sock, sock >type, GFP_ATOMIC, kern);
 	if (sk == NULL)
After patch : 
 
 	if (sock >type != SOCK_RAW)
 		return  ESOCKTNOSUPPORT;
 	if (!capable(CAP_NET_RAW))
 		return  EPERM;
 
 	sk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);
 	if (!sk)
 	 */
 	if (sock >type != SOCK_RAW && sock >type != SOCK_DGRAM)
 		goto out;
 
 	rc =  EPERM;
 	if (sock >type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))
 		goto out;
 
 	rc =  ENOMEM;
 	sk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);
 	if (!sk)
 		break;
 
 	case SOCK_RAW:
 		if (!capable(CAP_NET_RAW))
 			return  EPERM;
 		break;
 	default:
 		return  ESOCKTNOSUPPORT;
 
 	switch (sock >type) {
 	case SOCK_RAW:
 		rc =  EPERM;
 		if (!capable(CAP_NET_RAW))
 			goto out;
 		proto = &ieee802154_raw_prot;
 		ops = &ieee802154_raw_ops;
 		break;
 	    sock >type != SOCK_RAW)
 		return  ESOCKTNOSUPPORT;
 
 	if (sock >type == SOCK_RAW) {
 		if (!capable(CAP_NET_RAW))
 			return  EPERM;
 		sock >ops = &llcp_rawsock_ops;
 	} else {
 		sock >ops = &llcp_sock_ops;
 	}
 
 	sk = nfc_llcp_sock_alloc(sock, sock >type, GFP_ATOMIC, kern);
 	if (sk == NULL)
