CVE Number : CVE-2016-4565
Commit Message : 
IB/security: Restrict use of the write() interface
Commit Details : 
The drivers/infiniband stack uses write() as a replacement for
bi-directional ioctl().  This is not safe. There are ways to
trigger write calls that result in the return structure that
is normally written to user space being shunted off to user
specified kernel memory instead.

For the immediate repair, detect and deny suspicious accesses to
the write API.

For long term, update the user space libraries and the kernel API
to something that doesn't present the same security vulnerabilities
(likely a structured ioctl() interface).

The impacted uAPI interfaces are generally only available if
hardware from drivers/infiniband is installed in the system.

Reported-by: Jann Horn <jann@thejh.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
 Expanded check to all known write() entry points 
Cc: stable@vger.kernel.org
Signed-off-by: Doug Ledford <dledford@redhat.com>

Before patch : 
 
 #include <asm/uaccess.h>
 
 #include <rdma/ib_cm.h>
 #include <rdma/ib_user_cm.h>
 #include <rdma/ib_marshall.h>
 	struct ib_ucm_cmd_hdr hdr;
 	ssize_t result;
 
 	if (len < sizeof(hdr))
 		return  EINVAL;
 
 	struct rdma_ucm_cmd_hdr hdr;
 	ssize_t ret;
 
 	if (len < sizeof(hdr))
 		return  EINVAL;
 
 
 #include <asm/uaccess.h>
 
 #include "uverbs.h"
 
 MODULE_AUTHOR("Roland Dreier");
 	int srcu_key;
 	ssize_t ret;
 
 	if (count < sizeof hdr)
 		return  EINVAL;
 
 #include <linux/export.h>
 #include <linux/uio.h>
 
 #include "qib.h"
 #include "qib_common.h"
 #include "qib_user_sdma.h"
 	ssize_t ret = 0;
 	void *dest;
 
 	if (count < sizeof(cmd.type)) {
 		ret =  EINVAL;
 		goto bail;
   Remove unneeded file entries in sysfs
   Remove software processing of IB protocol and place in library for use
   by qib, ipath (if still present), hfi1, and eventually soft roce
 
 #include <linux/vmalloc.h>
 #include <linux/io.h>
 
 #include "hfi.h"
 #include "pio.h"
 #include "device.h"
 	int uctxt_required = 1;
 	int must_be_root = 0;
 
 	if (count < sizeof(cmd)) {
 		ret =  EINVAL;
 		goto bail;
 #define _RDMA_IB_H
 
 #include <linux/types.h>
 
 struct ib_addr {
 	union {
 	__u64			sib_scope_id;
 };
 
 #endif /* _RDMA_IB_H */
After patch : 
 
 #include <asm/uaccess.h>
 
 #include <rdma/ib.h>
 #include <rdma/ib_cm.h>
 #include <rdma/ib_user_cm.h>
 #include <rdma/ib_marshall.h>
 	struct ib_ucm_cmd_hdr hdr;
 	ssize_t result;
 
 	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))
 		return  EACCES;
 
 	if (len < sizeof(hdr))
 		return  EINVAL;
 
 	struct rdma_ucm_cmd_hdr hdr;
 	ssize_t ret;
 
 	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))
 		return  EACCES;
 
 	if (len < sizeof(hdr))
 		return  EINVAL;
 
 
 #include <asm/uaccess.h>
 
 #include <rdma/ib.h>
 
 #include "uverbs.h"
 
 MODULE_AUTHOR("Roland Dreier");
 	int srcu_key;
 	ssize_t ret;
 
 	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))
 		return  EACCES;
 
 	if (count < sizeof hdr)
 		return  EINVAL;
 
 #include <linux/export.h>
 #include <linux/uio.h>
 
 #include <rdma/ib.h>
 
 #include "qib.h"
 #include "qib_common.h"
 #include "qib_user_sdma.h"
 	ssize_t ret = 0;
 	void *dest;
 
 	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))
 		return  EACCES;
 
 	if (count < sizeof(cmd.type)) {
 		ret =  EINVAL;
 		goto bail;
   Remove unneeded file entries in sysfs
   Remove software processing of IB protocol and place in library for use
   by qib, ipath (if still present), hfi1, and eventually soft roce
   Replace incorrect uAPI
 #include <linux/vmalloc.h>
 #include <linux/io.h>
 
 #include <rdma/ib.h>
 
 #include "hfi.h"
 #include "pio.h"
 #include "device.h"
 	int uctxt_required = 1;
 	int must_be_root = 0;
 
 	/* FIXME: This interface cannot continue out of staging */
 	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))
 		return  EACCES;
 
 	if (count < sizeof(cmd)) {
 		ret =  EINVAL;
 		goto bail;
 #define _RDMA_IB_H
 
 #include <linux/types.h>
 #include <linux/sched.h>
 
 struct ib_addr {
 	union {
 	__u64			sib_scope_id;
 };
 
 /*
  * The IB interfaces that use write() as bi directional ioctl() are
  * fundamentally unsafe, since there are lots of ways to trigger "write()"
  * calls from various contexts with elevated privileges. That includes the
  * traditional suid executable error message writes, but also various kernel
  * interfaces that can write to file descriptors.
  *
  * This function provides protection for the legacy API by restricting the
  * calling context.
  */
 static inline bool ib_safe_file_access(struct file *filp)
 {
 	return filp >f_cred == current_cred() && segment_eq(get_fs(), USER_DS);
 }
 
 #endif /* _RDMA_IB_H */
