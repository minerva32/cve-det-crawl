CVE Number : CVE-2019-13233
Commit Message : 
x86/insn-eval: Fix use-after-free access to LDT entry
Commit Details : 
get_desc() computes a pointer into the LDT while holding a lock that
protects the LDT from being freed, but then drops the lock and returns the
(now potentially dangling) pointer to its caller.

Fix it by giving the caller a copy of the LDT entry instead.

Fixes: 670f928ba09b ("x86/insn-eval: Add utility function to get segment descriptor")
Cc: stable@vger.kernel.org
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 }
 
 /**
  * get_desc()   Obtain pointer to a segment descriptor
  * @sel:	Segment selector
  *
  * Given a segment selector, obtain a pointer to the segment descriptor.
  *
  * Returns:
  *
  * Pointer to segment descriptor on success.
  *
  * NULL on error.
  */
 static struct desc_struct *get_desc(unsigned short sel)
 {
 	struct desc_ptr gdt_desc = {0, 0};
 	unsigned long desc_base;
 
 #ifdef CONFIG_MODIFY_LDT_SYSCALL
 	if ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {
 		struct desc_struct *desc = NULL;
 		struct ldt_struct *ldt;
 
 		/* Bits [15:3] contain the index of the desired entry. */
 
 		mutex_lock(&current >active_mm >context.lock);
 		ldt = current >active_mm >context.ldt;
 		if (ldt && sel < ldt >nr_entries)
 			desc = &ldt >entries[sel];
 
 		mutex_unlock(&current >active_mm >context.lock);
 
 		return desc;
 	}
 #endif
 	native_store_gdt(&gdt_desc);
 	desc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);
 
 	if (desc_base > gdt_desc.size)
 		return NULL;
 
 	return (struct desc_struct *)(gdt_desc.address   desc_base);
 }
 
 /**
  */
 unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
 {
 	struct desc_struct *desc;
 	short sel;
 
 	sel = get_segment_selector(regs, seg_reg_idx);
 	if (!sel)
 		return  1L;
 
 	desc = get_desc(sel);
 	if (!desc)
 		return  1L;
 
 	return get_desc_base(desc);
 }
 
 /**
  */
 static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
 {
 	struct desc_struct *desc;
 	unsigned long limit;
 	short sel;
 
 	if (!sel)
 		return 0;
 
 	desc = get_desc(sel);
 	if (!desc)
 		return 0;
 
 	/*
 	 * not tested when checking the segment limits. In practice,
 	 * this means that the segment ends in (limit << 12)   0xfff.
 	 */
 	limit = get_desc_limit(desc);
 	if (desc >g)
 		limit = (limit << 12)   0xfff;
 
 	return limit;
  */
 int insn_get_code_seg_params(struct pt_regs *regs)
 {
 	struct desc_struct *desc;
 	short sel;
 
 	if (v8086_mode(regs))
 	if (sel < 0)
 		return sel;
 
 	desc = get_desc(sel);
 	if (!desc)
 		return  EINVAL;
 
 	/*
 	 * determines whether a segment contains data or code. If this is a data
 	 * segment, return error.
 	 */
 	if (!(desc >type & BIT(3)))
 		return  EINVAL;
 
 	switch ((desc >l << 1) | desc >d) {
 	case 0: /*
 		 * Legacy mode. CS.L=0, CS.D=0. Address and operand size are
 		 * both 16 bit.
After patch : 
 }
 
 /**
  * get_desc()   Obtain contents of a segment descriptor
  * @out:	Segment descriptor contents on success
  * @sel:	Segment selector
  *
  * Given a segment selector, obtain a pointer to the segment descriptor.
  *
  * Returns:
  *
  * True on success, false on failure.
  *
  * NULL on error.
  */
 static bool get_desc(struct desc_struct *out, unsigned short sel)
 {
 	struct desc_ptr gdt_desc = {0, 0};
 	unsigned long desc_base;
 
 #ifdef CONFIG_MODIFY_LDT_SYSCALL
 	if ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {
 		bool success = false;
 		struct ldt_struct *ldt;
 
 		/* Bits [15:3] contain the index of the desired entry. */
 
 		mutex_lock(&current >active_mm >context.lock);
 		ldt = current >active_mm >context.ldt;
 		if (ldt && sel < ldt >nr_entries) {
 			*out = ldt >entries[sel];
 			success = true;
 		}
 
 		mutex_unlock(&current >active_mm >context.lock);
 
 		return success;
 	}
 #endif
 	native_store_gdt(&gdt_desc);
 	desc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);
 
 	if (desc_base > gdt_desc.size)
 		return false;
 
 	*out = *(struct desc_struct *)(gdt_desc.address   desc_base);
 	return true;
 }
 
 /**
  */
 unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
 {
 	struct desc_struct desc;
 	short sel;
 
 	sel = get_segment_selector(regs, seg_reg_idx);
 	if (!sel)
 		return  1L;
 
 	if (!get_desc(&desc, sel))
 		return  1L;
 
 	return get_desc_base(&desc);
 }
 
 /**
  */
 static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
 {
 	struct desc_struct desc;
 	unsigned long limit;
 	short sel;
 
 	if (!sel)
 		return 0;
 
 	if (!get_desc(&desc, sel))
 		return 0;
 
 	/*
 	 * not tested when checking the segment limits. In practice,
 	 * this means that the segment ends in (limit << 12)   0xfff.
 	 */
 	limit = get_desc_limit(&desc);
 	if (desc.g)
 		limit = (limit << 12)   0xfff;
 
 	return limit;
  */
 int insn_get_code_seg_params(struct pt_regs *regs)
 {
 	struct desc_struct desc;
 	short sel;
 
 	if (v8086_mode(regs))
 	if (sel < 0)
 		return sel;
 
 	if (!get_desc(&desc, sel))
 		return  EINVAL;
 
 	/*
 	 * determines whether a segment contains data or code. If this is a data
 	 * segment, return error.
 	 */
 	if (!(desc.type & BIT(3)))
 		return  EINVAL;
 
 	switch ((desc.l << 1) | desc.d) {
 	case 0: /*
 		 * Legacy mode. CS.L=0, CS.D=0. Address and operand size are
 		 * both 16 bit.
