CVE Number : CVE-2011-1476
Commit Message : 
sound/oss: remove offset from load_patch callbacks
Commit Details : 
Was: PATCH sound/oss/midi_synth: prevent underflow, use of
uninitialized value, and signedness issue

The offset passed to midi_synth_load_patch() can be essentially
arbitrary.  If it's greater than the header length, this will result in
a copy_from_user(dst, src, negative_val).  While this will just return
-EFAULT on x86, on other architectures this may cause memory corruption.
Additionally, the length field of the sysex_info structure may not be
initialized prior to its use.  Finally, a signed comparison may result
in an unintentionally large loop.

On suggestion by Takashi Iwai, version two removes the offset argument
from the load_patch callbacks entirely, which also resolves similar
issues in opl3.  Compile tested only.

v3 adjusts comments and hopefully gets copy offsets right.

Signed-off-by: Dan Rosenberg <drosenberg@vsecurity.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

Before patch : 
 	void (*reset) (int dev);
 	void (*hw_control) (int dev, unsigned char *event);
 	int (*load_patch) (int dev, int format, const char __user *addr,
 	     int offs, int count, int pmgr_flag);
 	void (*aftertouch) (int dev, int voice, int pressure);
 	void (*controller) (int dev, int voice, int ctrl_num, int value);
 	void (*panning) (int dev, int voice, int value);
 
 int
 midi_synth_load_patch(int dev, int format, const char __user *addr,
 		      int offs, int count, int pmgr_flag)
 {
 	int             orig_dev = synth_devs[dev] >midi_dev;
 
 	if (!prefix_cmd(orig_dev, 0xf0))
 		return 0;
 
 	if (format != SYSEX_PATCH)
 	{
 /*		  printk("MIDI Error: Invalid patch format (key) 0x%x\n", format);*/
 		  return  EINVAL;
 	}
 	if (count < hdr_size)
 	{
 /*		printk("MIDI Error: Patch header too short\n");*/
 		return  EINVAL;
 	}
 	count  = hdr_size;
 
 	/*
 	 * Copy the header from user space but ignore the first bytes which have
 	 * been transferred already.
 	 */
 
 	if(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size   offs))
 		return  EFAULT;
  
  	if (count < sysex.len)
 	{
 /*		printk(KERN_WARNING "MIDI Warning: Sysex record too short (%d<%d)\n", count, (int) sysex.len);*/
 		sysex.len = count;
 	}
   	left = sysex.len;
   	src_offs = 0;
 
 	for (i = 0; i < left && !signal_pending(current); i  )
 	{
 void midi_synth_close (int dev);
 void midi_synth_hw_control (int dev, unsigned char *event);
 int midi_synth_load_patch (int dev, int format, const char __user * addr,
 		 int offs, int count, int pmgr_flag);
 void midi_synth_panning (int dev, int channel, int pressure);
 void midi_synth_aftertouch (int dev, int channel, int pressure);
 void midi_synth_controller (int dev, int channel, int ctrl_num, int value);
 }
 
 static int opl3_load_patch(int dev, int format, const char __user *addr,
 		int offs, int count, int pmgr_flag)
 {
 	struct sbi_instrument ins;
 
 		return  EINVAL;
 	}
 
 	/*
 	 * What the fuck is going on here?  We leave junk in the beginning
 	 * of ins and then check the field pretty close to that beginning?
 	 */
 	if(copy_from_user(&((char *) &ins)[offs], addr   offs, sizeof(ins)   offs))
 		return  EFAULT;
 
 	if (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)
 				return  ENXIO;
 
 			fmt = (*(short *) &event_rec[0]) & 0xffff;
 			err = synth_devs[dev] >load_patch(dev, fmt, buf, p   4, c, 0);
 			if (err < 0)
 				return err;
 
After patch : 
 	void (*reset) (int dev);
 	void (*hw_control) (int dev, unsigned char *event);
 	int (*load_patch) (int dev, int format, const char __user *addr,
 	     int count, int pmgr_flag);
 	void (*aftertouch) (int dev, int voice, int pressure);
 	void (*controller) (int dev, int voice, int ctrl_num, int value);
 	void (*panning) (int dev, int voice, int value);
 
 int
 midi_synth_load_patch(int dev, int format, const char __user *addr,
 		      int count, int pmgr_flag)
 {
 	int             orig_dev = synth_devs[dev] >midi_dev;
 
 	if (!prefix_cmd(orig_dev, 0xf0))
 		return 0;
 
 	/* Invalid patch format */
 	if (format != SYSEX_PATCH)
 		  return  EINVAL;
 
 	/* Patch header too short */
 	if (count < hdr_size)
 		return  EINVAL;
 
 	count  = hdr_size;
 
 	/*
 	 * Copy the header from user space
 	 */
 
 	if (copy_from_user(&sysex, addr, hdr_size))
 		return  EFAULT;
 
 	/* Sysex record too short */
 	if ((unsigned)count < (unsigned)sysex.len)
 		sysex.len = count;
 
 	left = sysex.len;
 	src_offs = 0;
 
 	for (i = 0; i < left && !signal_pending(current); i  )
 	{
 void midi_synth_close (int dev);
 void midi_synth_hw_control (int dev, unsigned char *event);
 int midi_synth_load_patch (int dev, int format, const char __user * addr,
 		 int count, int pmgr_flag);
 void midi_synth_panning (int dev, int channel, int pressure);
 void midi_synth_aftertouch (int dev, int channel, int pressure);
 void midi_synth_controller (int dev, int channel, int ctrl_num, int value);
 }
 
 static int opl3_load_patch(int dev, int format, const char __user *addr,
 		int count, int pmgr_flag)
 {
 	struct sbi_instrument ins;
 
 		return  EINVAL;
 	}
 
 	if (copy_from_user(&ins, addr, sizeof(ins)))
 		return  EFAULT;
 
 	if (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)
 				return  ENXIO;
 
 			fmt = (*(short *) &event_rec[0]) & 0xffff;
 			err = synth_devs[dev] >load_patch(dev, fmt, buf   p, c, 0);
 			if (err < 0)
 				return err;
 
