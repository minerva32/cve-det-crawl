CVE Number : CVE-2012-3400
Commit Message : 
udf: Avoid run away loop when partition table length is corrupted
Commit Details : 
Check provided length of partition table so that (possibly maliciously)
corrupted partition table cannot cause accessing data beyond current buffer.

Signed-off-by: Jan Kara <jack@suse.cz>

Before patch : 
 	struct genericPartitionMap *gpm;
 	uint16_t ident;
 	struct buffer_head *bh;
 	int ret = 0;
 
 	bh = udf_read_tagged(sb, block, block, &ident);
 		return 1;
 	BUG_ON(ident != TAG_IDENT_LVD);
 	lvd = (struct logicalVolDesc *)bh >b_data;
 
 	ret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd >numPartitionMaps));
 	if (ret)
 		goto out_bh;
 
 	for (i = 0, offset = 0;
 	     i < sbi >s_partitions && offset < le32_to_cpu(lvd >mapTableLength);
 	     i  , offset  = gpm >partitionMapLength) {
 		struct udf_part_map *map = &sbi >s_partmaps[i];
 		gpm = (struct genericPartitionMap *)
After patch : 
 	struct genericPartitionMap *gpm;
 	uint16_t ident;
 	struct buffer_head *bh;
 	unsigned int table_len;
 	int ret = 0;
 
 	bh = udf_read_tagged(sb, block, block, &ident);
 		return 1;
 	BUG_ON(ident != TAG_IDENT_LVD);
 	lvd = (struct logicalVolDesc *)bh >b_data;
 	table_len = le32_to_cpu(lvd >mapTableLength);
 	if (sizeof(*lvd)   table_len > sb >s_blocksize) {
 		udf_err(sb, "error loading logical volume descriptor: "
 			"Partition table too long (%u > %lu)\n", table_len,
 			sb >s_blocksize   sizeof(*lvd));
 		goto out_bh;
 	}
 
 	ret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd >numPartitionMaps));
 	if (ret)
 		goto out_bh;
 
 	for (i = 0, offset = 0;
 	     i < sbi >s_partitions && offset < table_len;
 	     i  , offset  = gpm >partitionMapLength) {
 		struct udf_part_map *map = &sbi >s_partmaps[i];
 		gpm = (struct genericPartitionMap *)
