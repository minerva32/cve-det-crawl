CVE Number : CVE-2014-9730
Commit Message : 
udf: Check component length before reading it
Commit Details : 
Check that length specified in a component of a symlink fits in the
input buffer we are reading. Also properly ignore component length for
component types that do not use it. Otherwise we read memory after end
of buffer for corrupted udf image.

Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
CC: stable@vger.kernel.org
Signed-off-by: Jan Kara <jack@suse.cz>

Before patch : 
 	tolen  ;
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from   elen);
 		switch (pc >componentType) {
 		case 1:
 			/*
 			 * Symlink points to some place which should be agreed
  			 * upon between originator and receiver of the media. Ignore.
 			 */
 			if (pc >lengthComponentIdent > 0)
 				break;
 			/* Fall through */
 		case 2:
 			if (tolen == 0)
 			/* that would be .   just ignore */
 			break;
 		case 5:
 			comp_len = udf_get_filename(sb, pc >componentIdent,
 						    pc >lengthComponentIdent,
 						    p, tolen);
 			tolen  ;
 			break;
 		}
 		elen  = sizeof(struct pathComponent)   pc >lengthComponentIdent;
 	}
 	if (p > to   1)
 		p[ 1] = '\0';
After patch : 
 	tolen  ;
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from   elen);
 		elen  = sizeof(struct pathComponent);
 		switch (pc >componentType) {
 		case 1:
 			/*
 			 * Symlink points to some place which should be agreed
  			 * upon between originator and receiver of the media. Ignore.
 			 */
 			if (pc >lengthComponentIdent > 0) {
 				elen  = pc >lengthComponentIdent;
 				break;
 			}
 			/* Fall through */
 		case 2:
 			if (tolen == 0)
 			/* that would be .   just ignore */
 			break;
 		case 5:
 			elen  = pc >lengthComponentIdent;
 			if (elen > fromlen)
 				return  EIO;
 			comp_len = udf_get_filename(sb, pc >componentIdent,
 						    pc >lengthComponentIdent,
 						    p, tolen);
 			tolen  ;
 			break;
 		}
 	}
 	if (p > to   1)
 		p[ 1] = '\0';
