CVE Number : CVE-2010-4162
Commit Message : 
bio: take care not overflow page count when mapping/copying user data
Commit Details : 
If the iovec is being set up in a way that causes uaddr + PAGE_SIZE
to overflow, we could end up attempting to map a huge number of
pages. Check for this invalid input type.

Reported-by: Dan Rosenberg <drosenberg@vsecurity.com>
Cc: stable@kernel.org
Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

Before patch : 
 		end = (uaddr   iov[i].iov_len   PAGE_SIZE   1) >> PAGE_SHIFT;
 		start = uaddr >> PAGE_SHIFT;
 
 		nr_pages  = end   start;
 		len  = iov[i].iov_len;
 	}
 		unsigned long end = (uaddr   len   PAGE_SIZE   1) >> PAGE_SHIFT;
 		unsigned long start = uaddr >> PAGE_SHIFT;
 
 		nr_pages  = end   start;
 		/*
 		 * buffer must be aligned to at least hardsector size for now
 		unsigned long start = uaddr >> PAGE_SHIFT;
 		const int local_nr_pages = end   start;
 		const int page_limit = cur_page   local_nr_pages;
 		
 		ret = get_user_pages_fast(uaddr, local_nr_pages,
 				write_to_vm, &pages[cur_page]);
 		if (ret < local_nr_pages) {
After patch : 
 		end = (uaddr   iov[i].iov_len   PAGE_SIZE   1) >> PAGE_SHIFT;
 		start = uaddr >> PAGE_SHIFT;
 
 		/*
 		 * Overflow, abort
 		 */
 		if (end < start)
 			return ERR_PTR( EINVAL);
 
 		nr_pages  = end   start;
 		len  = iov[i].iov_len;
 	}
 		unsigned long end = (uaddr   len   PAGE_SIZE   1) >> PAGE_SHIFT;
 		unsigned long start = uaddr >> PAGE_SHIFT;
 
 		/*
 		 * Overflow, abort
 		 */
 		if (end < start)
 			return ERR_PTR( EINVAL);
 
 		nr_pages  = end   start;
 		/*
 		 * buffer must be aligned to at least hardsector size for now
 		unsigned long start = uaddr >> PAGE_SHIFT;
 		const int local_nr_pages = end   start;
 		const int page_limit = cur_page   local_nr_pages;
 
 		ret = get_user_pages_fast(uaddr, local_nr_pages,
 				write_to_vm, &pages[cur_page]);
 		if (ret < local_nr_pages) {
