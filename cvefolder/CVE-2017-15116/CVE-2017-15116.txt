CVE Number : CVE-2017-15116
Commit Message : 
crypto: rng - Remove old low-level rng interface
Commit Details : 
Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

Before patch : 
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
 	return container_of(tfm, struct crypto_rng, base);
 }
 
 static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)
 {
 	return &crypto_rng_tfm(tfm) >__crt_alg >cra_rng;
 }
 
 static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,
 		    u8 *dst, unsigned int dlen)
 {
 	return crypto_old_rng_alg(tfm) >rng_make_random(tfm, dst, dlen);
 }
 
 static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,
 			unsigned int slen)
 {
 	u8 *buf = NULL;
 	u8 *src = (u8 *)seed;
 	int err;
 
 	if (slen) {
 		buf = kmalloc(slen, GFP_KERNEL);
 		if (!buf)
 			return  ENOMEM;
 
 		memcpy(buf, seed, slen);
 		src = buf;
 	}
 
 	err = crypto_old_rng_alg(tfm) >rng_reset(tfm, src, slen);
 
 	kzfree(buf);
 	return err;
 }
 
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
 		seed = buf;
 	}
 
 	err = tfm >seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
 	struct crypto_rng *rng = __crypto_rng_cast(tfm);
 	struct rng_alg *alg = crypto_rng_alg(rng);
 	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
 
 	if (oalg >rng_make_random) {
 		rng >generate = generate;
 		rng >seed = rngapi_reset;
 		rng >seedsize = oalg >seedsize;
 		return 0;
 	}
 
 	rng >generate = alg >generate;
 	rng >seed = alg >seed;
 	rng >seedsize = alg >seedsize;
 
 	return 0;
 }
 
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
 	return alg >cra_rng.rng_make_random ?
 	       alg >cra_rng.seedsize : ralg >seedsize;
 }
 
 #ifdef CONFIG_NET
 	seq_printf(m, "seedsize     : %u\n", seedsize(alg));
 }
 
 const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
 EXPORT_SYMBOL_GPL(crypto_rng_type);
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {
  * RNG: Random Number Generator  algorithms under the crypto API
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
 #include <crypto/algapi.h>
 #include <crypto/rng.h>
 
 extern const struct crypto_type crypto_rng_type;
 
 int crypto_register_rng(struct rng_alg *alg);
 void crypto_unregister_rng(struct rng_alg *alg);
 int crypto_register_rngs(struct rng_alg *algs, int count);
  * RNG: Random Number Generator  algorithms under the crypto API
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
 };
 
 struct crypto_rng {
 	int (*generate)(struct crypto_rng *tfm,
 			const u8 *src, unsigned int slen,
 			u8 *dst, unsigned int dlen);
 	int (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);
 	unsigned int seedsize;
 	struct crypto_tfm base;
 };
 
 				      const u8 *src, unsigned int slen,
 				      u8 *dst, unsigned int dlen)
 {
 	return tfm >generate(tfm, src, slen, dst, dlen);
 }
 
 /**
  */
 static inline int crypto_rng_seedsize(struct crypto_rng *tfm)
 {
 	return tfm >seedsize;
 }
 
 #endif
 struct crypto_aead;
 struct crypto_blkcipher;
 struct crypto_hash;
 struct crypto_rng;
 struct crypto_tfm;
 struct crypto_type;
 struct aead_givcrypt_request;
 			      unsigned int slen, u8 *dst, unsigned int *dlen);
 };
 
 /**
  * struct old_rng_alg   random number generator definition
  * @rng_make_random: The function defined by this variable obtains a random
  *		     number. The random number generator transform must generate
  *		     the random number out of the context provided with this
  *		     call.
  * @rng_reset: Reset of the random number generator by clearing the entire state.
  *	       With the invocation of this function call, the random number
  *             generator shall completely reinitialize its state. If the random
  *	       number generator requires a seed for setting up a new state,
  *	       the seed must be provided by the consumer while invoking this
  *	       function. The required size of the seed is defined with
  *	       @seedsize .
  * @seedsize: The seed size required for a random number generator
  *	      initialization defined with this variable. Some random number
  *	      generators like the SP800 90A DRBG does not require a seed as the
  *	      seeding is implemented internally without the need of support by
  *	      the consumer. In this case, the seed size is set to zero.
  */
 struct old_rng_alg {
 	int (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,
 			       unsigned int dlen);
 	int (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);
 
 	unsigned int seedsize;
 };
 
 
 #define cra_ablkcipher	cra_u.ablkcipher
 #define cra_aead	cra_u.aead
 #define cra_blkcipher	cra_u.blkcipher
 #define cra_cipher	cra_u.cipher
 #define cra_compress	cra_u.compress
 #define cra_rng		cra_u.rng
 
 /**
  * struct crypto_alg   definition of a cryptograpic cipher algorithm
 		struct blkcipher_alg blkcipher;
 		struct cipher_alg cipher;
 		struct compress_alg compress;
 		struct old_rng_alg rng;
 	} cra_u;
 
 	int (*cra_init)(struct crypto_tfm *tfm);
After patch : 
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
  * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
 	return container_of(tfm, struct crypto_rng, base);
 }
 
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
 		seed = buf;
 	}
 
 	err = crypto_rng_alg(tfm) >seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
 	return 0;
 }
 
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
 	return ralg >seedsize;
 }
 
 #ifdef CONFIG_NET
 	seq_printf(m, "seedsize     : %u\n", seedsize(alg));
 }
 
 static const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {
  * RNG: Random Number Generator  algorithms under the crypto API
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
  * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
 #include <crypto/algapi.h>
 #include <crypto/rng.h>
 
 int crypto_register_rng(struct rng_alg *alg);
 void crypto_unregister_rng(struct rng_alg *alg);
 int crypto_register_rngs(struct rng_alg *algs, int count);
  * RNG: Random Number Generator  algorithms under the crypto API
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
  * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
 };
 
 struct crypto_rng {
 	struct crypto_tfm base;
 };
 
 				      const u8 *src, unsigned int slen,
 				      u8 *dst, unsigned int dlen)
 {
 	return crypto_rng_alg(tfm) >generate(tfm, src, slen, dst, dlen);
 }
 
 /**
  */
 static inline int crypto_rng_seedsize(struct crypto_rng *tfm)
 {
 	return crypto_rng_alg(tfm) >seedsize;
 }
 
 #endif
 struct crypto_aead;
 struct crypto_blkcipher;
 struct crypto_hash;
 struct crypto_tfm;
 struct crypto_type;
 struct aead_givcrypt_request;
 			      unsigned int slen, u8 *dst, unsigned int *dlen);
 };
 
 
 #define cra_ablkcipher	cra_u.ablkcipher
 #define cra_aead	cra_u.aead
 #define cra_blkcipher	cra_u.blkcipher
 #define cra_cipher	cra_u.cipher
 #define cra_compress	cra_u.compress
 
 /**
  * struct crypto_alg   definition of a cryptograpic cipher algorithm
 		struct blkcipher_alg blkcipher;
 		struct cipher_alg cipher;
 		struct compress_alg compress;
 	} cra_u;
 
 	int (*cra_init)(struct crypto_tfm *tfm);
