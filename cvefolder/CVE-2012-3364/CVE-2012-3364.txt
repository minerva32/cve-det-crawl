CVE Number : CVE-2012-3364
Commit Message : 
NFC: Prevent multiple buffer overflows in NCI
Commit Details : 
Fix multiple remotely-exploitable stack-based buffer overflows due to
the NCI code pulling length fields directly from incoming frames and
copying too much data into statically-sized arrays.

Signed-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>
Cc: stable@kernel.org
Cc: security@kernel.org
Cc: Lauro Ramos Venancio <lauro.venancio@openbossa.org>
Cc: Aloisio Almeida Jr <aloisio.almeida@openbossa.org>
Cc: Samuel Ortiz <sameo@linux.intel.com>
Cc: David S. Miller <davem@davemloft.net>
Acked-by: Ilan Elias <ilane@ti.com>
Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

Before patch : 
 	nfca_poll >sens_res = __le16_to_cpu(*((__u16 *)data));
 	data  = 2;
 
 	nfca_poll >nfcid1_len = *data  ;
 
 	pr_debug("sens_res 0x%x, nfcid1_len %d\n",
 		 nfca_poll >sens_res, nfca_poll >nfcid1_len);
 			struct rf_tech_specific_params_nfcb_poll *nfcb_poll,
 						     __u8 *data)
 {
 	nfcb_poll >sensb_res_len = *data  ;
 
 	pr_debug("sensb_res_len %d\n", nfcb_poll >sensb_res_len);
 
 						     __u8 *data)
 {
 	nfcf_poll >bit_rate = *data  ;
 	nfcf_poll >sensf_res_len = *data  ;
 
 	pr_debug("bit_rate %d, sensf_res_len %d\n",
 		 nfcf_poll >bit_rate, nfcf_poll >sensf_res_len);
 	switch (ntf >activation_rf_tech_and_mode) {
 	case NCI_NFC_A_PASSIVE_POLL_MODE:
 		nfca_poll = &ntf >activation_params.nfca_poll_iso_dep;
 		nfca_poll >rats_res_len = *data  ;
 		pr_debug("rats_res_len %d\n", nfca_poll >rats_res_len);
 		if (nfca_poll >rats_res_len > 0) {
 			memcpy(nfca_poll >rats_res,
 
 	case NCI_NFC_B_PASSIVE_POLL_MODE:
 		nfcb_poll = &ntf >activation_params.nfcb_poll_iso_dep;
 		nfcb_poll >attrib_res_len = *data  ;
 		pr_debug("attrib_res_len %d\n", nfcb_poll >attrib_res_len);
 		if (nfcb_poll >attrib_res_len > 0) {
 			memcpy(nfcb_poll >attrib_res,
After patch : 
 	nfca_poll >sens_res = __le16_to_cpu(*((__u16 *)data));
 	data  = 2;
 
 	nfca_poll >nfcid1_len = min_t(__u8, *data  , NFC_NFCID1_MAXSIZE);
 
 	pr_debug("sens_res 0x%x, nfcid1_len %d\n",
 		 nfca_poll >sens_res, nfca_poll >nfcid1_len);
 			struct rf_tech_specific_params_nfcb_poll *nfcb_poll,
 						     __u8 *data)
 {
 	nfcb_poll >sensb_res_len = min_t(__u8, *data  , NFC_SENSB_RES_MAXSIZE);
 
 	pr_debug("sensb_res_len %d\n", nfcb_poll >sensb_res_len);
 
 						     __u8 *data)
 {
 	nfcf_poll >bit_rate = *data  ;
 	nfcf_poll >sensf_res_len = min_t(__u8, *data  , NFC_SENSF_RES_MAXSIZE);
 
 	pr_debug("bit_rate %d, sensf_res_len %d\n",
 		 nfcf_poll >bit_rate, nfcf_poll >sensf_res_len);
 	switch (ntf >activation_rf_tech_and_mode) {
 	case NCI_NFC_A_PASSIVE_POLL_MODE:
 		nfca_poll = &ntf >activation_params.nfca_poll_iso_dep;
 		nfca_poll >rats_res_len = min_t(__u8, *data  , 20);
 		pr_debug("rats_res_len %d\n", nfca_poll >rats_res_len);
 		if (nfca_poll >rats_res_len > 0) {
 			memcpy(nfca_poll >rats_res,
 
 	case NCI_NFC_B_PASSIVE_POLL_MODE:
 		nfcb_poll = &ntf >activation_params.nfcb_poll_iso_dep;
 		nfcb_poll >attrib_res_len = min_t(__u8, *data  , 50);
 		pr_debug("attrib_res_len %d\n", nfcb_poll >attrib_res_len);
 		if (nfcb_poll >attrib_res_len > 0) {
 			memcpy(nfcb_poll >attrib_res,
