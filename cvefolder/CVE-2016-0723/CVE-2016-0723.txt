CVE Number : CVE-2016-0723
Commit Message : 
tty: Fix unsafe ldisc reference via ioctl(TIOCGETD)
Commit Details : 
ioctl(TIOCGETD) retrieves the line discipline id directly from the
ldisc because the line discipline id (c_line) in termios is untrustworthy;
userspace may have set termios via ioctl(TCSETS*) without actually
changing the line discipline via ioctl(TIOCSETD).

However, directly accessing the current ldisc via tty->ldisc is
unsafe; the ldisc ptr dereferenced may be stale if the line discipline
is changing via ioctl(TIOCSETD) or hangup.

Wait for the line discipline reference (just like read() or write())
to retrieve the "current" line discipline id.

Cc: <stable@vger.kernel.org>
Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Before patch : 
 }
 
 /**
  *	send_break	 	performed time break
  *	@tty: device to break on
  *	@duration: timeout in mS
 	case TIOCGSID:
 		return tiocgsid(tty, real_tty, p);
 	case TIOCGETD:
 		return put_user(tty >ldisc >ops >num, (int __user *)p);
 	case TIOCSETD:
 		return tiocsetd(tty, p);
 	case TIOCVHANGUP:
After patch : 
 }
 
 /**
  *	tiocgetd	 	get line discipline
  *	@tty: tty device
  *	@p: pointer to user data
  *
  *	Retrieves the line discipline id directly from the ldisc.
  *
  *	Locking: waits for ldisc reference (in case the line discipline
  *		is changing or the tty is being hungup)
  */
 
 static int tiocgetd(struct tty_struct *tty, int __user *p)
 {
 	struct tty_ldisc *ld;
 	int ret;
 
 	ld = tty_ldisc_ref_wait(tty);
 	ret = put_user(ld >ops >num, p);
 	tty_ldisc_deref(ld);
 	return ret;
 }
 
 /**
  *	send_break	 	performed time break
  *	@tty: device to break on
  *	@duration: timeout in mS
 	case TIOCGSID:
 		return tiocgsid(tty, real_tty, p);
 	case TIOCGETD:
 		return tiocgetd(tty, p);
 	case TIOCSETD:
 		return tiocsetd(tty, p);
 	case TIOCVHANGUP:
