CVE Number : CVE-2012-6704
Commit Message : 
net: cleanups in sock_setsockopt()
Commit Details : 
Use min_t()/max_t() macros, reformat two comments, use !!test_bit() to
match !!sock_flag()

Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 		break;
 	case SO_SNDBUF:
 		/* Don't error on this BSD doesn't and if you think
 		   about it this is right. Otherwise apps have to
 		   play 'guess the biggest size' games. RCVBUF/SNDBUF
 		   are treated in BSD as hints */
 
 		if (val > sysctl_wmem_max)
 			val = sysctl_wmem_max;
 set_sndbuf:
 		sk >sk_userlocks |= SOCK_SNDBUF_LOCK;
 		if ((val * 2) < SOCK_MIN_SNDBUF)
 			sk >sk_sndbuf = SOCK_MIN_SNDBUF;
 		else
 			sk >sk_sndbuf = val * 2;
 
 		/*
 		 *	Wake up sending tasks if we
 		 *	upped the value.
 		 */
 		sk >sk_write_space(sk);
 		break;
 
 
 	case SO_RCVBUF:
 		/* Don't error on this BSD doesn't and if you think
 		   about it this is right. Otherwise apps have to
 		   play 'guess the biggest size' games. RCVBUF/SNDBUF
 		   are treated in BSD as hints */
 
 		if (val > sysctl_rmem_max)
 			val = sysctl_rmem_max;
 set_rcvbuf:
 		sk >sk_userlocks |= SOCK_RCVBUF_LOCK;
 		/*
 		 * returning the value we actually used in getsockopt
 		 * is the most desirable behavior.
 		 */
 		if ((val * 2) < SOCK_MIN_RCVBUF)
 			sk >sk_rcvbuf = SOCK_MIN_RCVBUF;
 		else
 			sk >sk_rcvbuf = val * 2;
 		break;
 
 	case SO_RCVBUFFORCE:
 		break;
 
 	case SO_PASSCRED:
 		v.val = test_bit(SOCK_PASSCRED, &sock >flags) ? 1 : 0;
 		break;
 
 	case SO_PEERCRED:
 		break;
 
 	case SO_PASSSEC:
 		v.val = test_bit(SOCK_PASSSEC, &sock >flags) ? 1 : 0;
 		break;
 
 	case SO_PEERSEC:
After patch : 
 		break;
 	case SO_SNDBUF:
 		/* Don't error on this BSD doesn't and if you think
 		 * about it this is right. Otherwise apps have to
 		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
 		 * are treated in BSD as hints
 		 */
 		val = min_t(u32, val, sysctl_wmem_max);
 set_sndbuf:
 		sk >sk_userlocks |= SOCK_SNDBUF_LOCK;
 		sk >sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
 		/* Wake up sending tasks if we upped the value. */
 		sk >sk_write_space(sk);
 		break;
 
 
 	case SO_RCVBUF:
 		/* Don't error on this BSD doesn't and if you think
 		 * about it this is right. Otherwise apps have to
 		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
 		 * are treated in BSD as hints
 		 */
 		val = min_t(u32, val, sysctl_rmem_max);
 set_rcvbuf:
 		sk >sk_userlocks |= SOCK_RCVBUF_LOCK;
 		/*
 		 * returning the value we actually used in getsockopt
 		 * is the most desirable behavior.
 		 */
 		sk >sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
 		break;
 
 	case SO_RCVBUFFORCE:
 		break;
 
 	case SO_PASSCRED:
 		v.val = !!test_bit(SOCK_PASSCRED, &sock >flags);
 		break;
 
 	case SO_PEERCRED:
 		break;
 
 	case SO_PASSSEC:
 		v.val = !!test_bit(SOCK_PASSSEC, &sock >flags);
 		break;
 
 	case SO_PEERSEC:
