CVE Number : CVE-2020-14386
Commit Message : 
net/packet: fix overflow in tpacket_rcv
Commit Details : 
Using tp_reserve to calculate netoff can overflow as
tp_reserve is unsigned int and netoff is unsigned short.

This may lead to macoff receving a smaller value then
sizeof(struct virtio_net_hdr), and if po->has_vnet_hdr
is set, an out-of-bounds write will occur when
calling virtio_net_hdr_from_skb.

The bug is fixed by converting netoff to unsigned int
and checking if it exceeds USHRT_MAX.

This addresses CVE-2020-14386

Fixes: 8913336a7e8d ("packet: add PACKET_RESERVE sockopt")
Signed-off-by: Or Cohen <orcohen@paloaltonetworks.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 	int skb_len = skb >len;
 	unsigned int snaplen, res;
 	unsigned long status = TP_STATUS_USER;
 	unsigned short macoff, netoff, hdrlen;
 	struct sk_buff *copy_skb = NULL;
 	struct timespec64 ts;
 	__u32 ts_status;
 		}
 		macoff = netoff   maclen;
 	}
 	if (po >tp_version <= TPACKET_V2) {
 		if (macoff   snaplen > po >rx_ring.frame_size) {
 			if (po >copy_thresh &&
After patch : 
 	int skb_len = skb >len;
 	unsigned int snaplen, res;
 	unsigned long status = TP_STATUS_USER;
 	unsigned short macoff, hdrlen;
 	unsigned int netoff;
 	struct sk_buff *copy_skb = NULL;
 	struct timespec64 ts;
 	__u32 ts_status;
 		}
 		macoff = netoff   maclen;
 	}
 	if (netoff > USHRT_MAX) {
 		atomic_inc(&po >tp_drops);
 		goto drop_n_restore;
 	}
 	if (po >tp_version <= TPACKET_V2) {
 		if (macoff   snaplen > po >rx_ring.frame_size) {
 			if (po >copy_thresh &&
