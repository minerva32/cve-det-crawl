CVE Number : CVE-2011-4621
Commit Message : 
Sched: fix skip_clock_update optimization
Commit Details : 
idle_balance() drops/retakes rq->lock, leaving the previous task
vulnerable to set_tsk_need_resched().  Clear it after we return
from balancing instead, and in setup_thread_stack() as well, so
no successfully descheduled or never scheduled task has it set.

Need resched confused the skip_clock_update logic, which assumes
that the next call to update_rq_clock() will come nearly immediately
after being set.  Make the optimization robust against the waking
a sleeper before it sucessfully deschedules case by checking that
the current task has not been dequeued before setting the flag,
since it is that useless clock update we're trying to save, and
clear unconditionally in schedule() proper instead of conditionally
in put_prev_task().

Signed-off-by: Mike Galbraith <efault@gmx.de>
Reported-by: Bjoern B. Brandenburg <bbb.lst@gmail.com>
Tested-by: Yong Zhang <yong.zhang0@gmail.com>
Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: stable@kernel.org
LKML-Reference: <1291802742.1417.9.camel@marge.simson.net>
Signed-off-by: Ingo Molnar <mingo@elte.hu>

Before patch : 
 
 	setup_thread_stack(tsk, orig);
 	clear_user_return_notifier(tsk);
 	stackend = end_of_stack(tsk);
 	*stackend = STACK_END_MAGIC;	/* for overflow detection */
 
 
 inline void update_rq_clock(struct rq *rq)
 {
 	if (!rq >skip_clock_update) {
 		int cpu = cpu_of(rq);
 		u64 irq_time;
 
 		rq >clock = sched_clock_cpu(cpu);
 		irq_time = irq_time_cpu(cpu);
 		if (rq >clock   irq_time > rq >clock_task)
 			rq >clock_task = rq >clock   irq_time;
 
 		sched_irq_time_avg_update(rq, irq_time);
 	}
 }
 
 /*
 	 * A queue event has occurred, and we're going to schedule.  In
 	 * this case, we can save a useless back to back clock update.
 	 */
 	if (test_tsk_need_resched(rq >curr))
 		rq >skip_clock_update = 1;
 }
 
 {
 	if (prev >se.on_rq)
 		update_rq_clock(rq);
 	rq >skip_clock_update = 0;
 	prev >sched_class >put_prev_task(rq, prev);
 }
 
 		hrtick_clear(rq);
 
 	raw_spin_lock_irq(&rq >lock);
 	clear_tsk_need_resched(prev);
 
 	switch_count = &prev >nivcsw;
 	if (prev >state && !(preempt_count() & PREEMPT_ACTIVE)) {
 
 	put_prev_task(rq, prev);
 	next = pick_next_task(rq);
 
 	if (likely(prev != next)) {
 		sched_info_switch(prev, next);
 		rq >nr_switches  ;
 		rq >curr = next;
 		  *switch_count;
 
 		context_switch(rq, prev, next); /* unlocks the rq */
 		/*
After patch : 
 
 	setup_thread_stack(tsk, orig);
 	clear_user_return_notifier(tsk);
 	clear_tsk_need_resched(tsk);
 	stackend = end_of_stack(tsk);
 	*stackend = STACK_END_MAGIC;	/* for overflow detection */
 
 
 inline void update_rq_clock(struct rq *rq)
 {
 	int cpu = cpu_of(rq);
 	u64 irq_time;
 
 	if (rq >skip_clock_update)
 		return;
 
 	rq >clock = sched_clock_cpu(cpu);
 	irq_time = irq_time_cpu(cpu);
 	if (rq >clock   irq_time > rq >clock_task)
 		rq >clock_task = rq >clock   irq_time;
 
 	sched_irq_time_avg_update(rq, irq_time);
 }
 
 /*
 	 * A queue event has occurred, and we're going to schedule.  In
 	 * this case, we can save a useless back to back clock update.
 	 */
 	if (rq >curr >se.on_rq && test_tsk_need_resched(rq >curr))
 		rq >skip_clock_update = 1;
 }
 
 {
 	if (prev >se.on_rq)
 		update_rq_clock(rq);
 	prev >sched_class >put_prev_task(rq, prev);
 }
 
 		hrtick_clear(rq);
 
 	raw_spin_lock_irq(&rq >lock);
 
 	switch_count = &prev >nivcsw;
 	if (prev >state && !(preempt_count() & PREEMPT_ACTIVE)) {
 
 	put_prev_task(rq, prev);
 	next = pick_next_task(rq);
 	clear_tsk_need_resched(prev);
 	rq >skip_clock_update = 0;
 
 	if (likely(prev != next)) {
 		sched_info_switch(prev, next);
 		rq >nr_switches  ;
 		rq >curr = next;
 		  *switch_count;
 		WARN_ON_ONCE(test_tsk_need_resched(next));
 
 		context_switch(rq, prev, next); /* unlocks the rq */
 		/*
