CVE Number : CVE-2005-4886
Commit Message : 
SELINUX: Fix ipv6_skip_exthdr() invocation causing OOPS.
Commit Details : 
The SELinux hooks invoke ipv6_skip_exthdr() with an incorrect
length final argument.  However, the length argument turns out
to be superfluous.

I was just reading ipv6_skip_exthdr and it occured to me that we can
get rid of len altogether.  The only place where len is used is to
check whether the skb has two bytes for ipv6_opt_hdr.  This check
is done by skb_header_pointer/skb_copy_bits anyway.

Now it might appear that we've made the code slower by deferring
the check to skb_copy_bits.  However, this check should not trigger
in the common case so this is OK.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 						    u8 *proto);
 
 extern int			ipv6_skip_exthdr(const struct sk_buff *, int start,
 					         u8 *nexthdrp, int len);
 
 extern int 			ipv6_ext_hdr(u8 nexthdr);
 
  * when Linux implements ESP (and maybe AUTH) headers.
  *   AK
  *
  * This function parses (probably truncated) exthdr set "hdr"
  * of length "len". "nexthdrp" initially points to some place,
  * where type of the first header can be found.
  *
  * It skips all well known exthdrs, and returns pointer to the start
  *   ANK (980726)
  */
 
 int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len)
 {
 	u8 nexthdr = *nexthdrp;
 
 		struct ipv6_opt_hdr _hdr, *hp;
 		int hdrlen;
 
 		if (len < (int)sizeof(struct ipv6_opt_hdr))
 			return  1;
 		if (nexthdr == NEXTHDR_NONE)
 			return  1;
 		hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);
 		if (hp == NULL)
 			BUG();
 		if (nexthdr == NEXTHDR_FRAGMENT) {
 			unsigned short _frag_off, *fp;
 			fp = skb_header_pointer(skb,
 			hdrlen = ipv6_optlen(hp); 
 
 		nexthdr = hp >nexthdr;
 		len  = hdrlen;
 		start  = hdrlen;
 	}
 
 	if (len < 0)
 		return 1;
 
 	ptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, len);
 	if (ptr < 0)
 		return 0;
 	if (nexthdr == IPPROTO_ICMPV6) {
 	nexthdr = ((struct ipv6hdr *)skb >data) >nexthdr;
 	if (ipv6_ext_hdr(nexthdr)) {
 		/* now skip over extension headers */
 		inner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr, skb >len   sizeof(struct ipv6hdr));
 		if (inner_offset<0)
 			return;
 	} else {
 
 	nexthdr = ip6 >nexthdr;
 	offset  = sizeof(_ipv6h);
 	offset = ipv6_skip_exthdr(skb, offset, &nexthdr,
 				  skb >tail   skb >head   offset);
 	if (offset < 0)
 		goto out;
 
After patch : 
 						    u8 *proto);
 
 extern int			ipv6_skip_exthdr(const struct sk_buff *, int start,
 					         u8 *nexthdrp);
 
 extern int 			ipv6_ext_hdr(u8 nexthdr);
 
  * when Linux implements ESP (and maybe AUTH) headers.
  *   AK
  *
  * This function parses (probably truncated) exthdr set "hdr".
  * "nexthdrp" initially points to some place,
  * where type of the first header can be found.
  *
  * It skips all well known exthdrs, and returns pointer to the start
  *   ANK (980726)
  */
 
 int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp)
 {
 	u8 nexthdr = *nexthdrp;
 
 		struct ipv6_opt_hdr _hdr, *hp;
 		int hdrlen;
 
 		if (nexthdr == NEXTHDR_NONE)
 			return  1;
 		hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);
 		if (hp == NULL)
 			return  1;
 		if (nexthdr == NEXTHDR_FRAGMENT) {
 			unsigned short _frag_off, *fp;
 			fp = skb_header_pointer(skb,
 			hdrlen = ipv6_optlen(hp); 
 
 		nexthdr = hp >nexthdr;
 		start  = hdrlen;
 	}
 
 	if (len < 0)
 		return 1;
 
 	ptr = ipv6_skip_exthdr(skb, ptr, &nexthdr);
 	if (ptr < 0)
 		return 0;
 	if (nexthdr == IPPROTO_ICMPV6) {
 	nexthdr = ((struct ipv6hdr *)skb >data) >nexthdr;
 	if (ipv6_ext_hdr(nexthdr)) {
 		/* now skip over extension headers */
 		inner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr);
 		if (inner_offset<0)
 			return;
 	} else {
 
 	nexthdr = ip6 >nexthdr;
 	offset  = sizeof(_ipv6h);
 	offset = ipv6_skip_exthdr(skb, offset, &nexthdr);
 	if (offset < 0)
 		goto out;
 
