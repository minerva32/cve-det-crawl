CVE Number : CVE-2017-9242
Commit Message : 
ipv6: fix out of bound writes in __ip6_append_data()
Commit Details : 
Andrey Konovalov and idaifish@gmail.com reported crashes caused by
one skb shared_info being overwritten from __ip6_append_data()

Andrey program lead to following state :

copy -4200 datalen 2000 fraglen 2040
maxfraglen 2040 alloclen 2048 transhdrlen 0 offset 0 fraggap 6200

The skb_copy_and_csum_bits(skb_prev, maxfraglen, data + transhdrlen,
fraggap, 0); is overwriting skb->head and skb_shared_info

Since we apparently detect this rare condition too late, move the
code earlier to even avoid allocating skb and risking crashes.

Once again, many thanks to Andrey and syzkaller team.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Andrey Konovalov <andreyknvl@google.com>
Reported-by: <idaifish@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 			 */
 			alloclen  = sizeof(struct frag_hdr);
 
 			if (transhdrlen) {
 				skb = sock_alloc_send_skb(sk,
 						alloclen   hh_len,
 				data  = fraggap;
 				pskb_trim_unique(skb_prev, maxfraglen);
 			}
 			copy = datalen   transhdrlen   fraggap;
 
 			if (copy < 0) {
 				err =  EINVAL;
 				kfree_skb(skb);
 				goto error;
 			} else if (copy > 0 && getfrag(from, data   transhdrlen, offset, copy, fraggap, skb) < 0) {
 				err =  EFAULT;
 				kfree_skb(skb);
 				goto error;
After patch : 
 			 */
 			alloclen  = sizeof(struct frag_hdr);
 
 			copy = datalen   transhdrlen   fraggap;
 			if (copy < 0) {
 				err =  EINVAL;
 				goto error;
 			}
 			if (transhdrlen) {
 				skb = sock_alloc_send_skb(sk,
 						alloclen   hh_len,
 				data  = fraggap;
 				pskb_trim_unique(skb_prev, maxfraglen);
 			}
 			if (copy > 0 &&
 			    getfrag(from, data   transhdrlen, offset,
 				    copy, fraggap, skb) < 0) {
 				err =  EFAULT;
 				kfree_skb(skb);
 				goto error;
