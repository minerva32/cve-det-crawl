CVE Number : CVE-2019-15221
Commit Message : 
ALSA: line6: Fix write on zero-sized buffer
Commit Details : 
LINE6 drivers allocate the buffers based on the value returned from
usb_maxpacket() calls.  The manipulated device may return zero for
this, and this results in the kmalloc() with zero size (and it may
succeed) while the other part of the driver code writes the packet
data with the fixed size -- which eventually overwrites.

This patch adds a simple sanity check for the invalid buffer size for
avoiding that problem.

Reported-by: syzbot+219f00fb49874dcaea17@syzkaller.appspotmail.com
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

Before patch : 
 	line6pcm >max_packet_size_out =
 		usb_maxpacket(line6 >usbdev,
 			usb_sndisocpipe(line6 >usbdev, ep_write), 1);
 
 	spin_lock_init(&line6pcm >out.lock);
 	spin_lock_init(&line6pcm >in.lock);
After patch : 
 	line6pcm >max_packet_size_out =
 		usb_maxpacket(line6 >usbdev,
 			usb_sndisocpipe(line6 >usbdev, ep_write), 1);
 	if (!line6pcm >max_packet_size_in || !line6pcm >max_packet_size_out) {
 		dev_err(line6pcm >line6 >ifcdev,
 			"cannot get proper max packet size\n");
 		return  EINVAL;
 	}
 
 	spin_lock_init(&line6pcm >out.lock);
 	spin_lock_init(&line6pcm >in.lock);
