CVE Number : CVE-2006-0038
Commit Message : 
NETFILTER: Fix possible overflow in netfilters do_replace()
Commit Details : 
netfilter's do_replace() can overflow on addition within SMP_ALIGN()
and/or on multiplication by NR_CPUS, resulting in a buffer overflow on
the copy_from_user().  In practice, the overflow on addition is
triggerable on all systems, whereas the multiplication one might require
much physical memory to be present due to the check above.  Either is
sufficient to overwrite arbitrary amounts of kernel memory.

I really hate adding the same check to all 4 versions of do_replace(),
but the code is duplicate...

Found by Solar Designer during security audit of OpenVZ.org

Signed-Off-By: Kirill Korotaev <dev@openvz.org>
Signed-Off-By: Solar Designer <solar@openwall.com>
Signed-off-by: Patrck McHardy <kaber@trash.net>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 		BUGPRINT("Entries_size never zero\n");
 		return  EINVAL;
 	}
 	countersize = COUNTER_OFFSET(tmp.nentries) * 
 					(highest_possible_processor_id() 1);
 	newinfo = (struct ebt_table_info *)
 	if (len != sizeof(tmp)   tmp.size)
 		return  ENOPROTOOPT;
 
 	newinfo = xt_alloc_table_info(tmp.size);
 	if (!newinfo)
 		return  ENOMEM;
 	if (len != sizeof(tmp)   tmp.size)
 		return  ENOPROTOOPT;
 
 	newinfo = xt_alloc_table_info(tmp.size);
 	if (!newinfo)
 		return  ENOMEM;
 	if (copy_from_user(&tmp, user, sizeof(tmp)) != 0)
 		return  EFAULT;
 
 	newinfo = xt_alloc_table_info(tmp.size);
 	if (!newinfo)
 		return  ENOMEM;
After patch : 
 		BUGPRINT("Entries_size never zero\n");
 		return  EINVAL;
 	}
 	/* overflow check */
 	if (tmp.nentries >= ((INT_MAX   sizeof(struct ebt_table_info)) / NR_CPUS  
 			SMP_CACHE_BYTES) / sizeof(struct ebt_counter))
 		return  ENOMEM;
 	if (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))
 		return  ENOMEM;
 
 	countersize = COUNTER_OFFSET(tmp.nentries) * 
 					(highest_possible_processor_id() 1);
 	newinfo = (struct ebt_table_info *)
 	if (len != sizeof(tmp)   tmp.size)
 		return  ENOPROTOOPT;
 
 	/* overflow check */
 	if (tmp.size >= (INT_MAX   sizeof(struct xt_table_info)) / NR_CPUS  
 			SMP_CACHE_BYTES)
 		return  ENOMEM;
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return  ENOMEM;
 
 	newinfo = xt_alloc_table_info(tmp.size);
 	if (!newinfo)
 		return  ENOMEM;
 	if (len != sizeof(tmp)   tmp.size)
 		return  ENOPROTOOPT;
 
 	/* overflow check */
 	if (tmp.size >= (INT_MAX   sizeof(struct xt_table_info)) / NR_CPUS  
 			SMP_CACHE_BYTES)
 		return  ENOMEM;
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return  ENOMEM;
 
 	newinfo = xt_alloc_table_info(tmp.size);
 	if (!newinfo)
 		return  ENOMEM;
 	if (copy_from_user(&tmp, user, sizeof(tmp)) != 0)
 		return  EFAULT;
 
 	/* overflow check */
 	if (tmp.size >= (INT_MAX   sizeof(struct xt_table_info)) / NR_CPUS  
 			SMP_CACHE_BYTES)
 		return  ENOMEM;
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return  ENOMEM;
 
 	newinfo = xt_alloc_table_info(tmp.size);
 	if (!newinfo)
 		return  ENOMEM;
