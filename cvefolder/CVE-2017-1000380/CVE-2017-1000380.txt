CVE Number : CVE-2017-1000380
Commit Message : 
ALSA: timer: Fix race between read and ioctl
Commit Details : 
The read from ALSA timer device, the function snd_timer_user_tread(),
may access to an uninitialized struct snd_timer_user fields when the
read is concurrently performed while the ioctl like
snd_timer_user_tselect() is invoked.  We have already fixed the races
among ioctls via a mutex, but we seem to have forgotten the race
between read vs ioctl.

This patch simply applies (more exactly extends the already applied
range of) tu->ioctl_lock in snd_timer_user_tread() for closing the
race window.

Reported-by: Alexander Potapenko <glider@google.com>
Tested-by: Alexander Potapenko <glider@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

Before patch : 
 
 	tu = file >private_data;
 	unit = tu >tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
 	spin_lock_irq(&tu >qlock);
 	while ((long)count   result >= unit) {
 		while (!tu >qused) {
 			add_wait_queue(&tu >qchange_sleep, &wait);
 
 			spin_unlock_irq(&tu >qlock);
 			schedule();
 			spin_lock_irq(&tu >qlock);
 
 			remove_wait_queue(&tu >qchange_sleep, &wait);
 		tu >qused  ;
 		spin_unlock_irq(&tu >qlock);
 
 		mutex_lock(&tu >ioctl_lock);
 		if (tu >tread) {
 			if (copy_to_user(buffer, &tu >tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
 					 sizeof(struct snd_timer_read)))
 				err =  EFAULT;
 		}
 		mutex_unlock(&tu >ioctl_lock);
 
 		spin_lock_irq(&tu >qlock);
 		if (err < 0)
 	}
  _error:
 	spin_unlock_irq(&tu >qlock);
 	return result > 0 ? result : err;
 }
 
After patch : 
 
 	tu = file >private_data;
 	unit = tu >tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
 	mutex_lock(&tu >ioctl_lock);
 	spin_lock_irq(&tu >qlock);
 	while ((long)count   result >= unit) {
 		while (!tu >qused) {
 			add_wait_queue(&tu >qchange_sleep, &wait);
 
 			spin_unlock_irq(&tu >qlock);
 			mutex_unlock(&tu >ioctl_lock);
 			schedule();
 			mutex_lock(&tu >ioctl_lock);
 			spin_lock_irq(&tu >qlock);
 
 			remove_wait_queue(&tu >qchange_sleep, &wait);
 		tu >qused  ;
 		spin_unlock_irq(&tu >qlock);
 
 		if (tu >tread) {
 			if (copy_to_user(buffer, &tu >tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
 					 sizeof(struct snd_timer_read)))
 				err =  EFAULT;
 		}
 
 		spin_lock_irq(&tu >qlock);
 		if (err < 0)
 	}
  _error:
 	spin_unlock_irq(&tu >qlock);
 	mutex_unlock(&tu >ioctl_lock);
 	return result > 0 ? result : err;
 }
 
