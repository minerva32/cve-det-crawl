CVE Number : CVE-2021-26708
Commit Message : 
vsock: fix the race conditions in multi-transport support
Commit Details : 
There are multiple similar bugs implicitly introduced by the
commit c0cfa2d8a788fcf4 ("vsock: add multi-transports support") and
commit 6a2c0962105ae8ce ("vsock: prevent transport modules unloading").

The bug pattern:
 1 vsock_sock.transport pointer is copied to a local variable,
 2 lock_sock() is called,
 3 the local variable is used.
VSOCK multi-transport support introduced the race condition:
vsock_sock.transport value may change between 1 and 2.

Let's copy vsock_sock.transport pointer to local variables after
the lock_sock() call.

Fixes: c0cfa2d8a788fcf4 ("vsock: add multi-transports support")
Signed-off-by: Alexander Popov <alex.popov@linux.com>
Reviewed-by: Stefano Garzarella <sgarzare@redhat.com>
Reviewed-by: Jorgen Hansen <jhansen@vmware.com>
Link: https://lore.kernel.org/r/20210201084719.2257066-1-alex.popov@linux.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>

Before patch : 
 			mask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;
 
 	} else if (sock >type == SOCK_STREAM) {
 		const struct vsock_transport *transport = vsk >transport;
 		lock_sock(sk);
 
 		/* Listening sockets that have connections in their accept
 		 * queue can be read.
 		 */
 	err = 0;
 	sk = sock >sk;
 	vsk = vsock_sk(sk);
 	transport = vsk >transport;
 
 	lock_sock(sk);
 
 	err = vsock_auto_bind(vsk);
 	if (err)
 		goto out;
 	err = 0;
 	sk = sock >sk;
 	vsk = vsock_sk(sk);
 	transport = vsk >transport;
 
 	lock_sock(sk);
 
 	switch (optname) {
 	case SO_VM_SOCKETS_BUFFER_SIZE:
 		COPY_IN(val);
 
 	sk = sock >sk;
 	vsk = vsock_sk(sk);
 	transport = vsk >transport;
 	total_written = 0;
 	err = 0;
 
 
 	lock_sock(sk);
 
 	/* Callers should not provide a destination with stream sockets. */
 	if (msg >msg_namelen) {
 		err = sk >sk_state == TCP_ESTABLISHED ?  EISCONN :  EOPNOTSUPP;
 
 	sk = sock >sk;
 	vsk = vsock_sk(sk);
 	transport = vsk >transport;
 	err = 0;
 
 	lock_sock(sk);
 
 	if (!transport || sk >sk_state != TCP_ESTABLISHED) {
 		/* Recvmsg is supposed to return 0 if a peer performs an
 		 * orderly shutdown. Differentiate between that case and when a
After patch : 
 			mask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;
 
 	} else if (sock >type == SOCK_STREAM) {
 		const struct vsock_transport *transport;
 
 		lock_sock(sk);
 
 		transport = vsk >transport;
 
 		/* Listening sockets that have connections in their accept
 		 * queue can be read.
 		 */
 	err = 0;
 	sk = sock >sk;
 	vsk = vsock_sk(sk);
 
 	lock_sock(sk);
 
 	transport = vsk >transport;
 
 	err = vsock_auto_bind(vsk);
 	if (err)
 		goto out;
 	err = 0;
 	sk = sock >sk;
 	vsk = vsock_sk(sk);
 
 	lock_sock(sk);
 
 	transport = vsk >transport;
 
 	switch (optname) {
 	case SO_VM_SOCKETS_BUFFER_SIZE:
 		COPY_IN(val);
 
 	sk = sock >sk;
 	vsk = vsock_sk(sk);
 	total_written = 0;
 	err = 0;
 
 
 	lock_sock(sk);
 
 	transport = vsk >transport;
 
 	/* Callers should not provide a destination with stream sockets. */
 	if (msg >msg_namelen) {
 		err = sk >sk_state == TCP_ESTABLISHED ?  EISCONN :  EOPNOTSUPP;
 
 	sk = sock >sk;
 	vsk = vsock_sk(sk);
 	err = 0;
 
 	lock_sock(sk);
 
 	transport = vsk >transport;
 
 	if (!transport || sk >sk_state != TCP_ESTABLISHED) {
 		/* Recvmsg is supposed to return 0 if a peer performs an
 		 * orderly shutdown. Differentiate between that case and when a
