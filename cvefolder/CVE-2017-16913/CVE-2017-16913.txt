CVE Number : CVE-2017-16913
Commit Message : 
usbip: fix stub_rx: harden CMD_SUBMIT path to handle malicious input
Commit Details : 
Harden CMD_SUBMIT path to handle malicious input that could trigger
large memory allocations. Add checks to validate transfer_buffer_length
and number_of_packets to protect against bad input requesting for
unbounded memory allocations. Validate early in get_pipe() and return
failure.

Reported-by: Secunia Research <vuln@secunia.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Before patch : 
 	return priv;
 }
 
 static int get_pipe(struct stub_device *sdev, int epnum, int dir)
 {
 	struct usb_device *udev = sdev >udev;
 	struct usb_host_endpoint *ep;
 	struct usb_endpoint_descriptor *epd = NULL;
 
 	if (epnum < 0 || epnum > 15)
 		goto err_ret;
 		goto err_ret;
 
 	epd = &ep >desc;
 	if (usb_endpoint_xfer_control(epd)) {
 		if (dir == USBIP_DIR_OUT)
 			return usb_sndctrlpipe(udev, epnum);
 	}
 
 	if (usb_endpoint_xfer_isoc(epd)) {
 		if (dir == USBIP_DIR_OUT)
 			return usb_sndisocpipe(udev, epnum);
 		else
 
 err_ret:
 	/* NOT REACHED */
 	dev_err(&sdev >udev >dev, "get pipe() invalid epnum %d\n", epnum);
 	return  1;
 }
 
 	struct stub_priv *priv;
 	struct usbip_device *ud = &sdev >ud;
 	struct usb_device *udev = sdev >udev;
 	int pipe = get_pipe(sdev, pdu >base.ep, pdu >base.direction);
 
 	if (pipe ==  1)
 		return;
 	}
 
 	/* allocate urb transfer buffer, if needed */
 	if (pdu >u.cmd_submit.transfer_buffer_length > 0) {
 		priv >urb >transfer_buffer =
 			kzalloc(pdu >u.cmd_submit.transfer_buffer_length,
 				GFP_KERNEL);
After patch : 
 	return priv;
 }
 
 static int get_pipe(struct stub_device *sdev, struct usbip_header *pdu)
 {
 	struct usb_device *udev = sdev >udev;
 	struct usb_host_endpoint *ep;
 	struct usb_endpoint_descriptor *epd = NULL;
 	int epnum = pdu >base.ep;
 	int dir = pdu >base.direction;
 
 	if (epnum < 0 || epnum > 15)
 		goto err_ret;
 		goto err_ret;
 
 	epd = &ep >desc;
 
 	/* validate transfer_buffer_length */
 	if (pdu >u.cmd_submit.transfer_buffer_length > INT_MAX) {
 		dev_err(&sdev >udev >dev,
 			"CMD_SUBMIT:  EMSGSIZE transfer_buffer_length %d\n",
 			pdu >u.cmd_submit.transfer_buffer_length);
 		return  1;
 	}
 
 	if (usb_endpoint_xfer_control(epd)) {
 		if (dir == USBIP_DIR_OUT)
 			return usb_sndctrlpipe(udev, epnum);
 	}
 
 	if (usb_endpoint_xfer_isoc(epd)) {
 		/* validate packet size and number of packets */
 		unsigned int maxp, packets, bytes;
 
 		maxp = usb_endpoint_maxp(epd);
 		maxp *= usb_endpoint_maxp_mult(epd);
 		bytes = pdu >u.cmd_submit.transfer_buffer_length;
 		packets = DIV_ROUND_UP(bytes, maxp);
 
 		if (pdu >u.cmd_submit.number_of_packets < 0 ||
 		    pdu >u.cmd_submit.number_of_packets > packets) {
 			dev_err(&sdev >udev >dev,
 				"CMD_SUBMIT: isoc invalid num packets %d\n",
 				pdu >u.cmd_submit.number_of_packets);
 			return  1;
 		}
 		if (dir == USBIP_DIR_OUT)
 			return usb_sndisocpipe(udev, epnum);
 		else
 
 err_ret:
 	/* NOT REACHED */
 	dev_err(&sdev >udev >dev, "CMD_SUBMIT: invalid epnum %d\n", epnum);
 	return  1;
 }
 
 	struct stub_priv *priv;
 	struct usbip_device *ud = &sdev >ud;
 	struct usb_device *udev = sdev >udev;
 	int pipe = get_pipe(sdev, pdu);
 
 	if (pipe ==  1)
 		return;
 	}
 
 	/* allocate urb transfer buffer, if needed */
 	if (pdu >u.cmd_submit.transfer_buffer_length > 0 &&
 	    pdu >u.cmd_submit.transfer_buffer_length <= INT_MAX) {
 		priv >urb >transfer_buffer =
 			kzalloc(pdu >u.cmd_submit.transfer_buffer_length,
 				GFP_KERNEL);
