CVE Number : CVE-2017-7542
Commit Message : 
ipv6: avoid overflow of offset in ip6_find_1stfragopt
Commit Details : 
In some cases, offset can overflow and can cause an infinite loop in
ip6_find_1stfragopt(). Make it unsigned int to prevent the overflow, and
cap it at IPV6_MAXPLEN, since packets larger than that should be invalid.

This problem has been here since before the beginning of git history.

Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
 	u16 offset = sizeof(struct ipv6hdr);
 	unsigned int packet_len = skb_tail_pointer(skb)  
 		skb_network_header(skb);
 	int found_rhdr = 0;
 
 	while (offset <= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
 
 		switch (**nexthdr) {
 
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb)  
 						 offset);
 		offset  = ipv6_optlen(exthdr);
 		*nexthdr = &exthdr >nexthdr;
 	}
 
After patch : 
 
 int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
 	unsigned int offset = sizeof(struct ipv6hdr);
 	unsigned int packet_len = skb_tail_pointer(skb)  
 		skb_network_header(skb);
 	int found_rhdr = 0;
 
 	while (offset <= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
 		unsigned int len;
 
 		switch (**nexthdr) {
 
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb)  
 						 offset);
 		len = ipv6_optlen(exthdr);
 		if (len   offset >= IPV6_MAXPLEN)
 			return  EINVAL;
 		offset  = len;
 		*nexthdr = &exthdr >nexthdr;
 	}
 
