CVE Number : CVE-2014-9922
Commit Message : 
fs: limit filesystem stacking depth
Commit Details : 
Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

Before patch : 
 	s >s_maxbytes = path.dentry >d_sb >s_maxbytes;
 	s >s_blocksize = path.dentry >d_sb >s_blocksize;
 	s >s_magic = ECRYPTFS_SUPER_MAGIC;
 
 	inode = ecryptfs_get_inode(path.dentry >d_inode, s);
 	rc = PTR_ERR(inode);
 	}
 	ufs >lower_namelen = statfs.f_namelen;
 
 	ufs >upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs >upper_mnt);
 	if (IS_ERR(ufs >upper_mnt)) {
  */
 #include <linux/quota.h>
 
 /** 
  * enum positive_aop_returns   aop return codes with specific semantics
  *
 	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
 	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
 	struct rcu_head		rcu;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);
After patch : 
 	s >s_maxbytes = path.dentry >d_sb >s_maxbytes;
 	s >s_blocksize = path.dentry >d_sb >s_blocksize;
 	s >s_magic = ECRYPTFS_SUPER_MAGIC;
 	s >s_stack_depth = path.dentry >d_sb >s_stack_depth   1;
 
 	rc =  EINVAL;
 	if (s >s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 		pr_err("eCryptfs: maximum fs stacking depth exceeded\n");
 		goto out_free;
 	}
 
 	inode = ecryptfs_get_inode(path.dentry >d_inode, s);
 	rc = PTR_ERR(inode);
 	}
 	ufs >lower_namelen = statfs.f_namelen;
 
 	sb >s_stack_depth = max(upperpath.mnt >mnt_sb >s_stack_depth,
 				lowerpath.mnt >mnt_sb >s_stack_depth)   1;
 
 	err =  EINVAL;
 	if (sb >s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 		goto out_put_workpath;
 	}
 
 	ufs >upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs >upper_mnt);
 	if (IS_ERR(ufs >upper_mnt)) {
  */
 #include <linux/quota.h>
 
 /*
  * Maximum number of layers of fs stack.  Needs to be limited to
  * prevent kernel stack overflow
  */
 #define FILESYSTEM_MAX_STACK_DEPTH 2
 
 /** 
  * enum positive_aop_returns   aop return codes with specific semantics
  *
 	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
 	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
 	struct rcu_head		rcu;
 
 	/*
 	 * Indicates how deep in a filesystem stack this SB is
 	 */
 	int s_stack_depth;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);
