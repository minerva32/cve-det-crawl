CVE Number : CVE-2011-4325
Commit Message : 
NFS: Fix an O_DIRECT Oops...
Commit Details : 
We can't call nfs_readdata_release()/nfs_writedata_release() without
first initialising and referencing args.context. Doing so inside
nfs_direct_read_schedule_segment()/nfs_direct_write_schedule_segment()
causes an Oops.

We should rather be calling nfs_readdata_free()/nfs_writedata_free() in
those cases.

Looking at the O_DIRECT code, the "struct nfs_direct_req" is already
referencing the nfs_open_context for us. Since the readdata and writedata
structures carry a reference to that, we can simplify things by getting rid
of the extra nfs_open_context references, so that we can replace all
instances of nfs_readdata_release()/nfs_writedata_release().

Reported-by: Catalin Marinas <catalin.marinas@arm.com>
Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Tested-by: Catalin Marinas <catalin.marinas@arm.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 
 	if (put_dreq(dreq))
 		nfs_direct_complete(dreq);
 	nfs_readdata_release(calldata);
 }
 
 static const struct rpc_call_ops nfs_read_direct_ops = {
 					data >npages, 1, 0, data >pagevec, NULL);
 		up_read(&current >mm >mmap_sem);
 		if (result < 0) {
 			nfs_readdata_release(data);
 			break;
 		}
 		if ((unsigned)result < data >npages) {
 			bytes = result * PAGE_SIZE;
 			if (bytes <= pgbase) {
 				nfs_direct_release_pages(data >pagevec, result);
 				nfs_readdata_release(data);
 				break;
 			}
 			bytes  = pgbase;
 		data >inode = inode;
 		data >cred = msg.rpc_cred;
 		data >args.fh = NFS_FH(inode);
 		data >args.context = get_nfs_open_context(ctx);
 		data >args.offset = pos;
 		data >args.pgbase = pgbase;
 		data >args.pages = data >pagevec;
 		struct nfs_write_data *data = list_entry(dreq >rewrite_list.next, struct nfs_write_data, pages);
 		list_del(&data >pages);
 		nfs_direct_release_pages(data >pagevec, data >npages);
 		nfs_writedata_release(data);
 	}
 }
 
 
 	dprintk("NFS: %5u commit returned %d\n", data >task.tk_pid, status);
 	nfs_direct_write_complete(dreq, data >inode);
 	nfs_commitdata_release(calldata);
 }
 
 static const struct rpc_call_ops nfs_commit_direct_ops = {
 	data >args.fh = NFS_FH(data >inode);
 	data >args.offset = 0;
 	data >args.count = 0;
 	data >args.context = get_nfs_open_context(dreq >ctx);
 	data >res.count = 0;
 	data >res.fattr = &data >fattr;
 	data >res.verf = &data >verf;
 					data >npages, 0, 0, data >pagevec, NULL);
 		up_read(&current >mm >mmap_sem);
 		if (result < 0) {
 			nfs_writedata_release(data);
 			break;
 		}
 		if ((unsigned)result < data >npages) {
 			bytes = result * PAGE_SIZE;
 			if (bytes <= pgbase) {
 				nfs_direct_release_pages(data >pagevec, result);
 				nfs_writedata_release(data);
 				break;
 			}
 			bytes  = pgbase;
 		data >inode = inode;
 		data >cred = msg.rpc_cred;
 		data >args.fh = NFS_FH(inode);
 		data >args.context = get_nfs_open_context(ctx);
 		data >args.offset = pos;
 		data >args.pgbase = pgbase;
 		data >args.pages = data >pagevec;
 	return p;
 }
 
 static void nfs_readdata_free(struct nfs_read_data *p)
 {
 	if (p && (p >pagevec != &p >page_array[0]))
 		kfree(p >pagevec);
 	mempool_free(p, nfs_rdata_mempool);
 }
 
 void nfs_readdata_release(void *data)
 {
 	struct nfs_read_data *rdata = data;
 
 	put_nfs_open_context(rdata >args.context);
 	nfs_readdata_free(rdata);
 }
 	return p;
 }
 
 static void nfs_writedata_free(struct nfs_write_data *p)
 {
 	if (p && (p >pagevec != &p >page_array[0]))
 		kfree(p >pagevec);
 	mempool_free(p, nfs_wdata_mempool);
 }
 
 void nfs_writedata_release(void *data)
 {
 	struct nfs_write_data *wdata = data;
 
 	put_nfs_open_context(wdata >args.context);
 	nfs_writedata_free(wdata);
 }
 extern int  nfs_flush_incompatible(struct file *file, struct page *page);
 extern int  nfs_updatepage(struct file *, struct page *, unsigned int, unsigned int);
 extern int nfs_writeback_done(struct rpc_task *, struct nfs_write_data *);
 extern void nfs_writedata_release(void *);
 
 /*
  * Try to write back everything synchronously (but check the
 extern int  nfs_commit_inode(struct inode *, int);
 extern struct nfs_write_data *nfs_commitdata_alloc(void);
 extern void nfs_commit_free(struct nfs_write_data *wdata);
 extern void nfs_commitdata_release(void *wdata);
 #else
 static inline int
 nfs_commit_inode(struct inode *inode, int how)
  * Allocate nfs_write_data structures
  */
 extern struct nfs_write_data *nfs_writedata_alloc(unsigned int npages);
 
 /*
  * linux/fs/nfs/read.c
 extern int  nfs_readpages(struct file *, struct address_space *,
 		struct list_head *, unsigned);
 extern int  nfs_readpage_result(struct rpc_task *, struct nfs_read_data *);
 extern void nfs_readdata_release(void *data);
 extern int  nfs_readpage_async(struct nfs_open_context *, struct inode *,
 			       struct page *);
 
  * Allocate nfs_read_data structures
  */
 extern struct nfs_read_data *nfs_readdata_alloc(unsigned int npages);
 
 /*
  * linux/fs/nfs3proc.c
After patch : 
 
 	if (put_dreq(dreq))
 		nfs_direct_complete(dreq);
 	nfs_readdata_free(data);
 }
 
 static const struct rpc_call_ops nfs_read_direct_ops = {
 					data >npages, 1, 0, data >pagevec, NULL);
 		up_read(&current >mm >mmap_sem);
 		if (result < 0) {
 			nfs_readdata_free(data);
 			break;
 		}
 		if ((unsigned)result < data >npages) {
 			bytes = result * PAGE_SIZE;
 			if (bytes <= pgbase) {
 				nfs_direct_release_pages(data >pagevec, result);
 				nfs_readdata_free(data);
 				break;
 			}
 			bytes  = pgbase;
 		data >inode = inode;
 		data >cred = msg.rpc_cred;
 		data >args.fh = NFS_FH(inode);
 		data >args.context = ctx;
 		data >args.offset = pos;
 		data >args.pgbase = pgbase;
 		data >args.pages = data >pagevec;
 		struct nfs_write_data *data = list_entry(dreq >rewrite_list.next, struct nfs_write_data, pages);
 		list_del(&data >pages);
 		nfs_direct_release_pages(data >pagevec, data >npages);
 		nfs_writedata_free(data);
 	}
 }
 
 
 	dprintk("NFS: %5u commit returned %d\n", data >task.tk_pid, status);
 	nfs_direct_write_complete(dreq, data >inode);
 	nfs_commit_free(data);
 }
 
 static const struct rpc_call_ops nfs_commit_direct_ops = {
 	data >args.fh = NFS_FH(data >inode);
 	data >args.offset = 0;
 	data >args.count = 0;
 	data >args.context = dreq >ctx;
 	data >res.count = 0;
 	data >res.fattr = &data >fattr;
 	data >res.verf = &data >verf;
 					data >npages, 0, 0, data >pagevec, NULL);
 		up_read(&current >mm >mmap_sem);
 		if (result < 0) {
 			nfs_writedata_free(data);
 			break;
 		}
 		if ((unsigned)result < data >npages) {
 			bytes = result * PAGE_SIZE;
 			if (bytes <= pgbase) {
 				nfs_direct_release_pages(data >pagevec, result);
 				nfs_writedata_free(data);
 				break;
 			}
 			bytes  = pgbase;
 		data >inode = inode;
 		data >cred = msg.rpc_cred;
 		data >args.fh = NFS_FH(inode);
 		data >args.context = ctx;
 		data >args.offset = pos;
 		data >args.pgbase = pgbase;
 		data >args.pages = data >pagevec;
 	return p;
 }
 
 void nfs_readdata_free(struct nfs_read_data *p)
 {
 	if (p && (p >pagevec != &p >page_array[0]))
 		kfree(p >pagevec);
 	mempool_free(p, nfs_rdata_mempool);
 }
 
 static void nfs_readdata_release(struct nfs_read_data *rdata)
 {
 	put_nfs_open_context(rdata >args.context);
 	nfs_readdata_free(rdata);
 }
 	return p;
 }
 
 void nfs_writedata_free(struct nfs_write_data *p)
 {
 	if (p && (p >pagevec != &p >page_array[0]))
 		kfree(p >pagevec);
 	mempool_free(p, nfs_wdata_mempool);
 }
 
 static void nfs_writedata_release(struct nfs_write_data *wdata)
 {
 	put_nfs_open_context(wdata >args.context);
 	nfs_writedata_free(wdata);
 }
 extern int  nfs_flush_incompatible(struct file *file, struct page *page);
 extern int  nfs_updatepage(struct file *, struct page *, unsigned int, unsigned int);
 extern int nfs_writeback_done(struct rpc_task *, struct nfs_write_data *);
 
 /*
  * Try to write back everything synchronously (but check the
 extern int  nfs_commit_inode(struct inode *, int);
 extern struct nfs_write_data *nfs_commitdata_alloc(void);
 extern void nfs_commit_free(struct nfs_write_data *wdata);
 #else
 static inline int
 nfs_commit_inode(struct inode *inode, int how)
  * Allocate nfs_write_data structures
  */
 extern struct nfs_write_data *nfs_writedata_alloc(unsigned int npages);
 extern void nfs_writedata_free(struct nfs_write_data *);
 
 /*
  * linux/fs/nfs/read.c
 extern int  nfs_readpages(struct file *, struct address_space *,
 		struct list_head *, unsigned);
 extern int  nfs_readpage_result(struct rpc_task *, struct nfs_read_data *);
 extern int  nfs_readpage_async(struct nfs_open_context *, struct inode *,
 			       struct page *);
 
  * Allocate nfs_read_data structures
  */
 extern struct nfs_read_data *nfs_readdata_alloc(unsigned int npages);
 extern void nfs_readdata_free(struct nfs_read_data *);
 
 /*
  * linux/fs/nfs3proc.c
