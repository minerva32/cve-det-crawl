CVE Number : CVE-2016-9084
Commit Message : 
vfio/pci: Fix integer overflows, bitmask check
Commit Details : 
The VFIO_DEVICE_SET_IRQS ioctl did not sufficiently sanitize
user-supplied integers, potentially allowing memory corruption. This
patch adds appropriate integer overflow checks, checks the range bounds
for VFIO_IRQ_SET_DATA_NONE, and also verifies that only single element
in the VFIO_IRQ_SET_DATA_TYPE_MASK bitmask is set.
VFIO_IRQ_SET_ACTION_TYPE_MASK is already correctly checked later in
vfio_pci_set_irqs_ioctl().

Furthermore, a kzalloc is changed to a kcalloc because the use of a
kzalloc with an integer multiplication allowed an integer overflow
condition to be reached without this patch. kcalloc checks for overflow
and should prevent a similar occurrence.

Signed-off-by: Vlad Tsyrklevich <vlad@tsyrklevich.net>
Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

Before patch : 
 
 	} else if (cmd == VFIO_DEVICE_SET_IRQS) {
 		struct vfio_irq_set hdr;
 		u8 *data = NULL;
 		int ret = 0;
 
 		minsz = offsetofend(struct vfio_irq_set, count);
 
 			return  EFAULT;
 
 		if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||
 		    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |
 				  VFIO_IRQ_SET_ACTION_TYPE_MASK))
 			return  EINVAL;
 
 		if (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {
 			size_t size;
 			int max = vfio_pci_get_irq_count(vdev, hdr.index);
 
 			if (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)
 				size = sizeof(uint8_t);
 			else if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)
 				size = sizeof(int32_t);
 			else
 				return  EINVAL;
 
 			if (hdr.argsz   minsz < hdr.count * size ||
 			    hdr.start >= max || hdr.start   hdr.count > max)
 				return  EINVAL;
 
 			data = memdup_user((void __user *)(arg   minsz),
 	if (!is_irq_none(vdev))
 		return  EINVAL;
 
 	vdev >ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);
 	if (!vdev >ctx)
 		return  ENOMEM;
 
After patch : 
 
 	} else if (cmd == VFIO_DEVICE_SET_IRQS) {
 		struct vfio_irq_set hdr;
 		size_t size;
 		u8 *data = NULL;
 		int max, ret = 0;
 
 		minsz = offsetofend(struct vfio_irq_set, count);
 
 			return  EFAULT;
 
 		if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||
 		    hdr.count >= (U32_MAX   hdr.start) ||
 		    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |
 				  VFIO_IRQ_SET_ACTION_TYPE_MASK))
 			return  EINVAL;
 
 		max = vfio_pci_get_irq_count(vdev, hdr.index);
 		if (hdr.start >= max || hdr.start   hdr.count > max)
 			return  EINVAL;
 
 		switch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {
 		case VFIO_IRQ_SET_DATA_NONE:
 			size = 0;
 			break;
 		case VFIO_IRQ_SET_DATA_BOOL:
 			size = sizeof(uint8_t);
 			break;
 		case VFIO_IRQ_SET_DATA_EVENTFD:
 			size = sizeof(int32_t);
 			break;
 		default:
 			return  EINVAL;
 		}
 
 		if (size) {
 			if (hdr.argsz   minsz < hdr.count * size)
 				return  EINVAL;
 
 			data = memdup_user((void __user *)(arg   minsz),
 	if (!is_irq_none(vdev))
 		return  EINVAL;
 
 	vdev >ctx = kcalloc(nvec, sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);
 	if (!vdev >ctx)
 		return  ENOMEM;
 
