CVE Number : CVE-2017-7277
Commit Message : 
tcp: mark skbs with SCM_TIMESTAMPING_OPT_STATS
Commit Details : 
SOF_TIMESTAMPING_OPT_STATS can be enabled and disabled
while packets are collected on the error queue.
So, checking SOF_TIMESTAMPING_OPT_STATS in sk->sk_tsflags
is not enough to safely assume that the skb contains
OPT_STATS data.

Add a bit in sock_exterr_skb to indicate whether the
skb contains opt_stats data.

Fixes: 1c885808e456 ("tcp: SOF_TIMESTAMPING_OPT_STATS option for SO_TIMESTAMPING")
Reported-by: JongHwan Kim <zzoru007@gmail.com>
Signed-off-by: Soheil Hassas Yeganeh <soheil@google.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: Willem de Bruijn <willemb@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 	struct sock_extended_err	ee;
 	u16				addr_offset;
 	__be16				port;
 };
 
 #endif
 
 static void __skb_complete_tx_timestamp(struct sk_buff *skb,
 					struct sock *sk,
 					int tstype)
 {
 	struct sock_exterr_skb *serr;
 	int err;
 
 	serr = SKB_EXT_ERR(skb);
 	memset(serr, 0, sizeof(*serr));
 	serr >ee.ee_errno = ENOMSG;
 	serr >ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
 	serr >ee.ee_info = tstype;
 	if (sk >sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
 		serr >ee.ee_data = skb_shinfo(skb) >tskey;
 		if (sk >sk_protocol == IPPROTO_TCP &&
 	 */
 	if (likely(atomic_inc_not_zero(&sk >sk_refcnt))) {
 		*skb_hwtstamps(skb) = *hwtstamps;
 		__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);
 		sock_put(sk);
 	}
 }
 		     struct sock *sk, int tstype)
 {
 	struct sk_buff *skb;
 	bool tsonly;
 
 	if (!sk)
 		return;
 #ifdef CONFIG_INET
 		if ((sk >sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&
 		    sk >sk_protocol == IPPROTO_TCP &&
 		    sk >sk_type == SOCK_STREAM)
 			skb = tcp_get_timestamping_opt_stats(sk);
 		else
 #endif
 			skb = alloc_skb(0, GFP_ATOMIC);
 	} else {
 	else
 		skb >tstamp = ktime_get_real();
 
 	__skb_complete_tx_timestamp(skb, sk, tstype);
 }
 EXPORT_SYMBOL_GPL(__skb_tstamp_tx);
 
 			 SCM_TIMESTAMPING, sizeof(tss), &tss);
 
 		if (skb_is_err_queue(skb) && skb >len &&
 		    (sk >sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))
 			put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,
 				 skb >len, skb >data);
 	}
After patch : 
 	struct sock_extended_err	ee;
 	u16				addr_offset;
 	__be16				port;
 	u8				opt_stats:1,
 					unused:7;
 };
 
 #endif
 
 static void __skb_complete_tx_timestamp(struct sk_buff *skb,
 					struct sock *sk,
 					int tstype,
 					bool opt_stats)
 {
 	struct sock_exterr_skb *serr;
 	int err;
 
 	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb >cb));
 
 	serr = SKB_EXT_ERR(skb);
 	memset(serr, 0, sizeof(*serr));
 	serr >ee.ee_errno = ENOMSG;
 	serr >ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
 	serr >ee.ee_info = tstype;
 	serr >opt_stats = opt_stats;
 	if (sk >sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
 		serr >ee.ee_data = skb_shinfo(skb) >tskey;
 		if (sk >sk_protocol == IPPROTO_TCP &&
 	 */
 	if (likely(atomic_inc_not_zero(&sk >sk_refcnt))) {
 		*skb_hwtstamps(skb) = *hwtstamps;
 		__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND, false);
 		sock_put(sk);
 	}
 }
 		     struct sock *sk, int tstype)
 {
 	struct sk_buff *skb;
 	bool tsonly, opt_stats = false;
 
 	if (!sk)
 		return;
 #ifdef CONFIG_INET
 		if ((sk >sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&
 		    sk >sk_protocol == IPPROTO_TCP &&
 		    sk >sk_type == SOCK_STREAM) {
 			skb = tcp_get_timestamping_opt_stats(sk);
 			opt_stats = true;
 		} else
 #endif
 			skb = alloc_skb(0, GFP_ATOMIC);
 	} else {
 	else
 		skb >tstamp = ktime_get_real();
 
 	__skb_complete_tx_timestamp(skb, sk, tstype, opt_stats);
 }
 EXPORT_SYMBOL_GPL(__skb_tstamp_tx);
 
 			 SCM_TIMESTAMPING, sizeof(tss), &tss);
 
 		if (skb_is_err_queue(skb) && skb >len &&
 		    SKB_EXT_ERR(skb) >opt_stats)
 			put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,
 				 skb >len, skb >data);
 	}
