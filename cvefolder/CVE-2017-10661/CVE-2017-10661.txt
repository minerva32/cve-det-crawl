CVE Number : CVE-2017-10661
Commit Message : 
timerfd: Protect the might cancel mechanism proper
Commit Details : 
The handling of the might_cancel queueing is not properly protected, so
parallel operations on the file descriptor can race with each other and
lead to list corruptions or use after free.

Protect the context for these operations with a seperate lock.

The wait queue lock cannot be reused for this because that would create a
lock inversion scenario vs. the cancel lock. Replacing might_cancel with an
atomic (atomic_t or atomic bit) does not help either because it still can
race vs. the actual list operation.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: "linux-fsdevel@vger.kernel.org"
Cc: syzkaller <syzkaller@googlegroups.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: linux-fsdevel@vger.kernel.org
Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1701311521430.3457@nanos
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>


Before patch : 
 	short unsigned settime_flags;	/* to show in fdinfo */
 	struct rcu_head rcu;
 	struct list_head clist;
 	bool might_cancel;
 };
 
 	rcu_read_unlock();
 }
 
 static void timerfd_remove_cancel(struct timerfd_ctx *ctx)
 {
 	if (ctx >might_cancel) {
 		ctx >might_cancel = false;
 	}
 }
 
 static bool timerfd_canceled(struct timerfd_ctx *ctx)
 {
 	if (!ctx >might_cancel || ctx >moffs != KTIME_MAX)
 
 static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)
 {
 	if ((ctx >clockid == CLOCK_REALTIME ||
 	     ctx >clockid == CLOCK_REALTIME_ALARM) &&
 	    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {
 			list_add_rcu(&ctx >clist, &cancel_list);
 			spin_unlock(&cancel_lock);
 		}
 	} else if (ctx >might_cancel) {
 		timerfd_remove_cancel(ctx);
 	}
 }
 
 static ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)
 		return  ENOMEM;
 
 	init_waitqueue_head(&ctx >wqh);
 	ctx >clockid = clockid;
 
 	if (isalarm(ctx))
After patch : 
 	short unsigned settime_flags;	/* to show in fdinfo */
 	struct rcu_head rcu;
 	struct list_head clist;
 	spinlock_t cancel_lock;
 	bool might_cancel;
 };
 
 	rcu_read_unlock();
 }
 
 static void __timerfd_remove_cancel(struct timerfd_ctx *ctx)
 {
 	if (ctx >might_cancel) {
 		ctx >might_cancel = false;
 	}
 }
 
 static void timerfd_remove_cancel(struct timerfd_ctx *ctx)
 {
 	spin_lock(&ctx >cancel_lock);
 	__timerfd_remove_cancel(ctx);
 	spin_unlock(&ctx >cancel_lock);
 }
 
 static bool timerfd_canceled(struct timerfd_ctx *ctx)
 {
 	if (!ctx >might_cancel || ctx >moffs != KTIME_MAX)
 
 static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)
 {
 	spin_lock(&ctx >cancel_lock);
 	if ((ctx >clockid == CLOCK_REALTIME ||
 	     ctx >clockid == CLOCK_REALTIME_ALARM) &&
 	    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {
 			list_add_rcu(&ctx >clist, &cancel_list);
 			spin_unlock(&cancel_lock);
 		}
 	} else {
 		__timerfd_remove_cancel(ctx);
 	}
 	spin_unlock(&ctx >cancel_lock);
 }
 
 static ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)
 		return  ENOMEM;
 
 	init_waitqueue_head(&ctx >wqh);
 	spin_lock_init(&ctx >cancel_lock);
 	ctx >clockid = clockid;
 
 	if (isalarm(ctx))
