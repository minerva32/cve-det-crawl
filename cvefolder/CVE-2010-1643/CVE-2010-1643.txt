CVE Number : CVE-2010-1643
Commit Message : 
nfsd: fix vm overcommit crash
Commit Details : 
Junjiro R.  Okajima reported a problem where knfsd crashes if you are
using it to export shmemfs objects and run strict overcommit.  In this
situation the current->mm based modifier to the overcommit goes through a
NULL pointer.

We could simply check for NULL and skip the modifier but we've caught
other real bugs in the past from mm being NULL here - cases where we did
need a valid mm set up (eg the exec bug about a year ago).

To preserve the checks and get the logic we want shuffle the checking
around and add a new helper to the vm_ security wrappers

Also fix a current->mm reference in nommu that should use the passed mm

akpm@linux-foundation.org: coding-style fixes
akpm@linux-foundation.org: fix build
Reported-by: Junjiro R. Okajima <hooanon05@yahoo.co.jp>
Acked-by: James Morris <jmorris@namei.org>
Signed-off-by: Alan Cox <alan@redhat.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 int security_settime(struct timespec *ts, struct timezone *tz);
 int security_vm_enough_memory(long pages);
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages);
 int security_bprm_alloc(struct linux_binprm *bprm);
 void security_bprm_free(struct linux_binprm *bprm);
 void security_bprm_apply_creds(struct linux_binprm *bprm, int unsafe);
 	return cap_vm_enough_memory(current >mm, pages);
 }
 
 static inline int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
 	return cap_vm_enough_memory(mm, pages);
 
 	/* Don't let a single process grow too big:
 	   leave 3% of the size of this process for other processes */
 	allowed  = mm >total_vm / 32;
 
 	/*
 	 * cast `allowed' as a signed long because vm_committed_space
 
 	/* Don't let a single process grow too big:
 	   leave 3% of the size of this process for other processes */
 	allowed  = current >mm >total_vm / 32;
 
 	/*
 	 * cast `allowed' as a signed long because vm_committed_space
  */
 static inline int shmem_acct_size(unsigned long flags, loff_t size)
 {
 	return (flags & VM_ACCOUNT)?
 		security_vm_enough_memory(VM_ACCT(size)): 0;
 }
 
 static inline void shmem_unacct_size(unsigned long flags, loff_t size)
  */
 static inline int shmem_acct_block(unsigned long flags)
 {
 	return (flags & VM_ACCOUNT)?
 		0: security_vm_enough_memory(VM_ACCT(PAGE_CACHE_SIZE));
 }
 
 static inline void shmem_unacct_blocks(unsigned long flags, long pages)
 
 int security_vm_enough_memory(long pages)
 {
 	return security_ops >vm_enough_memory(current >mm, pages);
 }
 
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
 	return security_ops >vm_enough_memory(mm, pages);
 }
 
 int security_bprm_alloc(struct linux_binprm *bprm)
 {
 	return security_ops >bprm_alloc_security(bprm);
After patch : 
 int security_settime(struct timespec *ts, struct timezone *tz);
 int security_vm_enough_memory(long pages);
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages);
 int security_vm_enough_memory_kern(long pages);
 int security_bprm_alloc(struct linux_binprm *bprm);
 void security_bprm_free(struct linux_binprm *bprm);
 void security_bprm_apply_creds(struct linux_binprm *bprm, int unsafe);
 	return cap_vm_enough_memory(current >mm, pages);
 }
 
 static inline int security_vm_enough_memory_kern(long pages)
 {
 	return cap_vm_enough_memory(current >mm, pages);
 }
 
 static inline int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
 	return cap_vm_enough_memory(mm, pages);
 
 	/* Don't let a single process grow too big:
 	   leave 3% of the size of this process for other processes */
 	if (mm)
 		allowed  = mm >total_vm / 32;
 
 	/*
 	 * cast `allowed' as a signed long because vm_committed_space
 
 	/* Don't let a single process grow too big:
 	   leave 3% of the size of this process for other processes */
 	if (mm)
 		allowed  = mm >total_vm / 32;
 
 	/*
 	 * cast `allowed' as a signed long because vm_committed_space
  */
 static inline int shmem_acct_size(unsigned long flags, loff_t size)
 {
 	return (flags & VM_ACCOUNT) ?
 		security_vm_enough_memory_kern(VM_ACCT(size)) : 0;
 }
 
 static inline void shmem_unacct_size(unsigned long flags, loff_t size)
  */
 static inline int shmem_acct_block(unsigned long flags)
 {
 	return (flags & VM_ACCOUNT) ?
 		0 : security_vm_enough_memory_kern(VM_ACCT(PAGE_CACHE_SIZE));
 }
 
 static inline void shmem_unacct_blocks(unsigned long flags, long pages)
 
 int security_vm_enough_memory(long pages)
 {
 	WARN_ON(current >mm == NULL);
 	return security_ops >vm_enough_memory(current >mm, pages);
 }
 
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)
 {
 	WARN_ON(mm == NULL);
 	return security_ops >vm_enough_memory(mm, pages);
 }
 
 int security_vm_enough_memory_kern(long pages)
 {
 	/* If current >mm is a kernel thread then we will pass NULL,
 	   for this specific case that is fine */
 	return security_ops >vm_enough_memory(current >mm, pages);
 }
 
 int security_bprm_alloc(struct linux_binprm *bprm)
 {
 	return security_ops >bprm_alloc_security(bprm);
