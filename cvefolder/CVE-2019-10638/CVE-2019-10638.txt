CVE Number : CVE-2019-10638
Commit Message : 
inet: switch IP ID generator to siphash
Commit Details : 
According to Amit Klein and Benny Pinkas, IP ID generation is too weak
and might be used by attackers.

Even with recent net_hash_mix() fix (netns: provide pure entropy for net_hash_mix())
having 64bit key and Jenkins hash is risky.

It is time to switch to siphash and its 128bit keys.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Amit Klein <aksecurity@gmail.com>
Reported-by: Benny Pinkas <benny@pinkas.net>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 	u64 key[2];
 } siphash_key_t;
 
 u64 __siphash_aligned(const void *data, size_t len, const siphash_key_t *key);
 #ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
 u64 __siphash_unaligned(const void *data, size_t len, const siphash_key_t *key);
 #include <linux/uidgid.h>
 #include <net/inet_frag.h>
 #include <linux/rcupdate.h>
 
 struct tcpm_hash_bucket;
 struct ctl_table_header;
 	unsigned int	ipmr_seq;	/* protected by rtnl_mutex */
 
 	atomic_t	rt_genid;
 };
 #endif
 
 void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
 	u32 hash, id;
 
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 
 	hash = jhash_3words((__force u32)iph >daddr,
 			    (__force u32)iph >saddr,
 			    iph >protocol ^ net_hash_mix(net),
 			    ip_idents_hashrnd);
 	id = ip_idents_reserve(hash, segs);
 	iph >id = htons(id);
 }
 #include <net/secure_seq.h>
 #include <linux/netfilter.h>
 
 static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,
 			       const struct in6_addr *dst,
 			       const struct in6_addr *src)
 {
 	u32 hash, id;
 
 	hash = __ipv6_addr_jhash(dst, hashrnd);
 	hash = __ipv6_addr_jhash(src, hash);
 	hash ^= net_hash_mix(net);
 
 	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
 	 * set the hight order instead thus minimizing possible future
  */
 __be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)
 {
 	static u32 ip6_proxy_idents_hashrnd __read_mostly;
 	struct in6_addr buf[2];
 	struct in6_addr *addrs;
 	u32 id;
 	if (!addrs)
 		return 0;
 
 	net_get_random_once(&ip6_proxy_idents_hashrnd,
 			    sizeof(ip6_proxy_idents_hashrnd));
 
 	id = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,
 				 &addrs[1], &addrs[0]);
 	return htonl(id);
 }
 EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);
 			 const struct in6_addr *daddr,
 			 const struct in6_addr *saddr)
 {
 	static u32 ip6_idents_hashrnd __read_mostly;
 	u32 id;
 
 	net_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));
 
 	id = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);
 	return htonl(id);
 }
 EXPORT_SYMBOL(ipv6_select_ident);
After patch : 
 	u64 key[2];
 } siphash_key_t;
 
 static inline bool siphash_key_is_zero(const siphash_key_t *key)
 {
 	return !(key >key[0] | key >key[1]);
 }
 
 u64 __siphash_aligned(const void *data, size_t len, const siphash_key_t *key);
 #ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
 u64 __siphash_unaligned(const void *data, size_t len, const siphash_key_t *key);
 #include <linux/uidgid.h>
 #include <net/inet_frag.h>
 #include <linux/rcupdate.h>
 #include <linux/siphash.h>
 
 struct tcpm_hash_bucket;
 struct ctl_table_header;
 	unsigned int	ipmr_seq;	/* protected by rtnl_mutex */
 
 	atomic_t	rt_genid;
 	siphash_key_t	ip_id_key;
 };
 #endif
 
 void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)
 {
 	u32 hash, id;
 
 	/* Note the following code is not safe, but this is okay. */
 	if (unlikely(siphash_key_is_zero(&net >ipv4.ip_id_key)))
 		get_random_bytes(&net >ipv4.ip_id_key,
 				 sizeof(net >ipv4.ip_id_key));
 
 	hash = siphash_3u32((__force u32)iph >daddr,
 			    (__force u32)iph >saddr,
 			    iph >protocol,
 			    &net >ipv4.ip_id_key);
 	id = ip_idents_reserve(hash, segs);
 	iph >id = htons(id);
 }
 #include <net/secure_seq.h>
 #include <linux/netfilter.h>
 
 static u32 __ipv6_select_ident(struct net *net,
 			       const struct in6_addr *dst,
 			       const struct in6_addr *src)
 {
 	const struct {
 		struct in6_addr dst;
 		struct in6_addr src;
 	} __aligned(SIPHASH_ALIGNMENT) combined = {
 		.dst = *dst,
 		.src = *src,
 	};
 	u32 hash, id;
 
 	/* Note the following code is not safe, but this is okay. */
 	if (unlikely(siphash_key_is_zero(&net >ipv4.ip_id_key)))
 		get_random_bytes(&net >ipv4.ip_id_key,
 				 sizeof(net >ipv4.ip_id_key));
 
 	hash = siphash(&combined, sizeof(combined), &net >ipv4.ip_id_key);
 
 	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
 	 * set the hight order instead thus minimizing possible future
  */
 __be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)
 {
 	struct in6_addr buf[2];
 	struct in6_addr *addrs;
 	u32 id;
 	if (!addrs)
 		return 0;
 
 	id = __ipv6_select_ident(net, &addrs[1], &addrs[0]);
 	return htonl(id);
 }
 EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);
 			 const struct in6_addr *daddr,
 			 const struct in6_addr *saddr)
 {
 	u32 id;
 
 	id = __ipv6_select_ident(net, daddr, saddr);
 	return htonl(id);
 }
 EXPORT_SYMBOL(ipv6_select_ident);
