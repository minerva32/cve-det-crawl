CVE Number : CVE-2012-2313
Commit Message : 
dl2k: Clean up rio_ioctl
Commit Details : 
The dl2k driver's rio_ioctl call has a few issues:
- No permissions checking
- Implements SIOCGMIIREG and SIOCGMIIREG using the SIOCDEVPRIVATE numbers
- Has a few ioctls that may have been used for debugging at one point
  but have no place in the kernel proper.

This patch removes all but the MII ioctls, renumbers them to use the
standard ones, and adds the proper permission check for SIOCSMIIREG.

We can also get rid of the dl2k-specific struct mii_data in favor of
the generic struct mii_ioctl_data.

Since we have the phyid on hand, we can add the SIOCGMIIPHY ioctl too.

Most of the MII code for the driver could probably be converted to use
the generic MII library but I don't have a device to test the results.

Reported-by: Stephan Mueller <stephan.mueller@atsec.com>
Signed-off-by: Jeff Mahoney <jeffm@suse.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
 	struct mii_data *miidata = (struct mii_data *) &rq >ifr_ifru;
 
 	struct netdev_desc *desc;
 	int i;
 
 	phy_addr = np >phy_addr;
 	switch (cmd) {
 	case SIOCDEVPRIVATE:
 		break;
 
 	case SIOCDEVPRIVATE   1:
 		miidata >out_value = mii_read (dev, phy_addr, miidata >reg_num);
 		break;
 	case SIOCDEVPRIVATE   2:
 		mii_write (dev, phy_addr, miidata >reg_num, miidata >in_value);
 		break;
 	case SIOCDEVPRIVATE   3:
 		break;
 	case SIOCDEVPRIVATE   4:
 		break;
 	case SIOCDEVPRIVATE   5:
 		netif_stop_queue (dev);
 		break;
 	case SIOCDEVPRIVATE   6:
 		netif_wake_queue (dev);
 		break;
 	case SIOCDEVPRIVATE   7:
 		printk
 		    ("tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n",
 		     netif_queue_stopped(dev), np >cur_tx, np >old_tx, np >cur_rx,
 		     np >old_rx);
 		break;
 	case SIOCDEVPRIVATE   8:
 		printk("TX ring:\n");
 		for (i = 0; i < TX_RING_SIZE; i  ) {
 			desc = &np >tx_ring[i];
 			printk
 			    ("%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x",
 			     i,
 			     (u32) (np >tx_ring_dma   i * sizeof (*desc)),
 			     (u32)le64_to_cpu(desc >next_desc),
 			     (u32)le64_to_cpu(desc >status),
 			     (u32)(le64_to_cpu(desc >fraginfo) >> 32),
 			     (u32)le64_to_cpu(desc >fraginfo));
 			printk ("\n");
 		}
 		printk ("\n");
 		break;
 
 	default:
 		return  EOPNOTSUPP;
 	}
 	char *data;
 };
 
 struct mii_data {
 	__u16 reserved;
 	__u16 reg_num;
 	__u16 in_value;
 	__u16 out_value;
 };
 
 /* The Rx and Tx buffer descriptors. */
 struct netdev_desc {
 	__le64 next_desc;
After patch : 
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
 	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np >phy_addr;
 	switch (cmd) {
 	case SIOCGMIIPHY:
 		miidata >phy_id = phy_addr;
 		break;
 	case SIOCGMIIREG:
 		miidata >val_out = mii_read (dev, phy_addr, miidata >reg_num);
 		break;
 	case SIOCSMIIREG:
 		if (!capable(CAP_NET_ADMIN))
 			return  EPERM;
 		mii_write (dev, phy_addr, miidata >reg_num, miidata >val_in);
 		break;
 	default:
 		return  EOPNOTSUPP;
 	}
 	char *data;
 };
 
 /* The Rx and Tx buffer descriptors. */
 struct netdev_desc {
 	__le64 next_desc;
