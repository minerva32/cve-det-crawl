CVE Number : CVE-2011-4112
Commit Message : 
net: Audit drivers to identify those needing IFF_TX_SKB_SHARING cleared
Commit Details : 
After the last patch, We are left in a state in which only drivers calling
ether_setup have IFF_TX_SKB_SHARING set (we assume that drivers touching real
hardware call ether_setup for their net_devices and don't hold any state in
their skbs.  There are a handful of drivers that violate this assumption of
course, and need to be fixed up.  This patch identifies those drivers, and marks
them as not being able to support the safe transmission of skbs by clearning the
IFF_TX_SKB_SHARING flag in priv_flags

Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
CC: Karsten Keil <isdn@linux-pingi.de>
CC: "David S. Miller" <davem@davemloft.net>
CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
CC: Patrick McHardy <kaber@trash.net>
CC: Krzysztof Halasa <khc@pm.waw.pl>
CC: "John W. Linville" <linville@tuxdriver.com>
CC: Greg Kroah-Hartman <gregkh@suse.de>
CC: Marcel Holtmann <marcel@holtmann.org>
CC: Johannes Berg <johannes@sipsolutions.net>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 	/* Setup the generic properties */
 	dev >flags = IFF_NOARP|IFF_POINTOPOINT;
 	dev >header_ops = NULL;
 	dev >netdev_ops = &isdn_netdev_ops;
 
 
 			if (slave_dev >type != ARPHRD_ETHER)
 				bond_setup_by_slave(bond_dev, slave_dev);
 			else
 				ether_setup(bond_dev);
 
 			netdev_bonding_change(bond_dev,
 					      NETDEV_POST_TYPE_CHANGE);
 	bond_dev >tx_queue_len = 0;
 	bond_dev >flags |= IFF_MASTER|IFF_MULTICAST;
 	bond_dev >priv_flags |= IFF_BONDING;
 	bond_dev >priv_flags &= ~IFF_XMIT_DST_RELEASE;
 
 	/* At first, we block adding VLANs. That's the only way to
 	 * prevent problems that occur when adding VLANs over an
 
 	dev >flags |= IFF_NOARP;
 	dev >flags &= ~IFF_MULTICAST;
 	dev >priv_flags &= ~IFF_XMIT_DST_RELEASE;
 	random_ether_addr(dev >dev_addr);
 }
 
 {
 	ether_setup(dev);
 
 	dev >priv_flags	       &= ~IFF_XMIT_DST_RELEASE;
 	dev >netdev_ops		= &macvlan_netdev_ops;
 	dev >destructor		= free_netdev;
 	dev >header_ops		= &macvlan_hard_header_ops,
 		dev >netdev_ops = &tap_netdev_ops;
 		/* Ethernet TAP Device */
 		ether_setup(dev);
 
 		random_ether_addr(dev >dev_addr);
 
 {
 	ether_setup(dev);
 
 	dev >netdev_ops = &veth_netdev_ops;
 	dev >ethtool_ops = &veth_ethtool_ops;
 	dev >features |= NETIF_F_LLTX;
 
 	used = pvc_is_used(pvc);
 
 	if (type == ARPHRD_ETHER)
 		dev = alloc_netdev(0, "pvceth%d", ether_setup);
 	else
 		dev = alloc_netdev(0, "pvc%d", pvc_setup);
 
 	if (!dev) {
 	dev >wireless_data = &ai >wireless_data;
 	dev >irq = irq;
 	dev >base_addr = port;
 
 	SET_NETDEV_DEV(dev, dmdev);
 
 
 	iface = netdev_priv(dev);
 	ether_setup(dev);
 
 	/* kernel callbacks */
 	if (iface) {
 
     ether_setup(dev);
     init_netdev(dev, ap_ifname);
 
     if (register_netdev(dev)) {
         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("ar6000_create_ap_interface: register_netdev failed\n"));
 	ether_setup(dev);
 
 	dev >priv_flags		|= IFF_802_1Q_VLAN;
 	dev >priv_flags		&= ~IFF_XMIT_DST_RELEASE;
 	dev >tx_queue_len	= 0;
 
 	dev >netdev_ops		= &vlan_netdev_ops;
 	dev >addr_len = ETH_ALEN;
 
 	ether_setup(dev);
 	dev >netdev_ops = &bnep_netdev_ops;
 
 	dev >watchdog_timeo  = HZ * 2;
 static void l2tp_eth_dev_setup(struct net_device *dev)
 {
 	ether_setup(dev);
 
 	dev >netdev_ops		= &l2tp_eth_netdev_ops;
 	dev >destructor		= free_netdev;
 }
 static void ieee80211_if_setup(struct net_device *dev)
 {
 	ether_setup(dev);
 	dev >netdev_ops = &ieee80211_dataif_ops;
 	dev >destructor = free_netdev;
 }
After patch : 
 
 	/* Setup the generic properties */
 	dev >flags = IFF_NOARP|IFF_POINTOPOINT;
 
 	/* isdn prepends a header in the tx path, can't share skbs */
 	dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 	dev >header_ops = NULL;
 	dev >netdev_ops = &isdn_netdev_ops;
 
 
 			if (slave_dev >type != ARPHRD_ETHER)
 				bond_setup_by_slave(bond_dev, slave_dev);
 			else {
 				ether_setup(bond_dev);
 				bond_dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 			}
 
 			netdev_bonding_change(bond_dev,
 					      NETDEV_POST_TYPE_CHANGE);
 	bond_dev >tx_queue_len = 0;
 	bond_dev >flags |= IFF_MASTER|IFF_MULTICAST;
 	bond_dev >priv_flags |= IFF_BONDING;
 	bond_dev >priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);
 
 	/* At first, we block adding VLANs. That's the only way to
 	 * prevent problems that occur when adding VLANs over an
 
 	dev >flags |= IFF_NOARP;
 	dev >flags &= ~IFF_MULTICAST;
 	dev >priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);
 	random_ether_addr(dev >dev_addr);
 }
 
 {
 	ether_setup(dev);
 
 	dev >priv_flags	       &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);
 	dev >netdev_ops		= &macvlan_netdev_ops;
 	dev >destructor		= free_netdev;
 	dev >header_ops		= &macvlan_hard_header_ops,
 		dev >netdev_ops = &tap_netdev_ops;
 		/* Ethernet TAP Device */
 		ether_setup(dev);
 		dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 
 		random_ether_addr(dev >dev_addr);
 
 {
 	ether_setup(dev);
 
 	dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 
 	dev >netdev_ops = &veth_netdev_ops;
 	dev >ethtool_ops = &veth_ethtool_ops;
 	dev >features |= NETIF_F_LLTX;
 
 	used = pvc_is_used(pvc);
 
 	if (type == ARPHRD_ETHER) {
 		dev = alloc_netdev(0, "pvceth%d", ether_setup);
 		dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 	} else
 		dev = alloc_netdev(0, "pvc%d", pvc_setup);
 
 	if (!dev) {
 	dev >wireless_data = &ai >wireless_data;
 	dev >irq = irq;
 	dev >base_addr = port;
 	dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 
 	SET_NETDEV_DEV(dev, dmdev);
 
 
 	iface = netdev_priv(dev);
 	ether_setup(dev);
 	dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 
 	/* kernel callbacks */
 	if (iface) {
 
     ether_setup(dev);
     init_netdev(dev, ap_ifname);
     dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 
     if (register_netdev(dev)) {
         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("ar6000_create_ap_interface: register_netdev failed\n"));
 	ether_setup(dev);
 
 	dev >priv_flags		|= IFF_802_1Q_VLAN;
 	dev >priv_flags		&= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);
 	dev >tx_queue_len	= 0;
 
 	dev >netdev_ops		= &vlan_netdev_ops;
 	dev >addr_len = ETH_ALEN;
 
 	ether_setup(dev);
 	dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 	dev >netdev_ops = &bnep_netdev_ops;
 
 	dev >watchdog_timeo  = HZ * 2;
 static void l2tp_eth_dev_setup(struct net_device *dev)
 {
 	ether_setup(dev);
 	dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 	dev >netdev_ops		= &l2tp_eth_netdev_ops;
 	dev >destructor		= free_netdev;
 }
 static void ieee80211_if_setup(struct net_device *dev)
 {
 	ether_setup(dev);
 	dev >priv_flags &= ~IFF_TX_SKB_SHARING;
 	dev >netdev_ops = &ieee80211_dataif_ops;
 	dev >destructor = free_netdev;
 }
