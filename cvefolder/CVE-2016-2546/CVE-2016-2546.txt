CVE Number : CVE-2016-2546
Commit Message : 
ALSA: timer: Fix race among timer ioctls
Commit Details : 
ALSA timer ioctls have an open race and this may lead to a
use-after-free of timer instance object.  A simplistic fix is to make
each ioctl exclusive.  We have already tread_sem for controlling the
tread, and extend this as a global mutex to be applied to each ioctl.

The downside is, of course, the worse concurrency.  But these ioctls
aren't to be parallel accessible, in anyway, so it should be fine to
serialize there.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Tested-by: Dmitry Vyukov <dvyukov@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

Before patch : 
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
 	struct mutex tread_sem;
 };
 
 /* list of timers */
 		return  ENOMEM;
 	spin_lock_init(&tu >qlock);
 	init_waitqueue_head(&tu >qchange_sleep);
 	mutex_init(&tu >tread_sem);
 	tu >ticks = 1;
 	tu >queue_size = 128;
 	tu >queue = kmalloc(tu >queue_size * sizeof(struct snd_timer_read),
 	if (file >private_data) {
 		tu = file >private_data;
 		file >private_data = NULL;
 		if (tu >timeri)
 			snd_timer_close(tu >timeri);
 		kfree(tu >queue);
 		kfree(tu >tqueue);
 		kfree(tu);
 	int err = 0;
 
 	tu = file >private_data;
 	mutex_lock(&tu >tread_sem);
 	if (tu >timeri) {
 		snd_timer_close(tu >timeri);
 		tu >timeri = NULL;
 	}
 
       __err:
       	mutex_unlock(&tu >tread_sem);
 	return err;
 }
 
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
 };
 
 static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
 	{
 		int xarg;
 
 		mutex_lock(&tu >tread_sem);
 		if (tu >timeri)	{	/* too late */
 			mutex_unlock(&tu >tread_sem);
 			return  EBUSY;
 		}
 		if (get_user(xarg, p)) {
 			mutex_unlock(&tu >tread_sem);
 			return  EFAULT;
 		}
 		tu >tread = xarg ? 1 : 0;
 		mutex_unlock(&tu >tread_sem);
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
 	return  ENOTTY;
 }
 
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;
After patch : 
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
 	struct mutex ioctl_lock;
 };
 
 /* list of timers */
 		return  ENOMEM;
 	spin_lock_init(&tu >qlock);
 	init_waitqueue_head(&tu >qchange_sleep);
 	mutex_init(&tu >ioctl_lock);
 	tu >ticks = 1;
 	tu >queue_size = 128;
 	tu >queue = kmalloc(tu >queue_size * sizeof(struct snd_timer_read),
 	if (file >private_data) {
 		tu = file >private_data;
 		file >private_data = NULL;
 		mutex_lock(&tu >ioctl_lock);
 		if (tu >timeri)
 			snd_timer_close(tu >timeri);
 		mutex_unlock(&tu >ioctl_lock);
 		kfree(tu >queue);
 		kfree(tu >tqueue);
 		kfree(tu);
 	int err = 0;
 
 	tu = file >private_data;
 	if (tu >timeri) {
 		snd_timer_close(tu >timeri);
 		tu >timeri = NULL;
 	}
 
       __err:
 	return err;
 }
 
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
 };
 
 static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
 	{
 		int xarg;
 
 		if (tu >timeri)	/* too late */
 			return  EBUSY;
 		if (get_user(xarg, p))
 			return  EFAULT;
 		tu >tread = xarg ? 1 : 0;
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
 	return  ENOTTY;
 }
 
 static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu = file >private_data;
 	long ret;
 
 	mutex_lock(&tu >ioctl_lock);
 	ret = __snd_timer_user_ioctl(file, cmd, arg);
 	mutex_unlock(&tu >ioctl_lock);
 	return ret;
 }
 
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;
