CVE Number : CVE-2017-8063
Commit Message : 
media cxusb: Use a dma capable buffer also for reading
Commit Details : 
Commit 17ce039b4e54 ("media cxusb: don't do DMA on stack")
added a kmalloc'ed bounce buffer for writes, but missed to do the same
for reads. As the read only happens after the write is finished, we can
reuse the same buffer.

As dvb_usb_generic_rw handles a read length of 0 by itself, avoid calling
it using the dvb_usb_generic_read wrapper function.

Signed-off-by: Stefan Br√ºns <stefan.bruens@rwth-aachen.de>
Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

Before patch : 
 			  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)
 {
 	struct cxusb_state *st = d >priv;
 	int ret, wo;
 
 	if (1   wlen > MAX_XFER_SIZE) {
 		warn("i2c wr: len=%d is too big!\n", wlen);
 		return  EOPNOTSUPP;
 	}
 
 	wo = (rbuf == NULL || rlen == 0); /* write only */
 
 	mutex_lock(&d >data_mutex);
 	st >data[0] = cmd;
 	memcpy(&st >data[1], wbuf, wlen);
 	if (wo)
 		ret = dvb_usb_generic_write(d, st >data, 1   wlen);
 	else
 		ret = dvb_usb_generic_rw(d, st >data, 1   wlen,
 					 rbuf, rlen, 0);
 
 	mutex_unlock(&d >data_mutex);
 	return ret;
After patch : 
 			  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)
 {
 	struct cxusb_state *st = d >priv;
 	int ret;
 
 	if (1   wlen > MAX_XFER_SIZE) {
 		warn("i2c wr: len=%d is too big!\n", wlen);
 		return  EOPNOTSUPP;
 	}
 
 	if (rlen > MAX_XFER_SIZE) {
 		warn("i2c rd: len=%d is too big!\n", rlen);
 		return  EOPNOTSUPP;
 	}
 
 	mutex_lock(&d >data_mutex);
 	st >data[0] = cmd;
 	memcpy(&st >data[1], wbuf, wlen);
 	ret = dvb_usb_generic_rw(d, st >data, 1   wlen, st >data, rlen, 0);
 	if (!ret && rbuf && rlen)
 		memcpy(rbuf, st >data, rlen);
 
 	mutex_unlock(&d >data_mutex);
 	return ret;
