CVE Number : CVE-2016-6197
Commit Message : 
ovl: verify upper dentry before unlink and rename
Commit Details : 
Unlink and rename in overlayfs checked the upper dentry for staleness by
verifying upper->d_parent against upperdir.  However the dentry can go
stale also by being unhashed, for example.

Expand the verification to actually look up the name again (under parent
lock) and check if it matches the upper dentry.  This matches what the VFS
does before passing the dentry to filesytem's unlink/rename methods, which
excludes any inconsistency caused by overlayfs.

Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

Before patch : 
 {
 	struct dentry *upperdir = ovl_dentry_upper(dentry >d_parent);
 	struct inode *dir = upperdir >d_inode;
 	struct dentry *upper = ovl_dentry_upper(dentry);
 	int err;
 
 	inode_lock_nested(dir, I_MUTEX_PARENT);
 	err =  ESTALE;
 	if (upper >d_parent == upperdir) {
 		/* Don't let d_delete() think it can reset d_inode */
 		dget(upper);
 		if (is_dir)
 			err = vfs_rmdir(dir, upper);
 		else
 			err = vfs_unlink(dir, upper, NULL);
 		dput(upper);
 		ovl_dentry_version_inc(dentry >d_parent);
 	}
 
 	/*
 	 * Keeping this dentry hashed would mean having to release
 	 */
 	if (!err)
 		d_drop(dentry);
 	inode_unlock(dir);
 
 	return err;
 
 	trap = lock_rename(new_upperdir, old_upperdir);
 
 	olddentry = ovl_dentry_upper(old);
 	newdentry = ovl_dentry_upper(new);
 	if (newdentry) {
 		if (opaquedir) {
 			newdentry = opaquedir;
 			opaquedir = NULL;
 		} else {
 			dget(newdentry);
 		}
 	} else {
 		new_create = true;
 		newdentry = lookup_one_len(new >d_name.name, new_upperdir,
 					   new >d_name.len);
 		err = PTR_ERR(newdentry);
 		if (IS_ERR(newdentry))
 			goto out_unlock;
 	}
 
 	err =  ESTALE;
 	if (olddentry >d_parent != old_upperdir)
 		goto out_dput;
 	if (newdentry >d_parent != new_upperdir)
 		goto out_dput;
 	if (olddentry == trap)
 		goto out_dput;
 	if (newdentry == trap)
 
 out_dput:
 	dput(newdentry);
 out_unlock:
 	unlock_rename(new_upperdir, old_upperdir);
 out_revert_creds:
After patch : 
 {
 	struct dentry *upperdir = ovl_dentry_upper(dentry >d_parent);
 	struct inode *dir = upperdir >d_inode;
 	struct dentry *upper;
 	int err;
 
 	inode_lock_nested(dir, I_MUTEX_PARENT);
 	upper = lookup_one_len(dentry >d_name.name, upperdir,
 			       dentry >d_name.len);
 	err = PTR_ERR(upper);
 	if (IS_ERR(upper))
 		goto out_unlock;
 
 	err =  ESTALE;
 	if (upper == ovl_dentry_upper(dentry)) {
 		if (is_dir)
 			err = vfs_rmdir(dir, upper);
 		else
 			err = vfs_unlink(dir, upper, NULL);
 		ovl_dentry_version_inc(dentry >d_parent);
 	}
 	dput(upper);
 
 	/*
 	 * Keeping this dentry hashed would mean having to release
 	 */
 	if (!err)
 		d_drop(dentry);
 out_unlock:
 	inode_unlock(dir);
 
 	return err;
 
 	trap = lock_rename(new_upperdir, old_upperdir);
 
 
 	olddentry = lookup_one_len(old >d_name.name, old_upperdir,
 				   old >d_name.len);
 	err = PTR_ERR(olddentry);
 	if (IS_ERR(olddentry))
 		goto out_unlock;
 
 	err =  ESTALE;
 	if (olddentry != ovl_dentry_upper(old))
 		goto out_dput_old;
 
 	newdentry = lookup_one_len(new >d_name.name, new_upperdir,
 				   new >d_name.len);
 	err = PTR_ERR(newdentry);
 	if (IS_ERR(newdentry))
 		goto out_dput_old;
 
 	err =  ESTALE;
 	if (ovl_dentry_upper(new)) {
 		if (opaquedir) {
 			if (newdentry != opaquedir)
 				goto out_dput;
 		} else {
 			if (newdentry != ovl_dentry_upper(new))
 				goto out_dput;
 		}
 	} else {
 		new_create = true;
 		if (!d_is_negative(newdentry) &&
 		    (!new_opaque || !ovl_is_whiteout(newdentry)))
 			goto out_dput;
 	}
 
 	if (olddentry == trap)
 		goto out_dput;
 	if (newdentry == trap)
 
 out_dput:
 	dput(newdentry);
 out_dput_old:
 	dput(olddentry);
 out_unlock:
 	unlock_rename(new_upperdir, old_upperdir);
 out_revert_creds:
