CVE Number : CVE-2016-4997
Commit Message : 
netfilter: x_tables: check for bogus target offset
Commit Details : 
We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

Before patch : 
 int xt_register_matches(struct xt_match *match, unsigned int n);
 void xt_unregister_matches(struct xt_match *match, unsigned int n);
 
 int xt_check_entry_offsets(const void *base,
 			   unsigned int target_offset,
 			   unsigned int next_offset);
 
 				unsigned int *size);
 int xt_compat_target_to_user(const struct xt_entry_target *t,
 			     void __user **dstptr, unsigned int *size);
 int xt_compat_check_entry_offsets(const void *base,
 				  unsigned int target_offset,
 				  unsigned int next_offset);
 
 	if (!arp_checkentry(&e >arp))
 		return  EINVAL;
 
 	err = xt_check_entry_offsets(e, e >target_offset, e >next_offset);
 	if (err)
 		return err;
 
 	if (!arp_checkentry(&e >arp))
 		return  EINVAL;
 
 	ret = xt_compat_check_entry_offsets(e, e >target_offset,
 					    e >next_offset);
 	if (ret)
 		return ret;
 	if (!ip_checkentry(&e >ip))
 		return  EINVAL;
 
 	err = xt_check_entry_offsets(e, e >target_offset, e >next_offset);
 	if (err)
 		return err;
 
 	if (!ip_checkentry(&e >ip))
 		return  EINVAL;
 
 	ret = xt_compat_check_entry_offsets(e,
 					    e >target_offset, e >next_offset);
 	if (ret)
 		return ret;
 	if (!ip6_checkentry(&e >ipv6))
 		return  EINVAL;
 
 	err = xt_check_entry_offsets(e, e >target_offset, e >next_offset);
 	if (err)
 		return err;
 
 	if (!ip6_checkentry(&e >ipv6))
 		return  EINVAL;
 
 	ret = xt_compat_check_entry_offsets(e,
 					    e >target_offset, e >next_offset);
 	if (ret)
 		return ret;
 	compat_uint_t verdict;
 };
 
 /* see xt_check_entry_offsets */
 int xt_compat_check_entry_offsets(const void *base,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
 	const struct compat_xt_entry_target *t;
 	const char *e = base;
 
 	if (target_offset   sizeof(*t) > next_offset)
 		return  EINVAL;
 
  * xt_check_entry_offsets   validate arp/ip/ip6t_entry
  *
  * @base: pointer to arp/ip/ip6t_entry
  * @target_offset: the arp/ip/ip6_t >target_offset
  * @next_offset: the arp/ip/ip6_t >next_offset
  *
  * validates that target_offset and next_offset are sane.
  * Also see xt_compat_check_entry_offsets for CONFIG_COMPAT version.
  *
  * The arp/ip/ip6t_entry structure @base must have passed following tests:
  *   it must point to a valid memory location
  *   base to base   next_offset must be accessible, i.e. not exceed allocated
  * Return: 0 on success, negative errno on failure.
  */
 int xt_check_entry_offsets(const void *base,
 			   unsigned int target_offset,
 			   unsigned int next_offset)
 {
 	const struct xt_entry_target *t;
 	const char *e = base;
 
 	if (target_offset   sizeof(*t) > next_offset)
 		return  EINVAL;
 
After patch : 
 int xt_register_matches(struct xt_match *match, unsigned int n);
 void xt_unregister_matches(struct xt_match *match, unsigned int n);
 
 int xt_check_entry_offsets(const void *base, const char *elems,
 			   unsigned int target_offset,
 			   unsigned int next_offset);
 
 				unsigned int *size);
 int xt_compat_target_to_user(const struct xt_entry_target *t,
 			     void __user **dstptr, unsigned int *size);
 int xt_compat_check_entry_offsets(const void *base, const char *elems,
 				  unsigned int target_offset,
 				  unsigned int next_offset);
 
 	if (!arp_checkentry(&e >arp))
 		return  EINVAL;
 
 	err = xt_check_entry_offsets(e, e >elems, e >target_offset,
 				     e >next_offset);
 	if (err)
 		return err;
 
 	if (!arp_checkentry(&e >arp))
 		return  EINVAL;
 
 	ret = xt_compat_check_entry_offsets(e, e >elems, e >target_offset,
 					    e >next_offset);
 	if (ret)
 		return ret;
 	if (!ip_checkentry(&e >ip))
 		return  EINVAL;
 
 	err = xt_check_entry_offsets(e, e >elems, e >target_offset,
 				     e >next_offset);
 	if (err)
 		return err;
 
 	if (!ip_checkentry(&e >ip))
 		return  EINVAL;
 
 	ret = xt_compat_check_entry_offsets(e, e >elems,
 					    e >target_offset, e >next_offset);
 	if (ret)
 		return ret;
 	if (!ip6_checkentry(&e >ipv6))
 		return  EINVAL;
 
 	err = xt_check_entry_offsets(e, e >elems, e >target_offset,
 				     e >next_offset);
 	if (err)
 		return err;
 
 	if (!ip6_checkentry(&e >ipv6))
 		return  EINVAL;
 
 	ret = xt_compat_check_entry_offsets(e, e >elems,
 					    e >target_offset, e >next_offset);
 	if (ret)
 		return ret;
 	compat_uint_t verdict;
 };
 
 int xt_compat_check_entry_offsets(const void *base, const char *elems,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
 	long size_of_base_struct = elems   (const char *)base;
 	const struct compat_xt_entry_target *t;
 	const char *e = base;
 
 	if (target_offset < size_of_base_struct)
 		return  EINVAL;
 
 	if (target_offset   sizeof(*t) > next_offset)
 		return  EINVAL;
 
  * xt_check_entry_offsets   validate arp/ip/ip6t_entry
  *
  * @base: pointer to arp/ip/ip6t_entry
  * @elems: pointer to first xt_entry_match, i.e. ip(6)t_entry >elems
  * @target_offset: the arp/ip/ip6_t >target_offset
  * @next_offset: the arp/ip/ip6_t >next_offset
  *
  * validates that target_offset and next_offset are sane.
  * Also see xt_compat_check_entry_offsets for CONFIG_COMPAT version.
  *
  * This function does not validate the targets or matches themselves, it
  * only tests that all the offsets and sizes are correct.
  *
  * The arp/ip/ip6t_entry structure @base must have passed following tests:
  *   it must point to a valid memory location
  *   base to base   next_offset must be accessible, i.e. not exceed allocated
  * Return: 0 on success, negative errno on failure.
  */
 int xt_check_entry_offsets(const void *base,
 			   const char *elems,
 			   unsigned int target_offset,
 			   unsigned int next_offset)
 {
 	long size_of_base_struct = elems   (const char *)base;
 	const struct xt_entry_target *t;
 	const char *e = base;
 
 	/* target start is within the ip/ip6/arpt_entry struct */
 	if (target_offset < size_of_base_struct)
 		return  EINVAL;
 
 	if (target_offset   sizeof(*t) > next_offset)
 		return  EINVAL;
 
