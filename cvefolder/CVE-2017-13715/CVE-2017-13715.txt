CVE Number : CVE-2017-13715
Commit Message : 
flow_dissector: Jump to exit code in __skb_flow_dissect
Commit Details : 
Instead of returning immediately (on a parsing failure for instance) we
jump to cleanup code. This always sets protocol values in key_control
(even on a failure there is still valid information in the key_tags that
was set before the problem was hit).

Signed-off-by: Tom Herbert <tom@herbertland.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 	struct flow_dissector_key_tags *key_tags;
 	struct flow_dissector_key_keyid *key_keyid;
 	u8 ip_proto = 0;
 
 	if (!data) {
 		data = skb >data;
 ip:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph || iph >ihl < 5)
 			return false;
 		nhoff  = iph >ihl * 4;
 
 		ip_proto = iph >protocol;
 ipv6:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph)
 			return false;
 
 		ip_proto = iph >nexthdr;
 		nhoff  = sizeof(struct ipv6hdr);
 
 		vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);
 		if (!vlan)
 			return false;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_VLANID)) {
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
 			return false;
 		proto = hdr >proto;
 		nhoff  = PPPOE_SES_HLEN;
 		switch (proto) {
 		case htons(PPP_IPV6):
 			goto ipv6;
 		default:
 			return false;
 		}
 	}
 	case htons(ETH_P_TIPC): {
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
 			return false;
 		key_basic >n_proto = proto;
 		key_control >thoff = (u16)nhoff;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_TIPC_ADDRS)) {
 			key_addrs >tipcaddrs.srcnode = hdr >srcnode;
 			key_control >addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;
 		}
 		return true;
 	}
 
 	case htons(ETH_P_MPLS_UC):
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,
 					   hlen, &_hdr);
 		if (!hdr)
 			return false;
 
 		if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>
 		     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {
 					htonl(MPLS_LS_LABEL_MASK);
 			}
 
 			key_basic >n_proto = proto;
 			key_basic >ip_proto = ip_proto;
 			key_control >thoff = (u16)nhoff;
 
 			return true;
 		}
 
 		return true;
 	}
 
 	case htons(ETH_P_FCOE):
 		key_control >thoff = (u16)(nhoff   FCOE_HEADER_LEN);
 		/* fall through */
 	default:
 		return false;
 	}
 
 ip_proto_again:
 
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
 			return false;
 		/*
 		 * Only look inside GRE if version zero and no
 		 * routing
 						     data, hlen, &_keyid);
 
 			if (!keyid)
 				return false;
 
 			if (skb_flow_dissector_uses_key(flow_dissector,
 							FLOW_DISSECTOR_KEY_GRE_KEYID)) {
 						   sizeof(_eth),
 						   data, hlen, &_eth);
 			if (!eth)
 				return false;
 			proto = eth >h_proto;
 			nhoff  = sizeof(*eth);
 		}
 		opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),
 					      data, hlen, &_opthdr);
 		if (!opthdr)
 			return false;
 
 		ip_proto = opthdr[0];
 		nhoff  = (opthdr[1]   1) << 3;
 		break;
 	}
 
 	key_basic >n_proto = proto;
 	key_basic >ip_proto = ip_proto;
 	key_control >thoff = (u16)nhoff;
 
 	if (skb_flow_dissector_uses_key(flow_dissector,
 					FLOW_DISSECTOR_KEY_PORTS)) {
 		key_ports = skb_flow_dissector_target(flow_dissector,
 							data, hlen);
 	}
 
 	return true;
 }
 EXPORT_SYMBOL(__skb_flow_dissect);
 
After patch : 
 	struct flow_dissector_key_tags *key_tags;
 	struct flow_dissector_key_keyid *key_keyid;
 	u8 ip_proto = 0;
 	bool ret = false;
 
 	if (!data) {
 		data = skb >data;
 ip:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph || iph >ihl < 5)
 			goto out_bad;
 		nhoff  = iph >ihl * 4;
 
 		ip_proto = iph >protocol;
 ipv6:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph)
 			goto out_bad;
 
 		ip_proto = iph >nexthdr;
 		nhoff  = sizeof(struct ipv6hdr);
 
 		vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);
 		if (!vlan)
 			goto out_bad;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_VLANID)) {
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
 			goto out_bad;
 		proto = hdr >proto;
 		nhoff  = PPPOE_SES_HLEN;
 		switch (proto) {
 		case htons(PPP_IPV6):
 			goto ipv6;
 		default:
 			goto out_bad;
 		}
 	}
 	case htons(ETH_P_TIPC): {
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
 			goto out_bad;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_TIPC_ADDRS)) {
 			key_addrs >tipcaddrs.srcnode = hdr >srcnode;
 			key_control >addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;
 		}
 		goto out_good;
 	}
 
 	case htons(ETH_P_MPLS_UC):
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,
 					   hlen, &_hdr);
 		if (!hdr)
 			goto out_bad;
 
 		if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>
 		     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {
 					htonl(MPLS_LS_LABEL_MASK);
 			}
 
 			goto out_good;
 		}
 
 		goto out_good;
 	}
 
 	case htons(ETH_P_FCOE):
 		key_control >thoff = (u16)(nhoff   FCOE_HEADER_LEN);
 		/* fall through */
 	default:
 		goto out_bad;
 	}
 
 ip_proto_again:
 
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
 			goto out_bad;
 		/*
 		 * Only look inside GRE if version zero and no
 		 * routing
 						     data, hlen, &_keyid);
 
 			if (!keyid)
 				goto out_bad;
 
 			if (skb_flow_dissector_uses_key(flow_dissector,
 							FLOW_DISSECTOR_KEY_GRE_KEYID)) {
 						   sizeof(_eth),
 						   data, hlen, &_eth);
 			if (!eth)
 				goto out_bad;
 			proto = eth >h_proto;
 			nhoff  = sizeof(*eth);
 		}
 		opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),
 					      data, hlen, &_opthdr);
 		if (!opthdr)
 			goto out_bad;
 
 		ip_proto = opthdr[0];
 		nhoff  = (opthdr[1]   1) << 3;
 		break;
 	}
 
 	if (skb_flow_dissector_uses_key(flow_dissector,
 					FLOW_DISSECTOR_KEY_PORTS)) {
 		key_ports = skb_flow_dissector_target(flow_dissector,
 							data, hlen);
 	}
 
 out_good:
 	ret = true;
 
 out_bad:
 	key_basic >n_proto = proto;
 	key_basic >ip_proto = ip_proto;
 	key_control >thoff = (u16)nhoff;
 
 	return ret;
 }
 EXPORT_SYMBOL(__skb_flow_dissect);
 
