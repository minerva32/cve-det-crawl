CVE Number : CVE-2019-15211
Commit Message : 
media: radio-raremono: change devm_k*alloc to k*alloc
Commit Details : 
Change devm_k*alloc to k*alloc to manually allocate memory

The manual allocation and freeing of memory is necessary because when
the USB radio is disconnected, the memory associated with devm_k*alloc
is freed. Meaning if we still have unresolved references to the radio
device, then we get use-after-free errors.

This patch fixes this by manually allocating memory, and freeing it in
the v4l2.release callback that gets called when the last radio device
exits.

Reported-and-tested-by: syzbot+a4387f5b6b799f6becbf@syzkaller.appspotmail.com

Signed-off-by: Luke Nowakowski-Krijger <lnowakow@eng.ucsd.edu>
Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
hverkuil-cisco@xs4all.nl: cleaned up two small checkpatch.pl warnings
hverkuil-cisco@xs4all.nl: prefix subject with driver name
Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

Before patch : 
 	return 0;
 }
 
 /* File system interface */
 static const struct v4l2_file_operations usb_raremono_fops = {
 	.owner		= THIS_MODULE,
 	struct raremono_device *radio;
 	int retval = 0;
 
 	radio = devm_kzalloc(&intf >dev, sizeof(struct raremono_device), GFP_KERNEL);
 	if (radio)
 		radio >buffer = devm_kmalloc(&intf >dev, BUFFER_LENGTH, GFP_KERNEL);
 
 	if (!radio || !radio >buffer)
 		return  ENOMEM;
 
 	radio >usbdev = interface_to_usbdev(intf);
 	radio >intf = intf;
 	if (retval != 3 ||
 	    (get_unaligned_be16(&radio >buffer[1]) & 0xfff) == 0x0242) {
 		dev_info(&intf >dev, "this is not Thanko's Raremono.\n");
 		return  ENODEV;
 	}
 
 	dev_info(&intf >dev, "Thanko's Raremono connected: (%04X:%04X)\n",
 	retval = v4l2_device_register(&intf >dev, &radio >v4l2_dev);
 	if (retval < 0) {
 		dev_err(&intf >dev, "couldn't register v4l2_device\n");
 		return retval;
 	}
 
 	mutex_init(&radio >lock);
 	radio >vdev.lock = &radio >lock;
 	radio >vdev.release = video_device_release_empty;
 	radio >vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 
 	usb_set_intfdata(intf, &radio >v4l2_dev);
 
 	}
 	dev_err(&intf >dev, "could not register video device\n");
 	v4l2_device_unregister(&radio >v4l2_dev);
 	return retval;
 }
 
After patch : 
 	return 0;
 }
 
 static void raremono_device_release(struct v4l2_device *v4l2_dev)
 {
 	struct raremono_device *radio = to_raremono_dev(v4l2_dev);
 
 	kfree(radio >buffer);
 	kfree(radio);
 }
 
 /* File system interface */
 static const struct v4l2_file_operations usb_raremono_fops = {
 	.owner		= THIS_MODULE,
 	struct raremono_device *radio;
 	int retval = 0;
 
 	radio = kzalloc(sizeof(*radio), GFP_KERNEL);
 	if (!radio)
 		return  ENOMEM;
 	radio >buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);
 	if (!radio >buffer) {
 		kfree(radio);
 		return  ENOMEM;
 	}
 
 	radio >usbdev = interface_to_usbdev(intf);
 	radio >intf = intf;
 	if (retval != 3 ||
 	    (get_unaligned_be16(&radio >buffer[1]) & 0xfff) == 0x0242) {
 		dev_info(&intf >dev, "this is not Thanko's Raremono.\n");
 		retval =  ENODEV;
 		goto free_mem;
 	}
 
 	dev_info(&intf >dev, "Thanko's Raremono connected: (%04X:%04X)\n",
 	retval = v4l2_device_register(&intf >dev, &radio >v4l2_dev);
 	if (retval < 0) {
 		dev_err(&intf >dev, "couldn't register v4l2_device\n");
 		goto free_mem;
 	}
 
 	mutex_init(&radio >lock);
 	radio >vdev.lock = &radio >lock;
 	radio >vdev.release = video_device_release_empty;
 	radio >vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
 	radio >v4l2_dev.release = raremono_device_release;
 
 	usb_set_intfdata(intf, &radio >v4l2_dev);
 
 	}
 	dev_err(&intf >dev, "could not register video device\n");
 	v4l2_device_unregister(&radio >v4l2_dev);
 
 free_mem:
 	kfree(radio >buffer);
 	kfree(radio);
 	return retval;
 }
 
