CVE Number : CVE-2019-12380
Commit Message : 
efi/x86/Add missing error handling to old_memmap 1:1 mapping code
Commit Details : 
The old_memmap flow in efi_call_phys_prolog() performs numerous memory
allocations, and either does not check for failure at all, or it does
but fails to propagate it back to the caller, which may end up calling
into the firmware with an incomplete 1:1 mapping.

So let's fix this by returning NULL from efi_call_phys_prolog() on
memory allocation failures only, and by handling this condition in the
caller. Also, clean up any half baked sets of page tables that we may
have created before returning with a NULL return value.

Note that any failure at this level will trigger a panic() two levels
up, so none of this makes a huge difference, but it is a nice cleanup
nonetheless.

ardb: update commit log, add efi_call_phys_epilog() call on error path

Signed-off-by: Gen Zhang <blackgod016574@gmail.com>
Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Rob Bradford <robert.bradford@intel.com>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/20190525112559.7917-2-ard.biesheuvel@linaro.org
Signed-off-by: Ingo Molnar <mingo@kernel.org>

Before patch : 
 	pgd_t *save_pgd;
 
 	save_pgd = efi_call_phys_prolog();
 
 	/* Disable interrupts around EFI calls: */
 	local_irq_save(flags);
 
 	if (!efi_enabled(EFI_OLD_MEMMAP)) {
 		efi_switch_mm(&efi_mm);
 		return NULL;
 	}
 
 	early_code_mapping_set_exec(1);
 
 	n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);
 	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);
 
 	/*
 	 * Build 1:1 identity mapping for efi=old_map usage. Note that
 		pgd_offset_k(pgd * PGDIR_SIZE) >pgd &= ~_PAGE_NX;
 	}
 
 out:
 	__flush_tlb_all();
 
 	return save_pgd;
 }
 
 void __init efi_call_phys_epilog(pgd_t *save_pgd)
After patch : 
 	pgd_t *save_pgd;
 
 	save_pgd = efi_call_phys_prolog();
 	if (!save_pgd)
 		return EFI_ABORTED;
 
 	/* Disable interrupts around EFI calls: */
 	local_irq_save(flags);
 
 	if (!efi_enabled(EFI_OLD_MEMMAP)) {
 		efi_switch_mm(&efi_mm);
 		return efi_mm.pgd;
 	}
 
 	early_code_mapping_set_exec(1);
 
 	n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);
 	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);
 	if (!save_pgd)
 		return NULL;
 
 	/*
 	 * Build 1:1 identity mapping for efi=old_map usage. Note that
 		pgd_offset_k(pgd * PGDIR_SIZE) >pgd &= ~_PAGE_NX;
 	}
 
 	__flush_tlb_all();
 	return save_pgd;
 out:
 	efi_call_phys_epilog(save_pgd);
 	return NULL;
 }
 
 void __init efi_call_phys_epilog(pgd_t *save_pgd)
