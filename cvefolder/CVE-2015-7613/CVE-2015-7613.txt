CVE Number : CVE-2015-7613
Commit Message : 
Initialize msg/shm IPC objects before doing ipc_addid()
Commit Details : 
As reported by Dmitry Vyukov, we really shouldn't do ipc_addid() before
having initialized the IPC object state.  Yes, we initialize the IPC
object in a locked state, but with all the lockless RCU lookup work,
that IPC object lock no longer means that the state cannot be seen.

We already did this for the IPC semaphore code (see commit e8577d1f0329:
"ipc/sem.c: fully initialize sem_array before making it visible") but we
clearly forgot about msg and shm.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Cc: Manfred Spraul <manfred@colorfullife.com>
Cc: Davidlohr Bueso <dbueso@suse.de>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Before patch : 
 		return retval;
 	}
 
 	/* ipc_addid() locks msq upon success. */
 	id = ipc_addid(&msg_ids(ns), &msq >q_perm, ns >msg_ctlmni);
 	if (id < 0) {
 		ipc_rcu_putref(msq, msg_rcu_free);
 		return id;
 	}
 
 	msq >q_stime = msq >q_rtime = 0;
 	msq >q_ctime = get_seconds();
 	msq >q_cbytes = msq >q_qnum = 0;
 	INIT_LIST_HEAD(&msq >q_receivers);
 	INIT_LIST_HEAD(&msq >q_senders);
 
 	ipc_unlock_object(&msq >q_perm);
 	rcu_read_unlock();
 
 	if (IS_ERR(file))
 		goto no_file;
 
 	id = ipc_addid(&shm_ids(ns), &shp >shm_perm, ns >shm_ctlmni);
 	if (id < 0) {
 		error = id;
 		goto no_id;
 	}
 
 	shp >shm_cprid = task_tgid_vnr(current);
 	shp >shm_lprid = 0;
 	shp >shm_atim = shp >shm_dtim = 0;
 	shp >shm_nattch = 0;
 	shp >shm_file = file;
 	shp >shm_creator = current;
 	list_add(&shp >shm_clist, &current >sysvshm.shm_clist);
 
 	/*
 	rcu_read_lock();
 	spin_lock(&new >lock);
 
 	id = idr_alloc(&ids >ipcs_idr, new,
 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
 		       GFP_NOWAIT);
 
 	ids >in_use  ;
 
 	current_euid_egid(&euid, &egid);
 	new >cuid = new >uid = euid;
 	new >gid = new >cgid = egid;
 
 	if (next_id < 0) {
 		new >seq = ids >seq  ;
 		if (ids >seq > IPCID_SEQ_MAX)
After patch : 
 		return retval;
 	}
 
 	msq >q_stime = msq >q_rtime = 0;
 	msq >q_ctime = get_seconds();
 	msq >q_cbytes = msq >q_qnum = 0;
 	INIT_LIST_HEAD(&msq >q_receivers);
 	INIT_LIST_HEAD(&msq >q_senders);
 
 	/* ipc_addid() locks msq upon success. */
 	id = ipc_addid(&msg_ids(ns), &msq >q_perm, ns >msg_ctlmni);
 	if (id < 0) {
 		ipc_rcu_putref(msq, msg_rcu_free);
 		return id;
 	}
 
 	ipc_unlock_object(&msq >q_perm);
 	rcu_read_unlock();
 
 	if (IS_ERR(file))
 		goto no_file;
 
 	shp >shm_cprid = task_tgid_vnr(current);
 	shp >shm_lprid = 0;
 	shp >shm_atim = shp >shm_dtim = 0;
 	shp >shm_nattch = 0;
 	shp >shm_file = file;
 	shp >shm_creator = current;
 
 	id = ipc_addid(&shm_ids(ns), &shp >shm_perm, ns >shm_ctlmni);
 	if (id < 0) {
 		error = id;
 		goto no_id;
 	}
 
 	list_add(&shp >shm_clist, &current >sysvshm.shm_clist);
 
 	/*
 	rcu_read_lock();
 	spin_lock(&new >lock);
 
 	current_euid_egid(&euid, &egid);
 	new >cuid = new >uid = euid;
 	new >gid = new >cgid = egid;
 
 	id = idr_alloc(&ids >ipcs_idr, new,
 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
 		       GFP_NOWAIT);
 
 	ids >in_use  ;
 
 	if (next_id < 0) {
 		new >seq = ids >seq  ;
 		if (ids >seq > IPCID_SEQ_MAX)
