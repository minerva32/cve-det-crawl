CVE Number : CVE-2017-5897
Commit Message : 
ip6_gre: fix ip6gre_err() invalid reads
Commit Details : 
Andrey Konovalov reported out of bound accesses in ip6gre_err()

If GRE flags contains GRE_KEY, the following expression
*(((__be32 *)p) + (grehlen / 4) - 1)

accesses data ~40 bytes after the expected point, since
grehlen includes the size of IPv6 headers.

Let's use a "struct gre_base_hdr *greh" pointer to make this
code more readable.

p1 becomes greh->protocol.
grhlen is the GRE header length.

Fixes: c12b395a4664 ("gre: Support GRE over IPv6")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 
 
 static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		u8 type, u8 code, int offset, __be32 info)
 {
 	const struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb >data;
 	__be16 *p = (__be16 *)(skb >data   offset);
 	int grehlen = offset   4;
 	struct ip6_tnl *t;
 	__be16 flags;
 
 	flags = p[0];
 	if (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {
 		if (flags&(GRE_VERSION|GRE_ROUTING))
 			return;
 		if (flags&GRE_KEY) {
 			grehlen  = 4;
 			if (flags&GRE_CSUM)
 				grehlen  = 4;
 		}
 	}
 
 	/* If only 8 bytes returned, keyed message will be dropped here */
 	if (!pskb_may_pull(skb, grehlen))
 		return;
 	ipv6h = (const struct ipv6hdr *)skb >data;
 	p = (__be16 *)(skb >data   offset);
 
 	t = ip6gre_tunnel_lookup(skb >dev, &ipv6h >daddr, &ipv6h >saddr,
 				flags & GRE_KEY ?
 				*(((__be32 *)p)   (grehlen / 4)   1) : 0,
 				p[1]);
 	if (!t)
 		return;
 
After patch : 
 
 
 static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		       u8 type, u8 code, int offset, __be32 info)
 {
 	const struct gre_base_hdr *greh;
 	const struct ipv6hdr *ipv6h;
 	int grehlen = sizeof(*greh);
 	struct ip6_tnl *t;
 	int key_off = 0;
 	__be16 flags;
 	__be32 key;
 
 	if (!pskb_may_pull(skb, offset   grehlen))
 		return;
 	greh = (const struct gre_base_hdr *)(skb >data   offset);
 	flags = greh >flags;
 	if (flags & (GRE_VERSION | GRE_ROUTING))
 		return;
 	if (flags & GRE_CSUM)
 		grehlen  = 4;
 	if (flags & GRE_KEY) {
 		key_off = grehlen   offset;
 		grehlen  = 4;
 	}
 
 	if (!pskb_may_pull(skb, offset   grehlen))
 		return;
 	ipv6h = (const struct ipv6hdr *)skb >data;
 	greh = (const struct gre_base_hdr *)(skb >data   offset);
 	key = key_off ? *(__be32 *)(skb >data   key_off) : 0;
 
 	t = ip6gre_tunnel_lookup(skb >dev, &ipv6h >daddr, &ipv6h >saddr,
 				 key, greh >protocol);
 	if (!t)
 		return;
 
