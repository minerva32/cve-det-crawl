CVE Number : CVE-2021-22555
Commit Message : 
netfilter: x_tables: fix compat match/target pad out-of-bound write
Commit Details : 
xt_compat_match/target_from_user doesn't check that zeroing the area
to start of next rule won't write past end of allocated ruleset blob.

Remove this code and zero the entire blob beforehand.

Reported-by: syzbot+cfc0247ac173f597aaaa@syzkaller.appspotmail.com
Reported-by: Andy Nguyen <theflow@google.com>
Fixes: 9fa492cdc160c ("NETFILTER: x_tables: simplify compat API")
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

Before patch : 
 {
 	const struct xt_match *match = m >u.kernel.match;
 	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
 	int pad, off = xt_compat_match_offset(match);
 	u_int16_t msize = cm >u.user.match_size;
 	char name[sizeof(m >u.user.name)];
 
 		match >compat_from_user(m >data, cm >data);
 	else
 		memcpy(m >data, cm >data, msize   sizeof(*cm));
 	pad = XT_ALIGN(match >matchsize)   match >matchsize;
 	if (pad > 0)
 		memset(m >data   match >matchsize, 0, pad);
 
 	msize  = off;
 	m >u.user.match_size = msize;
 {
 	const struct xt_target *target = t >u.kernel.target;
 	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
 	int pad, off = xt_compat_target_offset(target);
 	u_int16_t tsize = ct >u.user.target_size;
 	char name[sizeof(t >u.user.name)];
 
 		target >compat_from_user(t >data, ct >data);
 	else
 		memcpy(t >data, ct >data, tsize   sizeof(*ct));
 	pad = XT_ALIGN(target >targetsize)   target >targetsize;
 	if (pad > 0)
 		memset(t >data   target >targetsize, 0, pad);
 
 	tsize  = off;
 	t >u.user.target_size = tsize;
After patch : 
 {
 	const struct xt_match *match = m >u.kernel.match;
 	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
 	int off = xt_compat_match_offset(match);
 	u_int16_t msize = cm >u.user.match_size;
 	char name[sizeof(m >u.user.name)];
 
 		match >compat_from_user(m >data, cm >data);
 	else
 		memcpy(m >data, cm >data, msize   sizeof(*cm));
 
 	msize  = off;
 	m >u.user.match_size = msize;
 {
 	const struct xt_target *target = t >u.kernel.target;
 	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
 	int off = xt_compat_target_offset(target);
 	u_int16_t tsize = ct >u.user.target_size;
 	char name[sizeof(t >u.user.name)];
 
 		target >compat_from_user(t >data, ct >data);
 	else
 		memcpy(t >data, ct >data, tsize   sizeof(*ct));
 
 	tsize  = off;
 	t >u.user.target_size = tsize;
