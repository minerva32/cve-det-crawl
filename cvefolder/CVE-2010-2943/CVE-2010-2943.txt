CVE Number : CVE-2010-2943
Commit Message : 
xfs: remove block number from inode lookup code
Commit Details : 
The block number comes from bulkstat based inode lookups to shortcut
the mapping calculations. We ar enot able to trust anything from
bulkstat, so drop the block number as well so that the correct
lookups and mappings are always done.

Signed-off-by: Dave Chinner <dchinner@redhat.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>

Before patch : 
 	 * send invalid file handles and we have to handle it gracefully..
 	 */
 	error = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED,
 			 XFS_ILOCK_SHARED, &ip, 0);
 	if (error) {
 		/*
 		 * EINVAL means the inode cluster doesn't exist anymore.
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* buffer to place output in */
 	int		ubsize,		/* size of buffer */
 	xfs_daddr_t	bno,		/* starting bno of inode cluster */
 	int		*ubused,	/* bytes used by me */
 	int		*stat)		/* BULKSTAT_RV_... */
 {
 	return xfs_bulkstat_one_int(mp, ino, buffer, ubsize,
 				    xfs_bulkstat_one_fmt_compat, bno,
 				    ubused, stat);
 }
 
 		int res;
 
 		error = xfs_bulkstat_one_compat(mp, inlast, bulkreq.ubuffer,
 				sizeof(compat_xfs_bstat_t), 0, NULL, &res);
 	} else if (cmd == XFS_IOC_FSBULKSTAT_32) {
 		error = xfs_bulkstat(mp, &inlast, &count,
 			xfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* not used */
 	int		ubsize,		/* not used */
 	xfs_daddr_t	bno,		/* starting block of inode cluster */
 	int		*ubused,	/* not used */
 	int		*res)		/* result code value */
 {
 	 * the case in all other instances. It's OK that we do this because
 	 * quotacheck is done only at mount time.
 	 */
 	if ((error = xfs_iget(mp, NULL, ino, 0, XFS_ILOCK_EXCL, &ip, bno))) {
 		*res = BULKSTAT_RV_NOTHING;
 		return error;
 	}
 		    mp >m_sb.sb_uquotino != NULLFSINO) {
 			ASSERT(mp >m_sb.sb_uquotino > 0);
 			if ((error = xfs_iget(mp, NULL, mp >m_sb.sb_uquotino,
 					     0, 0, &uip, 0)))
 				return XFS_ERROR(error);
 		}
 		if (XFS_IS_OQUOTA_ON(mp) &&
 		    mp >m_sb.sb_gquotino != NULLFSINO) {
 			ASSERT(mp >m_sb.sb_gquotino > 0);
 			if ((error = xfs_iget(mp, NULL, mp >m_sb.sb_gquotino,
 					     0, 0, &gip, 0))) {
 				if (uip)
 					IRELE(uip);
 				return XFS_ERROR(error);
 	}
 
 	if ((flags & XFS_DQ_USER) && mp >m_sb.sb_uquotino != NULLFSINO) {
 		error = xfs_iget(mp, NULL, mp >m_sb.sb_uquotino, 0, 0, &qip, 0);
 		if (!error) {
 			error = xfs_truncate_file(mp, qip);
 			IRELE(qip);
 
 	if ((flags & (XFS_DQ_GROUP|XFS_DQ_PROJ)) &&
 	    mp >m_sb.sb_gquotino != NULLFSINO) {
 		error2 = xfs_iget(mp, NULL, mp >m_sb.sb_gquotino, 0, 0, &qip, 0);
 		if (!error2) {
 			error2 = xfs_truncate_file(mp, qip);
 			IRELE(qip);
 	}
 	if (!uip && mp >m_sb.sb_uquotino != NULLFSINO) {
 		if (xfs_iget(mp, NULL, mp >m_sb.sb_uquotino,
 					0, 0, &uip, 0) == 0)
 			tempuqip = B_TRUE;
 	}
 	if (!gip && mp >m_sb.sb_gquotino != NULLFSINO) {
 		if (xfs_iget(mp, NULL, mp >m_sb.sb_gquotino,
 					0, 0, &gip, 0) == 0)
 			tempgqip = B_TRUE;
 	}
 	if (uip) {
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* not used */
 	int		ubsize,		/* not used */
 	xfs_daddr_t	bno,		/* starting block of inode cluster */
 	int		*ubused,	/* not used */
 	int		*res)		/* bulkstat result code */
 {
 	ipreleased = B_FALSE;
  again:
 	lock_flags = XFS_ILOCK_SHARED;
 	if ((error = xfs_iget(mp, NULL, ino, 0, lock_flags, &ip, bno))) {
 		*res = BULKSTAT_RV_NOTHING;
 		return (error);
 	}
 	}
 
 	/*
 	 * If we get a block number passed we can use it to
 	 * find the buffer easily.
 	 */
 	if (imap >im_blkno) {
 		offset = XFS_INO_TO_OFFSET(mp, ino);
 		ASSERT(offset < mp >m_sb.sb_inopblock);
 
 		cluster_agbno = xfs_daddr_to_agbno(mp, imap >im_blkno);
 		offset  = (agbno   cluster_agbno) * mp >m_sb.sb_inopblock;
 
 		imap >im_len = XFS_FSB_TO_BB(mp, blks_per_cluster);
 		imap >im_boffset = (ushort)(offset << mp >m_sb.sb_inodelog);
 		return 0;
 	}
 
 	/*
 	 * If the inode chunks are aligned then use simple maths to
 	 * find the location. Otherwise we have to do a btree
 	 * lookup to find the location.
 	xfs_trans_t		*tp,
 	xfs_ino_t		ino,
 	struct xfs_inode	**ipp,
 	xfs_daddr_t		bno,
 	int			flags,
 	int			lock_flags)
 {
 	if (!ip)
 		return ENOMEM;
 
 	error = xfs_iread(mp, tp, ip, bno, flags);
 	if (error)
 		goto out_destroy;
 
  *        within the file system for the inode being requested.
  * lock_flags    flags indicating how to lock the inode.  See the comment
  *		 for xfs_ilock() for a list of valid values.
  * bno    the block number starting the buffer containing the inode,
  *	  if known (as by bulkstat), else 0.
  */
 int
 xfs_iget(
 	xfs_ino_t	ino,
 	uint		flags,
 	uint		lock_flags,
 	xfs_inode_t	**ipp,
 	xfs_daddr_t	bno)
 {
 	xfs_inode_t	*ip;
 	int		error;
 		read_unlock(&pag >pag_ici_lock);
 		XFS_STATS_INC(xs_ig_missed);
 
 		error = xfs_iget_cache_miss(mp, pag, tp, ino, &ip, bno,
 							flags, lock_flags);
 		if (error)
 			goto out_error_or_again;
 	xfs_mount_t	*mp,
 	xfs_trans_t	*tp,
 	xfs_inode_t	*ip,
 	xfs_daddr_t	bno,
 	uint		iget_flags)
 {
 	xfs_buf_t	*bp;
 	/*
 	 * Fill in the location information in the in core inode.
 	 */
 	ip >i_imap.im_blkno = bno;
 	error = xfs_imap(mp, tp, ip >i_ino, &ip >i_imap, iget_flags);
 	if (error)
 		return error;
 	ASSERT(bno == 0 || bno == ip >i_imap.im_blkno);
 
 	/*
 	 * Get pointers to the on disk inode and the buffer containing it.
  * xfs_iget.c prototypes.
  */
 int		xfs_iget(struct xfs_mount *, struct xfs_trans *, xfs_ino_t,
 			 uint, uint, xfs_inode_t **, xfs_daddr_t);
 void		xfs_iput(xfs_inode_t *, uint);
 void		xfs_iput_new(xfs_inode_t *, uint);
 void		xfs_ilock(xfs_inode_t *, uint);
 			  struct xfs_inode *, struct xfs_dinode **,
 			  struct xfs_buf **, uint);
 int		xfs_iread(struct xfs_mount *, struct xfs_trans *,
 			  struct xfs_inode *, xfs_daddr_t, uint);
 void		xfs_dinode_to_disk(struct xfs_dinode *,
 				   struct xfs_icdinode *);
 void		xfs_idestroy_fork(struct xfs_inode *, int);
 	void __user		*buffer,	/* buffer to place output in */
 	int			ubsize,		/* size of buffer */
 	bulkstat_one_fmt_pf	formatter,	/* formatter, copy to user */
 	xfs_daddr_t		bno,		/* starting bno of cluster */
 	int			*ubused,	/* bytes used by me */
 	int			*stat)		/* BULKSTAT_RV_... */
 {
 		return XFS_ERROR(ENOMEM);
 
 	error = xfs_iget(mp, NULL, ino,
 			 XFS_IGET_UNTRUSTED, XFS_ILOCK_SHARED, &ip, bno);
 	if (error) {
 		*stat = BULKSTAT_RV_NOTHING;
 		goto out_free;
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* buffer to place output in */
 	int		ubsize,		/* size of buffer */
 	xfs_daddr_t	bno,		/* starting bno of inode cluster */
 	int		*ubused,	/* bytes used by me */
 	int		*stat)		/* BULKSTAT_RV_... */
 {
 	return xfs_bulkstat_one_int(mp, ino, buffer, ubsize,
 				    xfs_bulkstat_one_fmt, bno,
 				    ubused, stat);
 }
 
 #define XFS_BULKSTAT_UBLEFT(ubleft)	((ubleft) >= statstruct_size)
 				 * Get the inode and fill in a single buffer.
 				 */
 				ubused = statstruct_size;
 				error = formatter(mp, ino, ubufp, ubleft, bno,
 						  &ubused, &fmterror);
 				if (fmterror == BULKSTAT_RV_NOTHING) {
 					if (error && error != ENOENT &&
 	 */
 
 	ino = (xfs_ino_t)*lastinop;
 	error = xfs_bulkstat_one(mp, ino, buffer, sizeof(xfs_bstat_t),
 				 0, NULL, &res);
 	if (error) {
 		/*
 		 * Special case way failed, do it the "long" way
 			       xfs_ino_t	ino,
 			       void		__user *buffer,
 			       int		ubsize,
 			       xfs_daddr_t	bno,
 			       int		*ubused,
 			       int		*stat);
 
 	void			__user *buffer,
 	int			ubsize,
 	bulkstat_one_fmt_pf	formatter,
 	xfs_daddr_t		bno,
 	int			*ubused,
 	int			*stat);
 
 	xfs_ino_t		ino,
 	void			__user *buffer,
 	int			ubsize,
 	xfs_daddr_t		bno,
 	int			*ubused,
 	int			*stat);
 
 	int				error;
 
 	ino = XFS_AGINO_TO_INO(mp, agno, agino);
 	error = xfs_iget(mp, NULL, ino, 0, 0, &ip, 0);
 	if (error)
 		goto fail;
 
 	 * Get and sanity check the root inode.
 	 * Save the pointer to it in the mount structure.
 	 */
 	error = xfs_iget(mp, NULL, sbp >sb_rootino, 0, XFS_ILOCK_EXCL, &rip, 0);
 	if (error) {
 		cmn_err(CE_WARN, "XFS: failed to read root inode");
 		goto out_log_dealloc;
 	sbp = &mp >m_sb;
 	if (sbp >sb_rbmino == NULLFSINO)
 		return 0;
 	error = xfs_iget(mp, NULL, sbp >sb_rbmino, 0, 0, &mp >m_rbmip, 0);
 	if (error)
 		return error;
 	ASSERT(mp >m_rbmip != NULL);
 	ASSERT(sbp >sb_rsumino != NULLFSINO);
 	error = xfs_iget(mp, NULL, sbp >sb_rsumino, 0, 0, &mp >m_rsumip, 0);
 	if (error) {
 		IRELE(mp >m_rbmip);
 		return error;
 {
 	int			error;
 
 	error = xfs_iget(mp, tp, ino, flags, lock_flags, ipp, 0);
 	if (!error && tp)
 		xfs_trans_ijoin(tp, *ipp, lock_flags);
 	return error;
 	if (error)
 		goto out;
 
 	error = xfs_iget(dp >i_mount, NULL, inum, 0, 0, ipp, 0);
 	if (error)
 		goto out_free_name;
 
After patch : 
 	 * send invalid file handles and we have to handle it gracefully..
 	 */
 	error = xfs_iget(mp, NULL, ino, XFS_IGET_UNTRUSTED,
 			 XFS_ILOCK_SHARED, &ip);
 	if (error) {
 		/*
 		 * EINVAL means the inode cluster doesn't exist anymore.
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* buffer to place output in */
 	int		ubsize,		/* size of buffer */
 	int		*ubused,	/* bytes used by me */
 	int		*stat)		/* BULKSTAT_RV_... */
 {
 	return xfs_bulkstat_one_int(mp, ino, buffer, ubsize,
 				    xfs_bulkstat_one_fmt_compat,
 				    ubused, stat);
 }
 
 		int res;
 
 		error = xfs_bulkstat_one_compat(mp, inlast, bulkreq.ubuffer,
 				sizeof(compat_xfs_bstat_t), 0, &res);
 	} else if (cmd == XFS_IOC_FSBULKSTAT_32) {
 		error = xfs_bulkstat(mp, &inlast, &count,
 			xfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* not used */
 	int		ubsize,		/* not used */
 	int		*ubused,	/* not used */
 	int		*res)		/* result code value */
 {
 	 * the case in all other instances. It's OK that we do this because
 	 * quotacheck is done only at mount time.
 	 */
 	if ((error = xfs_iget(mp, NULL, ino, 0, XFS_ILOCK_EXCL, &ip))) {
 		*res = BULKSTAT_RV_NOTHING;
 		return error;
 	}
 		    mp >m_sb.sb_uquotino != NULLFSINO) {
 			ASSERT(mp >m_sb.sb_uquotino > 0);
 			if ((error = xfs_iget(mp, NULL, mp >m_sb.sb_uquotino,
 					     0, 0, &uip)))
 				return XFS_ERROR(error);
 		}
 		if (XFS_IS_OQUOTA_ON(mp) &&
 		    mp >m_sb.sb_gquotino != NULLFSINO) {
 			ASSERT(mp >m_sb.sb_gquotino > 0);
 			if ((error = xfs_iget(mp, NULL, mp >m_sb.sb_gquotino,
 					     0, 0, &gip))) {
 				if (uip)
 					IRELE(uip);
 				return XFS_ERROR(error);
 	}
 
 	if ((flags & XFS_DQ_USER) && mp >m_sb.sb_uquotino != NULLFSINO) {
 		error = xfs_iget(mp, NULL, mp >m_sb.sb_uquotino, 0, 0, &qip);
 		if (!error) {
 			error = xfs_truncate_file(mp, qip);
 			IRELE(qip);
 
 	if ((flags & (XFS_DQ_GROUP|XFS_DQ_PROJ)) &&
 	    mp >m_sb.sb_gquotino != NULLFSINO) {
 		error2 = xfs_iget(mp, NULL, mp >m_sb.sb_gquotino, 0, 0, &qip);
 		if (!error2) {
 			error2 = xfs_truncate_file(mp, qip);
 			IRELE(qip);
 	}
 	if (!uip && mp >m_sb.sb_uquotino != NULLFSINO) {
 		if (xfs_iget(mp, NULL, mp >m_sb.sb_uquotino,
 					0, 0, &uip) == 0)
 			tempuqip = B_TRUE;
 	}
 	if (!gip && mp >m_sb.sb_gquotino != NULLFSINO) {
 		if (xfs_iget(mp, NULL, mp >m_sb.sb_gquotino,
 					0, 0, &gip) == 0)
 			tempgqip = B_TRUE;
 	}
 	if (uip) {
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* not used */
 	int		ubsize,		/* not used */
 	int		*ubused,	/* not used */
 	int		*res)		/* bulkstat result code */
 {
 	ipreleased = B_FALSE;
  again:
 	lock_flags = XFS_ILOCK_SHARED;
 	if ((error = xfs_iget(mp, NULL, ino, 0, lock_flags, &ip))) {
 		*res = BULKSTAT_RV_NOTHING;
 		return (error);
 	}
 	}
 
 	/*
 	 * If the inode chunks are aligned then use simple maths to
 	 * find the location. Otherwise we have to do a btree
 	 * lookup to find the location.
 	xfs_trans_t		*tp,
 	xfs_ino_t		ino,
 	struct xfs_inode	**ipp,
 	int			flags,
 	int			lock_flags)
 {
 	if (!ip)
 		return ENOMEM;
 
 	error = xfs_iread(mp, tp, ip, flags);
 	if (error)
 		goto out_destroy;
 
  *        within the file system for the inode being requested.
  * lock_flags    flags indicating how to lock the inode.  See the comment
  *		 for xfs_ilock() for a list of valid values.
  */
 int
 xfs_iget(
 	xfs_ino_t	ino,
 	uint		flags,
 	uint		lock_flags,
 	xfs_inode_t	**ipp)
 {
 	xfs_inode_t	*ip;
 	int		error;
 		read_unlock(&pag >pag_ici_lock);
 		XFS_STATS_INC(xs_ig_missed);
 
 		error = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,
 							flags, lock_flags);
 		if (error)
 			goto out_error_or_again;
 	xfs_mount_t	*mp,
 	xfs_trans_t	*tp,
 	xfs_inode_t	*ip,
 	uint		iget_flags)
 {
 	xfs_buf_t	*bp;
 	/*
 	 * Fill in the location information in the in core inode.
 	 */
 	error = xfs_imap(mp, tp, ip >i_ino, &ip >i_imap, iget_flags);
 	if (error)
 		return error;
 
 	/*
 	 * Get pointers to the on disk inode and the buffer containing it.
  * xfs_iget.c prototypes.
  */
 int		xfs_iget(struct xfs_mount *, struct xfs_trans *, xfs_ino_t,
 			 uint, uint, xfs_inode_t **);
 void		xfs_iput(xfs_inode_t *, uint);
 void		xfs_iput_new(xfs_inode_t *, uint);
 void		xfs_ilock(xfs_inode_t *, uint);
 			  struct xfs_inode *, struct xfs_dinode **,
 			  struct xfs_buf **, uint);
 int		xfs_iread(struct xfs_mount *, struct xfs_trans *,
 			  struct xfs_inode *, uint);
 void		xfs_dinode_to_disk(struct xfs_dinode *,
 				   struct xfs_icdinode *);
 void		xfs_idestroy_fork(struct xfs_inode *, int);
 	void __user		*buffer,	/* buffer to place output in */
 	int			ubsize,		/* size of buffer */
 	bulkstat_one_fmt_pf	formatter,	/* formatter, copy to user */
 	int			*ubused,	/* bytes used by me */
 	int			*stat)		/* BULKSTAT_RV_... */
 {
 		return XFS_ERROR(ENOMEM);
 
 	error = xfs_iget(mp, NULL, ino,
 			 XFS_IGET_UNTRUSTED, XFS_ILOCK_SHARED, &ip);
 	if (error) {
 		*stat = BULKSTAT_RV_NOTHING;
 		goto out_free;
 	xfs_ino_t	ino,		/* inode number to get data for */
 	void		__user *buffer,	/* buffer to place output in */
 	int		ubsize,		/* size of buffer */
 	int		*ubused,	/* bytes used by me */
 	int		*stat)		/* BULKSTAT_RV_... */
 {
 	return xfs_bulkstat_one_int(mp, ino, buffer, ubsize,
 				    xfs_bulkstat_one_fmt, ubused, stat);
 }
 
 #define XFS_BULKSTAT_UBLEFT(ubleft)	((ubleft) >= statstruct_size)
 				 * Get the inode and fill in a single buffer.
 				 */
 				ubused = statstruct_size;
 				error = formatter(mp, ino, ubufp, ubleft,
 						  &ubused, &fmterror);
 				if (fmterror == BULKSTAT_RV_NOTHING) {
 					if (error && error != ENOENT &&
 	 */
 
 	ino = (xfs_ino_t)*lastinop;
 	error = xfs_bulkstat_one(mp, ino, buffer, sizeof(xfs_bstat_t), 0, &res);
 	if (error) {
 		/*
 		 * Special case way failed, do it the "long" way
 			       xfs_ino_t	ino,
 			       void		__user *buffer,
 			       int		ubsize,
 			       int		*ubused,
 			       int		*stat);
 
 	void			__user *buffer,
 	int			ubsize,
 	bulkstat_one_fmt_pf	formatter,
 	int			*ubused,
 	int			*stat);
 
 	xfs_ino_t		ino,
 	void			__user *buffer,
 	int			ubsize,
 	int			*ubused,
 	int			*stat);
 
 	int				error;
 
 	ino = XFS_AGINO_TO_INO(mp, agno, agino);
 	error = xfs_iget(mp, NULL, ino, 0, 0, &ip);
 	if (error)
 		goto fail;
 
 	 * Get and sanity check the root inode.
 	 * Save the pointer to it in the mount structure.
 	 */
 	error = xfs_iget(mp, NULL, sbp >sb_rootino, 0, XFS_ILOCK_EXCL, &rip);
 	if (error) {
 		cmn_err(CE_WARN, "XFS: failed to read root inode");
 		goto out_log_dealloc;
 	sbp = &mp >m_sb;
 	if (sbp >sb_rbmino == NULLFSINO)
 		return 0;
 	error = xfs_iget(mp, NULL, sbp >sb_rbmino, 0, 0, &mp >m_rbmip);
 	if (error)
 		return error;
 	ASSERT(mp >m_rbmip != NULL);
 	ASSERT(sbp >sb_rsumino != NULLFSINO);
 	error = xfs_iget(mp, NULL, sbp >sb_rsumino, 0, 0, &mp >m_rsumip);
 	if (error) {
 		IRELE(mp >m_rbmip);
 		return error;
 {
 	int			error;
 
 	error = xfs_iget(mp, tp, ino, flags, lock_flags, ipp);
 	if (!error && tp)
 		xfs_trans_ijoin(tp, *ipp, lock_flags);
 	return error;
 	if (error)
 		goto out;
 
 	error = xfs_iget(dp >i_mount, NULL, inum, 0, 0, ipp);
 	if (error)
 		goto out_free_name;
 
