CVE Number : CVE-2021-27365
Commit Message : 
scsi: iscsi: Ensure sysfs attributes are limited to PAGE_SIZE
Commit Details : 
As the iSCSI parameters are exported back through sysfs, it should be
enforcing that they never are more than PAGE_SIZE (which should be more
than enough) before accepting updates through netlink.

Change all iSCSI sysfs attributes to use sysfs_emit().

Cc: stable@vger.kernel.org
Reported-by: Adam Nichols <adam@grimm-co.com>
Reviewed-by: Lee Duncan <lduncan@suse.com>
Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Reviewed-by: Mike Christie <michael.christie@oracle.com>
Signed-off-by: Chris Leech <cleech@redhat.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

Before patch : 
 
 	switch(param) {
 	case ISCSI_PARAM_FAST_ABORT:
 		len = sprintf(buf, "%d\n", session >fast_abort);
 		break;
 	case ISCSI_PARAM_ABORT_TMO:
 		len = sprintf(buf, "%d\n", session >abort_timeout);
 		break;
 	case ISCSI_PARAM_LU_RESET_TMO:
 		len = sprintf(buf, "%d\n", session >lu_reset_timeout);
 		break;
 	case ISCSI_PARAM_TGT_RESET_TMO:
 		len = sprintf(buf, "%d\n", session >tgt_reset_timeout);
 		break;
 	case ISCSI_PARAM_INITIAL_R2T_EN:
 		len = sprintf(buf, "%d\n", session >initial_r2t_en);
 		break;
 	case ISCSI_PARAM_MAX_R2T:
 		len = sprintf(buf, "%hu\n", session >max_r2t);
 		break;
 	case ISCSI_PARAM_IMM_DATA_EN:
 		len = sprintf(buf, "%d\n", session >imm_data_en);
 		break;
 	case ISCSI_PARAM_FIRST_BURST:
 		len = sprintf(buf, "%u\n", session >first_burst);
 		break;
 	case ISCSI_PARAM_MAX_BURST:
 		len = sprintf(buf, "%u\n", session >max_burst);
 		break;
 	case ISCSI_PARAM_PDU_INORDER_EN:
 		len = sprintf(buf, "%d\n", session >pdu_inorder_en);
 		break;
 	case ISCSI_PARAM_DATASEQ_INORDER_EN:
 		len = sprintf(buf, "%d\n", session >dataseq_inorder_en);
 		break;
 	case ISCSI_PARAM_DEF_TASKMGMT_TMO:
 		len = sprintf(buf, "%d\n", session >def_taskmgmt_tmo);
 		break;
 	case ISCSI_PARAM_ERL:
 		len = sprintf(buf, "%d\n", session >erl);
 		break;
 	case ISCSI_PARAM_TARGET_NAME:
 		len = sprintf(buf, "%s\n", session >targetname);
 		break;
 	case ISCSI_PARAM_TARGET_ALIAS:
 		len = sprintf(buf, "%s\n", session >targetalias);
 		break;
 	case ISCSI_PARAM_TPGT:
 		len = sprintf(buf, "%d\n", session >tpgt);
 		break;
 	case ISCSI_PARAM_USERNAME:
 		len = sprintf(buf, "%s\n", session >username);
 		break;
 	case ISCSI_PARAM_USERNAME_IN:
 		len = sprintf(buf, "%s\n", session >username_in);
 		break;
 	case ISCSI_PARAM_PASSWORD:
 		len = sprintf(buf, "%s\n", session >password);
 		break;
 	case ISCSI_PARAM_PASSWORD_IN:
 		len = sprintf(buf, "%s\n", session >password_in);
 		break;
 	case ISCSI_PARAM_IFACE_NAME:
 		len = sprintf(buf, "%s\n", session >ifacename);
 		break;
 	case ISCSI_PARAM_INITIATOR_NAME:
 		len = sprintf(buf, "%s\n", session >initiatorname);
 		break;
 	case ISCSI_PARAM_BOOT_ROOT:
 		len = sprintf(buf, "%s\n", session >boot_root);
 		break;
 	case ISCSI_PARAM_BOOT_NIC:
 		len = sprintf(buf, "%s\n", session >boot_nic);
 		break;
 	case ISCSI_PARAM_BOOT_TARGET:
 		len = sprintf(buf, "%s\n", session >boot_target);
 		break;
 	case ISCSI_PARAM_AUTO_SND_TGT_DISABLE:
 		len = sprintf(buf, "%u\n", session >auto_snd_tgt_disable);
 		break;
 	case ISCSI_PARAM_DISCOVERY_SESS:
 		len = sprintf(buf, "%u\n", session >discovery_sess);
 		break;
 	case ISCSI_PARAM_PORTAL_TYPE:
 		len = sprintf(buf, "%s\n", session >portal_type);
 		break;
 	case ISCSI_PARAM_CHAP_AUTH_EN:
 		len = sprintf(buf, "%u\n", session >chap_auth_en);
 		break;
 	case ISCSI_PARAM_DISCOVERY_LOGOUT_EN:
 		len = sprintf(buf, "%u\n", session >discovery_logout_en);
 		break;
 	case ISCSI_PARAM_BIDI_CHAP_EN:
 		len = sprintf(buf, "%u\n", session >bidi_chap_en);
 		break;
 	case ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:
 		len = sprintf(buf, "%u\n", session >discovery_auth_optional);
 		break;
 	case ISCSI_PARAM_DEF_TIME2WAIT:
 		len = sprintf(buf, "%d\n", session >time2wait);
 		break;
 	case ISCSI_PARAM_DEF_TIME2RETAIN:
 		len = sprintf(buf, "%d\n", session >time2retain);
 		break;
 	case ISCSI_PARAM_TSID:
 		len = sprintf(buf, "%u\n", session >tsid);
 		break;
 	case ISCSI_PARAM_ISID:
 		len = sprintf(buf, "%02x%02x%02x%02x%02x%02x\n",
 			      session >isid[0], session >isid[1],
 			      session >isid[2], session >isid[3],
 			      session >isid[4], session >isid[5]);
 		break;
 	case ISCSI_PARAM_DISCOVERY_PARENT_IDX:
 		len = sprintf(buf, "%u\n", session >discovery_parent_idx);
 		break;
 	case ISCSI_PARAM_DISCOVERY_PARENT_TYPE:
 		if (session >discovery_parent_type)
 			len = sprintf(buf, "%s\n",
 				      session >discovery_parent_type);
 		else
 			len = sprintf(buf, "\n");
 		break;
 	default:
 		return  ENOSYS;
 	case ISCSI_PARAM_CONN_ADDRESS:
 	case ISCSI_HOST_PARAM_IPADDRESS:
 		if (sin)
 			len = sprintf(buf, "%pI4\n", &sin >sin_addr.s_addr);
 		else
 			len = sprintf(buf, "%pI6\n", &sin6 >sin6_addr);
 		break;
 	case ISCSI_PARAM_CONN_PORT:
 	case ISCSI_PARAM_LOCAL_PORT:
 		if (sin)
 			len = sprintf(buf, "%hu\n", be16_to_cpu(sin >sin_port));
 		else
 			len = sprintf(buf, "%hu\n",
 				      be16_to_cpu(sin6 >sin6_port));
 		break;
 	default:
 
 	switch(param) {
 	case ISCSI_PARAM_PING_TMO:
 		len = sprintf(buf, "%u\n", conn >ping_timeout);
 		break;
 	case ISCSI_PARAM_RECV_TMO:
 		len = sprintf(buf, "%u\n", conn >recv_timeout);
 		break;
 	case ISCSI_PARAM_MAX_RECV_DLENGTH:
 		len = sprintf(buf, "%u\n", conn >max_recv_dlength);
 		break;
 	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
 		len = sprintf(buf, "%u\n", conn >max_xmit_dlength);
 		break;
 	case ISCSI_PARAM_HDRDGST_EN:
 		len = sprintf(buf, "%d\n", conn >hdrdgst_en);
 		break;
 	case ISCSI_PARAM_DATADGST_EN:
 		len = sprintf(buf, "%d\n", conn >datadgst_en);
 		break;
 	case ISCSI_PARAM_IFMARKER_EN:
 		len = sprintf(buf, "%d\n", conn >ifmarker_en);
 		break;
 	case ISCSI_PARAM_OFMARKER_EN:
 		len = sprintf(buf, "%d\n", conn >ofmarker_en);
 		break;
 	case ISCSI_PARAM_EXP_STATSN:
 		len = sprintf(buf, "%u\n", conn >exp_statsn);
 		break;
 	case ISCSI_PARAM_PERSISTENT_PORT:
 		len = sprintf(buf, "%d\n", conn >persistent_port);
 		break;
 	case ISCSI_PARAM_PERSISTENT_ADDRESS:
 		len = sprintf(buf, "%s\n", conn >persistent_address);
 		break;
 	case ISCSI_PARAM_STATSN:
 		len = sprintf(buf, "%u\n", conn >statsn);
 		break;
 	case ISCSI_PARAM_MAX_SEGMENT_SIZE:
 		len = sprintf(buf, "%u\n", conn >max_segment_size);
 		break;
 	case ISCSI_PARAM_KEEPALIVE_TMO:
 		len = sprintf(buf, "%u\n", conn >keepalive_tmo);
 		break;
 	case ISCSI_PARAM_LOCAL_PORT:
 		len = sprintf(buf, "%u\n", conn >local_port);
 		break;
 	case ISCSI_PARAM_TCP_TIMESTAMP_STAT:
 		len = sprintf(buf, "%u\n", conn >tcp_timestamp_stat);
 		break;
 	case ISCSI_PARAM_TCP_NAGLE_DISABLE:
 		len = sprintf(buf, "%u\n", conn >tcp_nagle_disable);
 		break;
 	case ISCSI_PARAM_TCP_WSF_DISABLE:
 		len = sprintf(buf, "%u\n", conn >tcp_wsf_disable);
 		break;
 	case ISCSI_PARAM_TCP_TIMER_SCALE:
 		len = sprintf(buf, "%u\n", conn >tcp_timer_scale);
 		break;
 	case ISCSI_PARAM_TCP_TIMESTAMP_EN:
 		len = sprintf(buf, "%u\n", conn >tcp_timestamp_en);
 		break;
 	case ISCSI_PARAM_IP_FRAGMENT_DISABLE:
 		len = sprintf(buf, "%u\n", conn >fragment_disable);
 		break;
 	case ISCSI_PARAM_IPV4_TOS:
 		len = sprintf(buf, "%u\n", conn >ipv4_tos);
 		break;
 	case ISCSI_PARAM_IPV6_TC:
 		len = sprintf(buf, "%u\n", conn >ipv6_traffic_class);
 		break;
 	case ISCSI_PARAM_IPV6_FLOW_LABEL:
 		len = sprintf(buf, "%u\n", conn >ipv6_flow_label);
 		break;
 	case ISCSI_PARAM_IS_FW_ASSIGNED_IPV6:
 		len = sprintf(buf, "%u\n", conn >is_fw_assigned_ipv6);
 		break;
 	case ISCSI_PARAM_TCP_XMIT_WSF:
 		len = sprintf(buf, "%u\n", conn >tcp_xmit_wsf);
 		break;
 	case ISCSI_PARAM_TCP_RECV_WSF:
 		len = sprintf(buf, "%u\n", conn >tcp_recv_wsf);
 		break;
 	case ISCSI_PARAM_LOCAL_IPADDR:
 		len = sprintf(buf, "%s\n", conn >local_ipaddr);
 		break;
 	default:
 		return  ENOSYS;
 
 	switch (param) {
 	case ISCSI_HOST_PARAM_NETDEV_NAME:
 		len = sprintf(buf, "%s\n", ihost >netdev);
 		break;
 	case ISCSI_HOST_PARAM_HWADDRESS:
 		len = sprintf(buf, "%s\n", ihost >hwaddress);
 		break;
 	case ISCSI_HOST_PARAM_INITIATOR_NAME:
 		len = sprintf(buf, "%s\n", ihost >initiatorname);
 		break;
 	default:
 		return  ENOSYS;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return  EACCES;
 	return sprintf(buf, "%llu\n", (unsigned long long)iscsi_handle(priv >iscsi_transport));
 }
 static DEVICE_ATTR(handle, S_IRUGO, show_transport_handle, NULL);
 
 		      struct device_attribute *attr,char *buf)		\
 {									\
 	struct iscsi_internal *priv = dev_to_iscsi_internal(dev);	\
 	return sprintf(buf, format"\n", priv >iscsi_transport >name);	\
 }									\
 static DEVICE_ATTR(name, S_IRUGO, show_transport_##name, NULL);
 
 show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
 	return sprintf(buf, "%llu\n", (unsigned long long) ep >id);
 }
 static ISCSI_ATTR(ep, handle, S_IRUGO, show_ep_handle, NULL);
 
 	struct iscsi_cls_session *session;
 	int err = 0, value = 0;
 
 	session = iscsi_session_lookup(ev >u.set_param.sid);
 	conn = iscsi_conn_lookup(ev >u.set_param.sid, ev >u.set_param.cid);
 	if (!conn || !session)
 	if (!transport >set_host_param)
 		return  ENOSYS;
 
 	shost = scsi_host_lookup(ev >u.set_host_param.host_no);
 	if (!shost) {
 		printk(KERN_ERR "set_host_param could not find host no %u\n",
 	    conn >state < ARRAY_SIZE(connection_state_names))
 		state = connection_state_names[conn >state];
 
 	return sprintf(buf, "%s\n", state);
 }
 static ISCSI_CLASS_ATTR(conn, state, S_IRUGO, show_conn_state,
 			NULL);
 			char *buf)
 {
 	struct iscsi_cls_session *session = iscsi_dev_to_session(dev >parent);
 	return sprintf(buf, "%s\n", iscsi_session_state_name(session >state));
 }
 static ISCSI_CLASS_ATTR(priv_sess, state, S_IRUGO, show_priv_session_state,
 			NULL);
 			char *buf)
 {
 	struct iscsi_cls_session *session = iscsi_dev_to_session(dev >parent);
 	return sprintf(buf, "%d\n", session >creator);
 }
 static ISCSI_CLASS_ATTR(priv_sess, creator, S_IRUGO, show_priv_session_creator,
 			NULL);
 			    char *buf)
 {
 	struct iscsi_cls_session *session = iscsi_dev_to_session(dev >parent);
 	return sprintf(buf, "%d\n", session >target_id);
 }
 static ISCSI_CLASS_ATTR(priv_sess, target_id, S_IRUGO,
 			show_priv_session_target_id, NULL);
 	struct iscsi_cls_session *session = 				\
 			iscsi_dev_to_session(dev >parent);		\
 	if (session >field ==  1)					\
 		return sprintf(buf, "off\n");				\
 	return sprintf(buf, format"\n", session >field);		\
 }
 
 #define iscsi_priv_session_attr_store(field)				\
After patch : 
 
 	switch(param) {
 	case ISCSI_PARAM_FAST_ABORT:
 		len = sysfs_emit(buf, "%d\n", session >fast_abort);
 		break;
 	case ISCSI_PARAM_ABORT_TMO:
 		len = sysfs_emit(buf, "%d\n", session >abort_timeout);
 		break;
 	case ISCSI_PARAM_LU_RESET_TMO:
 		len = sysfs_emit(buf, "%d\n", session >lu_reset_timeout);
 		break;
 	case ISCSI_PARAM_TGT_RESET_TMO:
 		len = sysfs_emit(buf, "%d\n", session >tgt_reset_timeout);
 		break;
 	case ISCSI_PARAM_INITIAL_R2T_EN:
 		len = sysfs_emit(buf, "%d\n", session >initial_r2t_en);
 		break;
 	case ISCSI_PARAM_MAX_R2T:
 		len = sysfs_emit(buf, "%hu\n", session >max_r2t);
 		break;
 	case ISCSI_PARAM_IMM_DATA_EN:
 		len = sysfs_emit(buf, "%d\n", session >imm_data_en);
 		break;
 	case ISCSI_PARAM_FIRST_BURST:
 		len = sysfs_emit(buf, "%u\n", session >first_burst);
 		break;
 	case ISCSI_PARAM_MAX_BURST:
 		len = sysfs_emit(buf, "%u\n", session >max_burst);
 		break;
 	case ISCSI_PARAM_PDU_INORDER_EN:
 		len = sysfs_emit(buf, "%d\n", session >pdu_inorder_en);
 		break;
 	case ISCSI_PARAM_DATASEQ_INORDER_EN:
 		len = sysfs_emit(buf, "%d\n", session >dataseq_inorder_en);
 		break;
 	case ISCSI_PARAM_DEF_TASKMGMT_TMO:
 		len = sysfs_emit(buf, "%d\n", session >def_taskmgmt_tmo);
 		break;
 	case ISCSI_PARAM_ERL:
 		len = sysfs_emit(buf, "%d\n", session >erl);
 		break;
 	case ISCSI_PARAM_TARGET_NAME:
 		len = sysfs_emit(buf, "%s\n", session >targetname);
 		break;
 	case ISCSI_PARAM_TARGET_ALIAS:
 		len = sysfs_emit(buf, "%s\n", session >targetalias);
 		break;
 	case ISCSI_PARAM_TPGT:
 		len = sysfs_emit(buf, "%d\n", session >tpgt);
 		break;
 	case ISCSI_PARAM_USERNAME:
 		len = sysfs_emit(buf, "%s\n", session >username);
 		break;
 	case ISCSI_PARAM_USERNAME_IN:
 		len = sysfs_emit(buf, "%s\n", session >username_in);
 		break;
 	case ISCSI_PARAM_PASSWORD:
 		len = sysfs_emit(buf, "%s\n", session >password);
 		break;
 	case ISCSI_PARAM_PASSWORD_IN:
 		len = sysfs_emit(buf, "%s\n", session >password_in);
 		break;
 	case ISCSI_PARAM_IFACE_NAME:
 		len = sysfs_emit(buf, "%s\n", session >ifacename);
 		break;
 	case ISCSI_PARAM_INITIATOR_NAME:
 		len = sysfs_emit(buf, "%s\n", session >initiatorname);
 		break;
 	case ISCSI_PARAM_BOOT_ROOT:
 		len = sysfs_emit(buf, "%s\n", session >boot_root);
 		break;
 	case ISCSI_PARAM_BOOT_NIC:
 		len = sysfs_emit(buf, "%s\n", session >boot_nic);
 		break;
 	case ISCSI_PARAM_BOOT_TARGET:
 		len = sysfs_emit(buf, "%s\n", session >boot_target);
 		break;
 	case ISCSI_PARAM_AUTO_SND_TGT_DISABLE:
 		len = sysfs_emit(buf, "%u\n", session >auto_snd_tgt_disable);
 		break;
 	case ISCSI_PARAM_DISCOVERY_SESS:
 		len = sysfs_emit(buf, "%u\n", session >discovery_sess);
 		break;
 	case ISCSI_PARAM_PORTAL_TYPE:
 		len = sysfs_emit(buf, "%s\n", session >portal_type);
 		break;
 	case ISCSI_PARAM_CHAP_AUTH_EN:
 		len = sysfs_emit(buf, "%u\n", session >chap_auth_en);
 		break;
 	case ISCSI_PARAM_DISCOVERY_LOGOUT_EN:
 		len = sysfs_emit(buf, "%u\n", session >discovery_logout_en);
 		break;
 	case ISCSI_PARAM_BIDI_CHAP_EN:
 		len = sysfs_emit(buf, "%u\n", session >bidi_chap_en);
 		break;
 	case ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:
 		len = sysfs_emit(buf, "%u\n", session >discovery_auth_optional);
 		break;
 	case ISCSI_PARAM_DEF_TIME2WAIT:
 		len = sysfs_emit(buf, "%d\n", session >time2wait);
 		break;
 	case ISCSI_PARAM_DEF_TIME2RETAIN:
 		len = sysfs_emit(buf, "%d\n", session >time2retain);
 		break;
 	case ISCSI_PARAM_TSID:
 		len = sysfs_emit(buf, "%u\n", session >tsid);
 		break;
 	case ISCSI_PARAM_ISID:
 		len = sysfs_emit(buf, "%02x%02x%02x%02x%02x%02x\n",
 			      session >isid[0], session >isid[1],
 			      session >isid[2], session >isid[3],
 			      session >isid[4], session >isid[5]);
 		break;
 	case ISCSI_PARAM_DISCOVERY_PARENT_IDX:
 		len = sysfs_emit(buf, "%u\n", session >discovery_parent_idx);
 		break;
 	case ISCSI_PARAM_DISCOVERY_PARENT_TYPE:
 		if (session >discovery_parent_type)
 			len = sysfs_emit(buf, "%s\n",
 				      session >discovery_parent_type);
 		else
 			len = sysfs_emit(buf, "\n");
 		break;
 	default:
 		return  ENOSYS;
 	case ISCSI_PARAM_CONN_ADDRESS:
 	case ISCSI_HOST_PARAM_IPADDRESS:
 		if (sin)
 			len = sysfs_emit(buf, "%pI4\n", &sin >sin_addr.s_addr);
 		else
 			len = sysfs_emit(buf, "%pI6\n", &sin6 >sin6_addr);
 		break;
 	case ISCSI_PARAM_CONN_PORT:
 	case ISCSI_PARAM_LOCAL_PORT:
 		if (sin)
 			len = sysfs_emit(buf, "%hu\n", be16_to_cpu(sin >sin_port));
 		else
 			len = sysfs_emit(buf, "%hu\n",
 				      be16_to_cpu(sin6 >sin6_port));
 		break;
 	default:
 
 	switch(param) {
 	case ISCSI_PARAM_PING_TMO:
 		len = sysfs_emit(buf, "%u\n", conn >ping_timeout);
 		break;
 	case ISCSI_PARAM_RECV_TMO:
 		len = sysfs_emit(buf, "%u\n", conn >recv_timeout);
 		break;
 	case ISCSI_PARAM_MAX_RECV_DLENGTH:
 		len = sysfs_emit(buf, "%u\n", conn >max_recv_dlength);
 		break;
 	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
 		len = sysfs_emit(buf, "%u\n", conn >max_xmit_dlength);
 		break;
 	case ISCSI_PARAM_HDRDGST_EN:
 		len = sysfs_emit(buf, "%d\n", conn >hdrdgst_en);
 		break;
 	case ISCSI_PARAM_DATADGST_EN:
 		len = sysfs_emit(buf, "%d\n", conn >datadgst_en);
 		break;
 	case ISCSI_PARAM_IFMARKER_EN:
 		len = sysfs_emit(buf, "%d\n", conn >ifmarker_en);
 		break;
 	case ISCSI_PARAM_OFMARKER_EN:
 		len = sysfs_emit(buf, "%d\n", conn >ofmarker_en);
 		break;
 	case ISCSI_PARAM_EXP_STATSN:
 		len = sysfs_emit(buf, "%u\n", conn >exp_statsn);
 		break;
 	case ISCSI_PARAM_PERSISTENT_PORT:
 		len = sysfs_emit(buf, "%d\n", conn >persistent_port);
 		break;
 	case ISCSI_PARAM_PERSISTENT_ADDRESS:
 		len = sysfs_emit(buf, "%s\n", conn >persistent_address);
 		break;
 	case ISCSI_PARAM_STATSN:
 		len = sysfs_emit(buf, "%u\n", conn >statsn);
 		break;
 	case ISCSI_PARAM_MAX_SEGMENT_SIZE:
 		len = sysfs_emit(buf, "%u\n", conn >max_segment_size);
 		break;
 	case ISCSI_PARAM_KEEPALIVE_TMO:
 		len = sysfs_emit(buf, "%u\n", conn >keepalive_tmo);
 		break;
 	case ISCSI_PARAM_LOCAL_PORT:
 		len = sysfs_emit(buf, "%u\n", conn >local_port);
 		break;
 	case ISCSI_PARAM_TCP_TIMESTAMP_STAT:
 		len = sysfs_emit(buf, "%u\n", conn >tcp_timestamp_stat);
 		break;
 	case ISCSI_PARAM_TCP_NAGLE_DISABLE:
 		len = sysfs_emit(buf, "%u\n", conn >tcp_nagle_disable);
 		break;
 	case ISCSI_PARAM_TCP_WSF_DISABLE:
 		len = sysfs_emit(buf, "%u\n", conn >tcp_wsf_disable);
 		break;
 	case ISCSI_PARAM_TCP_TIMER_SCALE:
 		len = sysfs_emit(buf, "%u\n", conn >tcp_timer_scale);
 		break;
 	case ISCSI_PARAM_TCP_TIMESTAMP_EN:
 		len = sysfs_emit(buf, "%u\n", conn >tcp_timestamp_en);
 		break;
 	case ISCSI_PARAM_IP_FRAGMENT_DISABLE:
 		len = sysfs_emit(buf, "%u\n", conn >fragment_disable);
 		break;
 	case ISCSI_PARAM_IPV4_TOS:
 		len = sysfs_emit(buf, "%u\n", conn >ipv4_tos);
 		break;
 	case ISCSI_PARAM_IPV6_TC:
 		len = sysfs_emit(buf, "%u\n", conn >ipv6_traffic_class);
 		break;
 	case ISCSI_PARAM_IPV6_FLOW_LABEL:
 		len = sysfs_emit(buf, "%u\n", conn >ipv6_flow_label);
 		break;
 	case ISCSI_PARAM_IS_FW_ASSIGNED_IPV6:
 		len = sysfs_emit(buf, "%u\n", conn >is_fw_assigned_ipv6);
 		break;
 	case ISCSI_PARAM_TCP_XMIT_WSF:
 		len = sysfs_emit(buf, "%u\n", conn >tcp_xmit_wsf);
 		break;
 	case ISCSI_PARAM_TCP_RECV_WSF:
 		len = sysfs_emit(buf, "%u\n", conn >tcp_recv_wsf);
 		break;
 	case ISCSI_PARAM_LOCAL_IPADDR:
 		len = sysfs_emit(buf, "%s\n", conn >local_ipaddr);
 		break;
 	default:
 		return  ENOSYS;
 
 	switch (param) {
 	case ISCSI_HOST_PARAM_NETDEV_NAME:
 		len = sysfs_emit(buf, "%s\n", ihost >netdev);
 		break;
 	case ISCSI_HOST_PARAM_HWADDRESS:
 		len = sysfs_emit(buf, "%s\n", ihost >hwaddress);
 		break;
 	case ISCSI_HOST_PARAM_INITIATOR_NAME:
 		len = sysfs_emit(buf, "%s\n", ihost >initiatorname);
 		break;
 	default:
 		return  ENOSYS;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return  EACCES;
 	return sysfs_emit(buf, "%llu\n",
 		  (unsigned long long)iscsi_handle(priv >iscsi_transport));
 }
 static DEVICE_ATTR(handle, S_IRUGO, show_transport_handle, NULL);
 
 		      struct device_attribute *attr,char *buf)		\
 {									\
 	struct iscsi_internal *priv = dev_to_iscsi_internal(dev);	\
 	return sysfs_emit(buf, format"\n", priv >iscsi_transport >name);\
 }									\
 static DEVICE_ATTR(name, S_IRUGO, show_transport_##name, NULL);
 
 show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
 	return sysfs_emit(buf, "%llu\n", (unsigned long long) ep >id);
 }
 static ISCSI_ATTR(ep, handle, S_IRUGO, show_ep_handle, NULL);
 
 	struct iscsi_cls_session *session;
 	int err = 0, value = 0;
 
 	if (ev >u.set_param.len > PAGE_SIZE)
 		return  EINVAL;
 
 	session = iscsi_session_lookup(ev >u.set_param.sid);
 	conn = iscsi_conn_lookup(ev >u.set_param.sid, ev >u.set_param.cid);
 	if (!conn || !session)
 	if (!transport >set_host_param)
 		return  ENOSYS;
 
 	if (ev >u.set_host_param.len > PAGE_SIZE)
 		return  EINVAL;
 
 	shost = scsi_host_lookup(ev >u.set_host_param.host_no);
 	if (!shost) {
 		printk(KERN_ERR "set_host_param could not find host no %u\n",
 	    conn >state < ARRAY_SIZE(connection_state_names))
 		state = connection_state_names[conn >state];
 
 	return sysfs_emit(buf, "%s\n", state);
 }
 static ISCSI_CLASS_ATTR(conn, state, S_IRUGO, show_conn_state,
 			NULL);
 			char *buf)
 {
 	struct iscsi_cls_session *session = iscsi_dev_to_session(dev >parent);
 	return sysfs_emit(buf, "%s\n", iscsi_session_state_name(session >state));
 }
 static ISCSI_CLASS_ATTR(priv_sess, state, S_IRUGO, show_priv_session_state,
 			NULL);
 			char *buf)
 {
 	struct iscsi_cls_session *session = iscsi_dev_to_session(dev >parent);
 	return sysfs_emit(buf, "%d\n", session >creator);
 }
 static ISCSI_CLASS_ATTR(priv_sess, creator, S_IRUGO, show_priv_session_creator,
 			NULL);
 			    char *buf)
 {
 	struct iscsi_cls_session *session = iscsi_dev_to_session(dev >parent);
 	return sysfs_emit(buf, "%d\n", session >target_id);
 }
 static ISCSI_CLASS_ATTR(priv_sess, target_id, S_IRUGO,
 			show_priv_session_target_id, NULL);
 	struct iscsi_cls_session *session = 				\
 			iscsi_dev_to_session(dev >parent);		\
 	if (session >field ==  1)					\
 		return sysfs_emit(buf, "off\n");			\
 	return sysfs_emit(buf, format"\n", session >field);		\
 }
 
 #define iscsi_priv_session_attr_store(field)				\
