CVE Number : CVE-2012-0810
Commit Message : 
x86: Do not disable preemption in int3 on 32bit
Commit Details : 
Preemption must be disabled before enabling interrupts in do_trap
on x86_64 because the stack in use for int3 and debug is a per CPU
stack set by th IST. But 32bit does not have an IST and the stack
still belongs to the current task and there is no problem in scheduling
out the task.

Keep preemption enabled on X86_32 when enabling interrupts for
do_trap().

The name of the function is changed from preempt_conditional_sti/cli()
to conditional_sti/cli_ist(), to annotate that this function is used
when the stack is on the IST.

Cc: stable-rt@vger.kernel.org
Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>


Before patch : 
 		local_irq_enable();
 }
 
 static inline void preempt_conditional_sti(struct pt_regs *regs)
 {
 	inc_preempt_count();
 	if (regs >flags & X86_EFLAGS_IF)
 		local_irq_enable();
 }
 		local_irq_disable();
 }
 
 static inline void preempt_conditional_cli(struct pt_regs *regs)
 {
 	if (regs >flags & X86_EFLAGS_IF)
 		local_irq_disable();
 	dec_preempt_count();
 }
 
 static void __kprobes
 	if (notify_die(DIE_TRAP, "stack segment", regs, error_code,
 			12, SIGBUS) == NOTIFY_STOP)
 		return;
 	preempt_conditional_sti(regs);
 	do_trap(12, SIGBUS, "stack segment", regs, error_code, NULL);
 	preempt_conditional_cli(regs);
 }
 
 dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)
 		return;
 #endif
 
 	preempt_conditional_sti(regs);
 	do_trap(3, SIGTRAP, "int3", regs, error_code, NULL);
 	preempt_conditional_cli(regs);
 }
 
 #ifdef CONFIG_X86_64
 		return;
 
 	/* It's safe to allow irq's after DR6 has been saved */
 	preempt_conditional_sti(regs);
 
 	if (regs >flags & X86_VM_MASK) {
 		handle_vm86_trap((struct kernel_vm86_regs *) regs,
 				error_code, 1);
 		preempt_conditional_cli(regs);
 		return;
 	}
 
 	si_code = get_si_code(tsk >thread.debugreg6);
 	if (tsk >thread.debugreg6 & (DR_STEP | DR_TRAP_BITS) || user_icebp)
 		send_sigtrap(tsk, regs, error_code, si_code);
 	preempt_conditional_cli(regs);
 
 	return;
 }
After patch : 
 		local_irq_enable();
 }
 
 static inline void conditional_sti_ist(struct pt_regs *regs)
 {
 #ifdef CONFIG_X86_64
 	/*
 	 * X86_64 uses a per CPU stack on the IST for certain traps
 	 * like int3. The task can not be preempted when using one
 	 * of these stacks, thus preemption must be disabled, otherwise
 	 * the stack can be corrupted if the task is scheduled out,
 	 * and another task comes in and uses this stack.
 	 *
 	 * On x86_32 the task keeps its own stack and it is OK if the
 	 * task schedules out.
 	 */
 	inc_preempt_count();
 #endif
 	if (regs >flags & X86_EFLAGS_IF)
 		local_irq_enable();
 }
 		local_irq_disable();
 }
 
 static inline void conditional_cli_ist(struct pt_regs *regs)
 {
 	if (regs >flags & X86_EFLAGS_IF)
 		local_irq_disable();
 #ifdef CONFIG_X86_64
 	dec_preempt_count();
 #endif
 }
 
 static void __kprobes
 	if (notify_die(DIE_TRAP, "stack segment", regs, error_code,
 			12, SIGBUS) == NOTIFY_STOP)
 		return;
 	conditional_sti_ist(regs);
 	do_trap(12, SIGBUS, "stack segment", regs, error_code, NULL);
 	conditional_cli_ist(regs);
 }
 
 dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)
 		return;
 #endif
 
 	conditional_sti_ist(regs);
 	do_trap(3, SIGTRAP, "int3", regs, error_code, NULL);
 	conditional_cli_ist(regs);
 }
 
 #ifdef CONFIG_X86_64
 		return;
 
 	/* It's safe to allow irq's after DR6 has been saved */
 	conditional_sti_ist(regs);
 
 	if (regs >flags & X86_VM_MASK) {
 		handle_vm86_trap((struct kernel_vm86_regs *) regs,
 				error_code, 1);
 		conditional_cli_ist(regs);
 		return;
 	}
 
 	si_code = get_si_code(tsk >thread.debugreg6);
 	if (tsk >thread.debugreg6 & (DR_STEP | DR_TRAP_BITS) || user_icebp)
 		send_sigtrap(tsk, regs, error_code, si_code);
 	conditional_cli_ist(regs);
 
 	return;
 }
