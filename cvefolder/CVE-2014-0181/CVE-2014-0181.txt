CVE Number : CVE-2014-0181
Commit Message : 
net: Use netlink_ns_capable to verify the permisions of netlink messages
Commit Details : 
It is possible by passing a netlink socket to a more privileged
executable and then to fool that executable into writing to the socket
data that happens to be valid netlink message to do something that
privileged executable did not intend to do.

To keep this from happening replace bare capable and ns_capable calls
with netlink_capable, netlink_net_calls and netlink_ns_capable calls.
Which act the same as the previous calls except they verify that the
opener of the socket had the desired permissions as well.

Reported-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
Signed-off-by: David S. Miller <davem@davemloft.net>

Before patch : 
 	type  = CRYPTO_MSG_BASE;
 	link = &crypto_dispatch[type];
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if ((type == (CRYPTO_MSG_GETALG   CRYPTO_MSG_BASE) &&
 		return;
 
 	/* Can only change if privileged. */
 	if (!capable(CAP_NET_ADMIN)) {
 		err = EPERM;
 		goto out;
 	}
 			goto next_msg;
 		}
 
 		if (!capable(CAP_SYS_ADMIN)) {
 			err =  EPERM;
 			goto next_msg;
 		}
 		if ((task_active_pid_ns(current) != &init_pid_ns))
 			return  EPERM;
 
 		if (!capable(CAP_AUDIT_CONTROL))
 			err =  EPERM;
 		break;
 	case AUDIT_USER:
 	case AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:
 	case AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:
 		if (!capable(CAP_AUDIT_WRITE))
 			err =  EPERM;
 		break;
 	default:  /* bad msg */
 	u8 limhops = 0;
 	int err = 0;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (nlmsg_len(nlh) < sizeof(*r))
 	u8 limhops = 0;
 	int err = 0;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (nlmsg_len(nlh) < sizeof(*r))
 	return 0;
 }
 
 static int do_setlink(struct net_device *dev, struct ifinfomsg *ifm,
 		      struct nlattr **tb, char *ifname, int modified)
 {
 	const struct net_device_ops *ops = dev >netdev_ops;
 			err = PTR_ERR(net);
 			goto errout;
 		}
 		if (!ns_capable(net >user_ns, CAP_NET_ADMIN)) {
 			err =  EPERM;
 			goto errout;
 		}
 	if (err < 0)
 		goto errout;
 
 	err = do_setlink(dev, ifm, tb, ifname, 0);
 errout:
 	return err;
 }
 }
 EXPORT_SYMBOL(rtnl_create_link);
 
 static int rtnl_group_changelink(struct net *net, int group,
 		struct ifinfomsg *ifm,
 		struct nlattr **tb)
 {
 
 	for_each_netdev(net, dev) {
 		if (dev >group == group) {
 			err = do_setlink(dev, ifm, tb, NULL, 0);
 			if (err < 0)
 				return err;
 		}
 				modified = 1;
 			}
 
 			return do_setlink(dev, ifm, tb, ifname, modified);
 		}
 
 		if (!(nlh >nlmsg_flags & NLM_F_CREATE)) {
 			if (ifm >ifi_index == 0 && tb[IFLA_GROUP])
 				return rtnl_group_changelink(net,
 						nla_get_u32(tb[IFLA_GROUP]),
 						ifm, tb);
 			return  ENODEV;
 	int err =  EINVAL;
 	__u8 *addr;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	err = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, NULL);
 	sz_idx = type>>2;
 	kind = type&3;
 
 	if (kind != 2 && !ns_capable(net >user_ns, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (kind == 2 && nlh >nlmsg_flags&NLM_F_DUMP) {
 	struct nlmsghdr *reply_nlh = NULL;
 	const struct reply_func *fn;
 
 	if ((nlh >nlmsg_type == RTM_SETDCB) && !capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	ret = nlmsg_parse(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,
 	struct dn_ifaddr __rcu **ifap;
 	int err =  EINVAL;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!net_eq(net, &init_net))
 	struct dn_ifaddr *ifa;
 	int err;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!net_eq(net, &init_net))
 	struct nlattr *attrs[RTA_MAX 1];
 	int err;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!net_eq(net, &init_net))
 	struct nlattr *attrs[RTA_MAX 1];
 	int err;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!net_eq(net, &init_net))
 	if (nlh >nlmsg_len < sizeof(*nlh) || skb >len < nlh >nlmsg_len)
 		return;
 
 	if (!capable(CAP_NET_ADMIN))
 		RCV_SKB_FAIL( EPERM);
 
 	/* Eventually we might send routing messages too */
 	    skb >len < nlh >nlmsg_len)
 		return;
 
 	if (!ns_capable(net >user_ns, CAP_NET_ADMIN)) {
 		netlink_ack(skb, nlh,  EPERM);
 		return;
 	}
 		return  EOPNOTSUPP;
 
 	if ((ops >flags & GENL_ADMIN_PERM) &&
 	    !capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if ((nlh >nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {
 
 	net = sock_net(skb >sk);
 	req = nlmsg_data(cb >nlh);
 	may_report_filterinfo = ns_capable(net >user_ns, CAP_NET_ADMIN);
 
 	mutex_lock(&net >packet.sklist_lock);
 	sk_for_each(sk, &net >packet.sklist) {
 	int err;
 	u8 pnaddr;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return  EPERM;
 
 	ASSERT_RTNL();
 	int err;
 	u8 dst;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return  EPERM;
 
 	ASSERT_RTNL();
 	u32 portid = skb ? NETLINK_CB(skb).portid : 0;
 	int ret = 0, ovr = 0;
 
 	if ((n >nlmsg_type != RTM_GETACTION) && !capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	ret = nlmsg_parse(n, sizeof(struct tcamsg), tca, TCA_ACT_MAX, NULL);
 	int err;
 	int tp_created = 0;
 
 	if ((n >nlmsg_type != RTM_GETTFILTER) && !capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 replay:
 	struct Qdisc *p = NULL;
 	int err;
 
 	if ((n >nlmsg_type != RTM_GETQDISC) && !capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);
 	struct Qdisc *q, *p;
 	int err;
 
 	if (!capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 replay:
 	u32 qid;
 	int err;
 
 	if ((n >nlmsg_type != RTM_GETTCLASS) && !capable(CAP_NET_ADMIN))
 		return  EPERM;
 
 	err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);
 	int hdr_space = nlmsg_total_size(GENL_HDRLEN   TIPC_GENL_HDRLEN);
 	u16 cmd;
 
 	if ((req_userhdr >cmd & 0xC000) && (!capable(CAP_NET_ADMIN)))
 		cmd = TIPC_CMD_NOT_NET_ADMIN;
 	else
 		cmd = req_userhdr >cmd;
 	link = &xfrm_dispatch[type];
 
 	/* All operations require privileges, even GET */
 	if (!ns_capable(net >user_ns, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if ((type == (XFRM_MSG_GETSA   XFRM_MSG_BASE) ||
After patch : 
 	type  = CRYPTO_MSG_BASE;
 	link = &crypto_dispatch[type];
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if ((type == (CRYPTO_MSG_GETALG   CRYPTO_MSG_BASE) &&
 		return;
 
 	/* Can only change if privileged. */
 	if (!__netlink_ns_capable(nsp, &init_user_ns, CAP_NET_ADMIN)) {
 		err = EPERM;
 		goto out;
 	}
 			goto next_msg;
 		}
 
 		if (!netlink_capable(skb, CAP_SYS_ADMIN)) {
 			err =  EPERM;
 			goto next_msg;
 		}
 		if ((task_active_pid_ns(current) != &init_pid_ns))
 			return  EPERM;
 
 		if (!netlink_capable(skb, CAP_AUDIT_CONTROL))
 			err =  EPERM;
 		break;
 	case AUDIT_USER:
 	case AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:
 	case AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:
 		if (!netlink_capable(skb, CAP_AUDIT_WRITE))
 			err =  EPERM;
 		break;
 	default:  /* bad msg */
 	u8 limhops = 0;
 	int err = 0;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (nlmsg_len(nlh) < sizeof(*r))
 	u8 limhops = 0;
 	int err = 0;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (nlmsg_len(nlh) < sizeof(*r))
 	return 0;
 }
 
 static int do_setlink(const struct sk_buff *skb,
 		      struct net_device *dev, struct ifinfomsg *ifm,
 		      struct nlattr **tb, char *ifname, int modified)
 {
 	const struct net_device_ops *ops = dev >netdev_ops;
 			err = PTR_ERR(net);
 			goto errout;
 		}
 		if (!netlink_ns_capable(skb, net >user_ns, CAP_NET_ADMIN)) {
 			err =  EPERM;
 			goto errout;
 		}
 	if (err < 0)
 		goto errout;
 
 	err = do_setlink(skb, dev, ifm, tb, ifname, 0);
 errout:
 	return err;
 }
 }
 EXPORT_SYMBOL(rtnl_create_link);
 
 static int rtnl_group_changelink(const struct sk_buff *skb,
 		struct net *net, int group,
 		struct ifinfomsg *ifm,
 		struct nlattr **tb)
 {
 
 	for_each_netdev(net, dev) {
 		if (dev >group == group) {
 			err = do_setlink(skb, dev, ifm, tb, NULL, 0);
 			if (err < 0)
 				return err;
 		}
 				modified = 1;
 			}
 
 			return do_setlink(skb, dev, ifm, tb, ifname, modified);
 		}
 
 		if (!(nlh >nlmsg_flags & NLM_F_CREATE)) {
 			if (ifm >ifi_index == 0 && tb[IFLA_GROUP])
 				return rtnl_group_changelink(skb, net,
 						nla_get_u32(tb[IFLA_GROUP]),
 						ifm, tb);
 			return  ENODEV;
 	int err =  EINVAL;
 	__u8 *addr;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	err = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, NULL);
 	sz_idx = type>>2;
 	kind = type&3;
 
 	if (kind != 2 && !netlink_net_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (kind == 2 && nlh >nlmsg_flags&NLM_F_DUMP) {
 	struct nlmsghdr *reply_nlh = NULL;
 	const struct reply_func *fn;
 
 	if ((nlh >nlmsg_type == RTM_SETDCB) && !netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	ret = nlmsg_parse(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,
 	struct dn_ifaddr __rcu **ifap;
 	int err =  EINVAL;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!net_eq(net, &init_net))
 	struct dn_ifaddr *ifa;
 	int err;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!net_eq(net, &init_net))
 	struct nlattr *attrs[RTA_MAX 1];
 	int err;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!net_eq(net, &init_net))
 	struct nlattr *attrs[RTA_MAX 1];
 	int err;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!net_eq(net, &init_net))
 	if (nlh >nlmsg_len < sizeof(*nlh) || skb >len < nlh >nlmsg_len)
 		return;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		RCV_SKB_FAIL( EPERM);
 
 	/* Eventually we might send routing messages too */
 	    skb >len < nlh >nlmsg_len)
 		return;
 
 	if (!netlink_net_capable(skb, CAP_NET_ADMIN)) {
 		netlink_ack(skb, nlh,  EPERM);
 		return;
 	}
 		return  EOPNOTSUPP;
 
 	if ((ops >flags & GENL_ADMIN_PERM) &&
 	    !netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if ((nlh >nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {
 
 	net = sock_net(skb >sk);
 	req = nlmsg_data(cb >nlh);
 	may_report_filterinfo = netlink_net_capable(cb >skb, CAP_NET_ADMIN);
 
 	mutex_lock(&net >packet.sklist_lock);
 	sk_for_each(sk, &net >packet.sklist) {
 	int err;
 	u8 pnaddr;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!netlink_capable(skb, CAP_SYS_ADMIN))
 		return  EPERM;
 
 	ASSERT_RTNL();
 	int err;
 	u8 dst;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if (!netlink_capable(skb, CAP_SYS_ADMIN))
 		return  EPERM;
 
 	ASSERT_RTNL();
 	u32 portid = skb ? NETLINK_CB(skb).portid : 0;
 	int ret = 0, ovr = 0;
 
 	if ((n >nlmsg_type != RTM_GETACTION) && !netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	ret = nlmsg_parse(n, sizeof(struct tcamsg), tca, TCA_ACT_MAX, NULL);
 	int err;
 	int tp_created = 0;
 
 	if ((n >nlmsg_type != RTM_GETTFILTER) && !netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 replay:
 	struct Qdisc *p = NULL;
 	int err;
 
 	if ((n >nlmsg_type != RTM_GETQDISC) && !netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);
 	struct Qdisc *q, *p;
 	int err;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 replay:
 	u32 qid;
 	int err;
 
 	if ((n >nlmsg_type != RTM_GETTCLASS) && !netlink_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	err = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);
 	int hdr_space = nlmsg_total_size(GENL_HDRLEN   TIPC_GENL_HDRLEN);
 	u16 cmd;
 
 	if ((req_userhdr >cmd & 0xC000) && (!netlink_capable(skb, CAP_NET_ADMIN)))
 		cmd = TIPC_CMD_NOT_NET_ADMIN;
 	else
 		cmd = req_userhdr >cmd;
 	link = &xfrm_dispatch[type];
 
 	/* All operations require privileges, even GET */
 	if (!netlink_net_capable(skb, CAP_NET_ADMIN))
 		return  EPERM;
 
 	if ((type == (XFRM_MSG_GETSA   XFRM_MSG_BASE) ||
