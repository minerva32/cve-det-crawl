CVE Number : CVE-2014-3185
Commit Message : 
USB: whiteheat: Added bounds checking for bulk command response
Commit Details : 
This patch fixes a potential security issue in the whiteheat USB driver
which might allow a local attacker to cause kernel memory corrpution. This
is due to an unchecked memcpy into a fixed size buffer (of 64 bytes). On
EHCI and XHCI busses it's possible to craft responses greater than 64
bytes leading a buffer overflow.

Signed-off-by: James Forshaw <forshaw@google.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Before patch : 
 		dev_dbg(&urb >dev >dev, "%s   command_info is NULL, exiting.\n", __func__);
 		return;
 	}
 	if (status) {
 		dev_dbg(&urb >dev >dev, "%s   nonzero urb status: %d\n", __func__, status);
 		if (status !=  ENOENT)
 		/* These are unsolicited reports from the firmware, hence no
 		   waiting command to wakeup */
 		dev_dbg(&urb >dev >dev, "%s   event received\n", __func__);
 	} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {
 		memcpy(command_info >result_buffer, &data[1],
 						urb >actual_length   1);
 		command_info >command_finished = WHITEHEAT_CMD_COMPLETE;
After patch : 
 		dev_dbg(&urb >dev >dev, "%s   command_info is NULL, exiting.\n", __func__);
 		return;
 	}
 	if (!urb >actual_length) {
 		dev_dbg(&urb >dev >dev, "%s   empty response, exiting.\n", __func__);
 		return;
 	}
 	if (status) {
 		dev_dbg(&urb >dev >dev, "%s   nonzero urb status: %d\n", __func__, status);
 		if (status !=  ENOENT)
 		/* These are unsolicited reports from the firmware, hence no
 		   waiting command to wakeup */
 		dev_dbg(&urb >dev >dev, "%s   event received\n", __func__);
 	} else if ((data[0] == WHITEHEAT_GET_DTR_RTS) &&
 		(urb >actual_length   1 <= sizeof(command_info >result_buffer))) {
 		memcpy(command_info >result_buffer, &data[1],
 						urb >actual_length   1);
 		command_info >command_finished = WHITEHEAT_CMD_COMPLETE;
