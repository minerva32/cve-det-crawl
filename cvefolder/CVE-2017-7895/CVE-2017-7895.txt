CVE Number : CVE-2017-7895
Commit Message : 
nfsd: stricter decoding of write-like NFSv2/v3 ops
Commit Details : 
The NFSv2/v3 code does not systematically check whether we decode past
the end of the buffer.  This generally appears to be harmless, but there
are a few places where we do arithmetic on the pointers involved and
don't account for the possibility that a length could be negative.  Add
checks to catch these.

Reported-by: Tuomas Haanpää <thaan@synopsys.com>
Reported-by: Ari Kauppi <ari@synopsys.com>
Reviewed-by: NeilBrown <neilb@suse.com>
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>

Before patch : 
 	args >count = ntohl(*p  );
 	args >stable = ntohl(*p  );
 	len = args >len = ntohl(*p  );
 	/*
 	 * The count must equal the amount of data passed.
 	 */
 	/* first copy and check from the first page */
 	old = (char*)p;
 	vec = &rqstp >rq_arg.head[0];
 	avail = vec >iov_len   (old   (char*)vec >iov_base);
 	while (len && avail && *old) {
 		*new   = *old  ;
 	 * bytes.
 	 */
 	hdr = (void*)p   head >iov_base;
 	dlen = head >iov_len   rqstp >rq_arg.page_len   hdr;
 
 	/*
After patch : 
 	args >count = ntohl(*p  );
 	args >stable = ntohl(*p  );
 	len = args >len = ntohl(*p  );
 	if ((void *)p > head >iov_base   head >iov_len)
 		return 0;
 	/*
 	 * The count must equal the amount of data passed.
 	 */
 	/* first copy and check from the first page */
 	old = (char*)p;
 	vec = &rqstp >rq_arg.head[0];
 	if ((void *)old > vec >iov_base   vec >iov_len)
 		return 0;
 	avail = vec >iov_len   (old   (char*)vec >iov_base);
 	while (len && avail && *old) {
 		*new   = *old  ;
 	 * bytes.
 	 */
 	hdr = (void*)p   head >iov_base;
 	if (hdr > head >iov_len)
 		return 0;
 	dlen = head >iov_len   rqstp >rq_arg.page_len   hdr;
 
 	/*
